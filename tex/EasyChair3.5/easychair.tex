% easychair.tex,v 3.5 2017/03/15

\documentclass{easychair}
%\documentclass[EPiC]{easychair}
%\documentclass[EPiCempty]{easychair}
%\documentclass[debug]{easychair}
%\documentclass[verbose]{easychair}
%\documentclass[notimes]{easychair}
%\documentclass[withtimes]{easychair}
%\documentclass[a4paper]{easychair}
%\documentclass[letterpaper]{easychair}

\usepackage{doc}
\usepackage{fullpage}
\usepackage{latexsym}
\usepackage{verbatim}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{stackengine}
\usepackage{scalerel}
\usepackage{code,proof,amsthm,amssymb, amsmath}
\usepackage{mathpartir}
\usepackage{turnstile}
\usepackage{fancyvrb}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{booktabs}
\usepackage{adjustbox}
\usepackage{color}
\usepackage{wrapfig}
\usepackage{bbm}
\usepackage{rotating}
\usetikzlibrary{positioning} 

\allowdisplaybreaks

\input{../generic-defns}
\input{../syn-defns}
\input{../../pfpl/fun-defns}
\input{../../pfpl/pcf-defns}
\input{../../pfpl/prod-defns}
\input{../../pfpl/sum-defns}
\input{../../pfpl/icoi-defns}
\input{../../pfpl/t-defns}


% use this if you have a long article and want to create an index
% \usepackage{makeidx}

% In order to save space or manage large tables or figures in a
% landcape-like text, you can use the rotating and pdflscape
% packages. Uncomment the desired from the below.
%
% \usepackage{rotating}
% \usepackage{pdflscape}

% Some of our commands for this guide.
%
\newcommand{\easychair}{\textsf{easychair}}
\newcommand{\miktex}{MiK{\TeX}}
\newcommand{\texniccenter}{{\TeX}nicCenter}
\newcommand{\makefile}{\texttt{Makefile}}
\newcommand{\latexeditor}{LEd}

\newcommand{\myname}{Andrew Carnegie}
\newcommand{\myandrewid}{andrew}
\newcommand{\hwnumber}{1}
% =========================================================================== %

\newtheorem{theorem}{Theorem}

\newcommand{\ms}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\irl}[1]{\mathtt{#1}}
\newcounter{rule}
\setcounter{rule}{0}
\newcommand{\rn}
  {\addtocounter{rule}{1}(\arabic{rule})}	

\newcounter{infercount}
\setcounter{infercount}{1}
\newcommand{\infern}[2]{\inferrule{#1}{#2}(\text{S}_{\arabic{infercount}}\stepcounter{infercount})}
\newcommand*\ts[2]{%
  \,\scalebox{1}[0.5]{$\sststile[ss]{\textstyle#1}{\textstyle#2}$}\,
}
\newcommand{\inferr}[2]{\inferrule{#2}{#1}}
\newcommand{\inferrr}[3]{\inferrule[#1]{#2}{#3}}
\newcommand{\paircaseabt}[4]{\irl{match_P}(#2,#3.#4)}
\newcommand{\paircasecst}[4]{\irl{match} \; #1\; \{(#2;#3) \hookrightarrow #4\}}
\newcommand{\na}[1]{\mathsf{linearCtxt}(#1)}
\newcommand{\nr}[1]{\mathsf{no\_ref}(#1)}
\newcommand{\stable}[1]{\mathsf{stable}(#1)}
\newcommand{\set}[1]{\mathsf{set}(#1)}
\newcommand{\safe}[1]{\mathsf{safe}(#1)}
\newcommand{\dist}[1]{\mathsf{disjoint}(#1)}
\newcommand{\stack}[1]{\irl{stack}(#1)}
\newcommand{\denote}[1]{\llbracket#1\rrbracket}
\newcommand{\nil}{[]}
\newcommand{\cons}[2]{\pi(#1,#2)}
\newcommand{\sharecst}[4]{\irl{share}\;#1\;\irl{as}\;#2,#3\;\irl{in}\;#4}
\newcommand{\sharecpcst}[4]{\irl{share}\;#1\;\irl{as}\;#2,#3\;\irl{in}\;#4}
\newcommand{\shareabt}[4]{\irl{share}(#1;#2,#3.#4)}
\newcommand{\ssize}[2]{\left\Vert #2 \right\Vert_{#1}}
\newcommand{\card}[1]{card(#1)}
\newcommand{\val}[1]{\irl{val}(#1)}
\newcommand{\gc}[3]{\mathsf{gc}(#1,#2,#3)}
\newcommand{\wfc}[5]{\mathsf{linearComp}(#1,#2,#3,#4,#5)}
\newcommand{\linearComp}[2]{\mathsf{linearComp}(#1,#2)}
\newcommand{\veq}[4]{#3 \sim^{#1}_{#2} #4}
\newcommand{\ctxeq}[2]{(#1) \sim (#2)}
\newcommand{\oh}[1]{\oslash(#1)}
\newcommand{\fogc}{\ms{FO}^{gc}}
\newcommand{\foheap}{\text{RaML}^{\ms{heap}}}
\newcommand{\jan}[1]{{\color{red} [\emph{Jan: #1}]}}
\newcommand{\yue}[1]{{\color{blue} [\emph{Yue: #1}]}}
\newcommand{\gcSem}{\ensuremath{\mathcal{E}_{\ms{gc}}}}
\newcommand{\copySem}{\ensuremath{\mathcal{E}_{\ms{copy}}}}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{attempt}{Attempt}
\newtheorem{corollary}[theorem]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
%\makeindex

%% Front Matter
%%
% Regular title as in the article class.
%
\title{Automatic Space Bound Analysis for Functional Programs with Garbage Collection}

% Authors are joined by \and. Their affiliations are given by \inst, which indexes
% into the list defined using \institute
%
\author{
Yue Niu
\and
Jan Hoffmann
}

% Institutes for affiliations are also joined by \and,
\institute{
  Carnegie Mellon University,
  Pittsburgh, PA, United States\\
  \email{\{yuen,jhoffmann\}@cs.cmu.edu}
 }

%  \authorrunning{} has to be set for the shorter version of the authors' names;
% otherwise a warning will be rendered in the running heads. When processed by
% EasyChair, this command is mandatory: a document without \authorrunning
% will be rejected by EasyChair

\authorrunning{Niu and Hoffmann}

% \titlerunning{} has to be set to either the main title or its shorter
% version for the running heads. When processed by
% EasyChair, this command is mandatory: a document without \titlerunning
% will be rejected by EasyChair
\titlerunning{The {\easychair} Class File}

\begin{document}

\maketitle

\begin{abstract}
  This article introduces a novel system for deriving upper bounds on
  the heap-space requirements of functional programs with garbage
  collection.
  %
  The space cost model is based on a perfect garbage collector that
  immediately deallocates memory cells when they become unreachable.
  %
  Heap-space bounds are derived using type-based automatic amortized
  resource analysis (AARA), a template-based technique that
  efficiently reduces bound inference to linear programming.
  %
	The first technical contribution of the work is a new operational cost
  semantics that models a perfect garbage collector.
  %
  The second technical contribution is an extension of AARA
  to take into account automatic deallocation. A key observation is
  that deallocation of a perfect collector can be modeled with
  destructive pattern matching if data structures are used in a linear
  way. However, the analysis uses destructive pattern matching to
  accurately model deallocation even if data is shared.
  The soundness of the extended AARA with respect to the new cost semantics 
	is proven in two parts via an intermediate linear cost semantics.
  %
  The analysis and the cost semantics have been implemented as an
  extension to Resource Aware ML (RaML). An experimental evaluation
  shows that the system is able to derive tight symbolic heap-space
  bounds for common algorithms. Often the bounds are asymptotic
  improvements over bounds that RaML derives without taking into
  account garbage collection.
\end{abstract}

% The table of contents below is added for your convenience. Please do not use
% the table of contents if you are preparing your paper for publication in the
% EPiC Series or Kalpa Publications series

\iffalse
\setcounter{tocdepth}{3}
{\small
\tableofcontents}
\fi

%\section{To mention}
%
%Processing in EasyChair - number of pages.
%
%Examples of how EasyChair processes papers. Caveats (replacement of EC
%class, errors).

%------------------------------------------------------------------------------
\section{Introduction}
\label{sect:introduction}
The memory footprint of a program is an important performance metric
that determines if a program can be safely executed on a given
system. Ideally, developers should describe or approximate the memory
footprint of programs as functions of the inputs. However, such memory
bounds are often difficult to derive and to prove sound.
%
To assist programmers with deriving memory bounds, the programming
language community has developed automatic and semi-automatic analysis
techniques~\cite{Jost03,Chin08,Albert07b}.
%
These systems are often special cases of more general resource bound
analyses that are based on abstract
interpretation~\cite{GulwaniMC09,BlancHHK10,SinnZV14},
recurrence
solving~\cite{FloresH14,AlbertFR15,DannerLR15,KincaidBBR2017}, type
systems~\cite{Jost10,HoffmannW15,LagoG11,CicekBGGH16,OOPSLA:WWC17,DasHP18},
program logics~\cite{Atkey10,CarbonneauxHZ15,CarbonneauxHRS17,Radicek17}, proof
assistants~\cite{Nipkow15,ChargueraudP15}, and term
rewriting~\cite{AvanziniM13,NoschinskiEG13,FrohnNHBG16}.

This article introduces a novel type system for automatically deriving
upper bounds on the heap-space requirements of functional programs
with garbage collection (GC).
%
Due to the challenges of modeling and predicting garbage collection,
most existing techniques for automating and guiding the derivation of
bounds on the heap memory requirements assume manual memory management
or simply ignore deallocation in the
analysis~\cite{Jost03,Jost06,SimoesVFJH12,Chin05,Chin08,Albert07b}. As
a result, the derived bounds are not accurate when the underlying
system employs garbage collection. The only exceptions we are aware of
are the works by Albert et al.~\cite{Albert09,Albert13}, Braberman
et al.~\cite{Braberman08}, and Unnikrishnan et
al.~\cite{UnnikrishnanSL03,Unnikrishnan09}. They analyze the
heap-space usage of programs with GC in two steps. First, they make
the deallocation of GC explicit; for example with a static analysis
for estimating object lifetimes~\cite{Albert13} or with a program
translation~\cite{Unnikrishnan09}. Second, they extract and solve
recurrence relations to derive a bound. The difference of our work is
that our technique is based on a type system, which is proved sound
with respect to a formal cost semantics. Advantages of a type-based
approach include natural compositionality and the use of type
derivations as certificates for resource bounds.

We model the (highwater mark) memory
usage based on a perfect garbage collector that immediately
deallocates memory cells when they become unreachable. The bounds that
are derived with respect to this cost model are not only a good theoretical
measure of the heap-space consumption of the program but also have practical
relevance. Consider a function $f : A \to B$ and assume we derived a
bound $b_f : \denote{A} \to \mathbb{N}$. In an execution of $f(a)$, we
can then keep track of the memory usage and start the garbage
collector whenever the bound $b_f(a)$ is reached. It is then
guaranteed that the evaluation will succeed using $b_f(a)$ heap-memory
cells.\footnote{We are not considering memory fragmentation, which
  can be avoided using a copying collector.} To improve performance,
we could trigger GC more often (to compactify the heap) 
or allow memory use of more than $b_f(a)$ cells 
(to amortize the cost of garbage collection).

\emph{The first technical contribution} of the work is a new
operational cost semantics that models a perfect garbage collector.
%
The cost semantics is a big-step (or natural) semantics that keeps
track of the reachable memory cells in the style of Spoonhower et
al.~\cite{Spoonhower:2008:SPP:1411204.1411240} and
Minamide~\cite{DBLP:journals/entcs/Minamide99}. Operationally, this
cost is the highwater mark on the heap usage, or the maximum number of
cells used in the mutable store during evaluation. If we traverse the 
evaluation tree in preorder and view each node as a ``step'' 
of the computation, then a cell is used in the current node
if it is reachable from the reminder of the
computation. Our formalization of reachability is identical to the
concept that garbage collectors implement to decide if a cell can be
freed during evaluation. For simplicity, we assume that evaluation of
the cons node allocates one fresh heap cell and that all other
operations do not allocate heap cells. However, the semantics can be
instantiated with more realistic cost metrics. A difference to
existing formulations of cost semantics with
GC~\cite{Morrisett95,Spoonhower:2008:SPP:1411204.1411240,DBLP:journals/entcs/Minamide99}
is that we update the highwater mark when reachability changes at
inner nodes of the derivation of the evaluation judgement instead of at
leaves. Moreover, we use a \emph{freelist}, which represents \emph{named}
cells available for evaluation. This alternative formulation is
equivalent to the existing semantics and mainly motivated by the
soundness proof of our type system for bound analysis.  However, the
cost semantics is a natural approach and different enough from its
predecessors~\cite{Spoonhower:2008:SPP:1411204.1411240,DBLP:journals/entcs/Minamide99}
to be of interest in its own right.

\emph{Our second technical contribution} is the type system for
deriving bounds on the heap-space for programs with perfect GC. The
type system is an extension of type-based automatic amortized resource
analysis
(AARA)~\cite{Jost03,Jost10,VasconcelosJFH15,HoffmannAH10,HoffmannW15,NgoDFH16}. AARA
is a template-based technique that introduces potential functions to
efficiently and automatically reduce bound inference to linear
programming. Existing type systems based on AARA can derive bounds on
the highwater mark of the heap usage for programs with manual
deallocation~\cite{Jost10}, but can only derive a bound on the
number of total heap allocations for programs with
GC~\cite{HoffmannW15}. This is usually a gross over-approximation of
the actual memory requirement. Our extension is based on the
observation that deallocation of a perfect collector can be modeled
with destructive pattern matching (deallocating the matched cell) if
data structures are used in a linear way. In the type system, we
extend this observation to non-linear programs and use destructive
pattern matching to accurately model deallocation even if data is
shared.

\emph{The third technical contribution} is to prove the soundness of
the extended AARA with respect to the GC-based cost semantics. The
proof is non-trivial and proceeds in two parts: First, we prove the
soundness of the type system with respect to a semantics that copies
data structures if they are shared. Second, we prove for all programs
that our GC semantics uses less memory than this copying
semantics. While the proofs are relatively standard, many
details---like relating program states of the two semantics in the
simulation proof---are quite involved. Briefly, we have to provide and maintain 
a mapping $\gamma$ from the heap used in the GC semantics $H_{gc}$ to \emph{subsets} of
the heap used in the copying semantics $H_{copy}$ such that the image of 
$H_{gc}$ under $\gamma$ forms a partition on the second heap. The intuition is that 
given a cell $l \in H_{gc}$, there must be multiple cells $\gamma(l) \in H_{copy}$  
that were allocated during sharing, and thus ``morally the same'' as $l$.

The analysis and the cost semantics have been implemented as an
extension to Resource Aware ML (RaML)~\cite{HoffmannAH10,HoffmannW15}. RaML is an
implementation of AARA for a subset of OCaml that can derive
multivariate polynomial bounds. However, we restrict the technical
development in this paper to a simple first-order language with
tuples and lists. The proofs and ideas carry over to the more
complex case of RaML.\footnote{An exception are function closures that
  we discuss in the Section~\ref{sect:conclusion}.}
%
An experimental evaluation shows that the system is able to derive
tight symbolic heap-space bounds for common algorithms. Our results
suggest that our new analysis provides asymptotic bound improvements
to several classes of commonly used functions and programming
patterns. We examine the reasons for these improvements and design
decisions throughout the system.



\section{Setting the Stage}
\label{sect:fop}

In the technical part of the paper, we focus our attention to a first-order, 
strictly evaluated functional language. 
One can think of this language as a simple subset of OCaml or SML. 
The only recursive data type in the language is the list type. 
However, our work extends to the expected algebraic data types definable in RaML.
Being first order, the language does not allow arbitrary local functional definitions. Instead,
all functions are defined at the top level and are mutually recursive by default.
The types of these functions form a signature for the program, and the semantics and typing 
judgments will be indexed by this signature.
Thus, the function types of the language can be expressed 
as arrows between zero-order (base)  types. 
%
Types are formally defined in Figure~\ref{fig:exp}. Like in all
grammars, we provide the abstract (left) and concrete (right) syntax
for every type former~\cite{PFPL16}.
A \emph{signature}  $\Sigma : \ms{Var} \to \ms{FTypes}$ is a map from variables to 
first-order types. 
A \emph{program} $P$ is a $\Sigma$ indexed map from $\ms{Var}$ to pairs 
$(y_f,e_f)_{f \in \Sigma}$, where $\Sigma(y_f) = \tau \to \tau'$, 
and $\Sigma;y_f : \tau \vdash e_f : \tau'$ (the type system is discussed in Section~$\ref{sect:typing}$). 
We write $P : \Sigma$ to mean $P$ is a program with signature $\Sigma$. 

\begin{figure}[t!]
\vspace{-2ex}
\begin{minipage}[t]{0.33\linewidth}
	\[
\begin{array}{r l l l l}
\hspace{-1em}\ms{BTypes} & \tau \,\,\,\,\, ::= \\
	& \irl{nat}                	 			& \irl{nat}											\\
	& \unittyabt                	 			& \unittycst								\\
  & \booltyabt                       & \booltycst                \\
  & \prodtyabt{\tau_1}{\tau_2}       & \prodtycst{\tau_1}{\tau_2}\\
  &\listtyabt{\tau}		& L(\tau)				\\						
  \\
\hspace{-1em}\ms{FTypes} & \rho \,\,\,\,\, ::= \\
	&\irl{arr}(\tau_1;\tau_2) 				& \arrtycst{\tau_1}{\tau_2}\\ 	
\\
\ms{Val}
        & v   \,\,\,\,\, ::= \\
 	& \irl{val}(n)                                			& n 											\\	
 	& \irl{val}(\irl{T})                               			& \irl{T} 								 \\ 
 	& \irl{val}(\irl{F})                                			& \irl{F}								 \\ 
 	& \irl{val}(\irl{Null})                                  & \irl{Null} 								 \\ 
 	& \irl{val}(l)                                			& l 								 \\ 
 	& \irl{val}(\pairexabt{v_1}{v_2})                             & \pairexcst{v_1}{v_2} 					
% \ms{Loc} & l   \,\,\,\,\, ::= \\
%  	& \irl{loc}(l)                                		\\	\\
% \ms{Var} & x   \,\,\,\,\, ::= \\
%  	& \irl{var}(x)                                		\\	
\end{array}
\]
\end{minipage}
\hfill
\begin{minipage}[t]{0.59\linewidth}
\[
\begin{array}{r l l l}
\ms{Exp}
        & e   \,\,\,\,\, ::= \\
 	& \irl{var}(x)                                			& x 											\\	
  & \irl{nat}[n]							& \numeral{n}											\\	
  & \irl{unit}							& ()											\\	
  & \irl{T}							& \irl{T}											\\	
  & \irl{F}	   					& \irl{F}											\\	
  & \ifexabt{x}{e_1}{e_2} & \ifexcst{x}{e_1}{e_2} \\ 
  % & \irl{lam}(x:\tau.e) 						&\lambda \; x : \tau. e 	\\	
  & \irl{ap}(f;x) 					& \appcst{f}{x} 									\\	
  & \irl{tpl}(x_1;x_2)     	& \pairexcst{x_1}{x_2}                								\\	
 	& \paircaseabt{p}{x_1}{x_2}{e_1}					& \paircasecst{p}{x_1}{x_2}{e_1}   \\	
 	& \nilexabt					& []   									\\	
 	& \consexabt{x_1}{x_2}					& x_1::x_2   									\\	
 	& \listcaseexabt{l}{e_1}{x}{xs}{e_2}					& \listcaseexcst{l}{e_1}{x}{xs}{e_2}   \\	
  & \irl{let}(e_1; x : \tau.e_2)			& \irl{let}\; x = e_1 \; \irl{in}\; e_2   \\	
  & \shareabt{x}{x_1}{x_2}{e} &\sharecst{x}{x_1}{x_2}{e}\\ 
\end{array}
\]
\end{minipage}

	\caption{Simple Types, Values, and Expressions }
\label{fig:exp}
\end{figure}

To simplify the presentation, the expressions of our language (see Figure~\ref{fig:exp}) are in \emph{let normal form} (also \emph{A normal form}).
% We allow an extended syntax in the implementation. 
The one nonstandard construct is $\sharecst{x}{x_1}{x_2}{e}$, which we will explain in more 
detail in the following sections. We introduce two distinct notions of \emph{linearity}, one on 
the syntactic level, and one on the semantic level. Syntactic linearity is linearity in 
expression variables, while semantic linearity is linearity in locations (defined below).
We say that a semantics is linear if it respects semantic linearity.

In line with previous works on space cost
semantics~\cite{Spoonhower:2008:SPP:1411204.1411240,DBLP:journals/entcs/Minamide99},
we employ a heap, which persistently binds
locations to values (normalized terms).  As usual, we derive the cost
of a (terminating) program from the number of heap locations 
used during execution, which in our case is the \emph{maximum difference} 
between the sizes of the initial and final freelist. We let \ms{Loc} be an infinite set of names
for addressing the heap.
%
For the rest of the paper, we use the following:
$\ms{Stack} \triangleq \{ V \mid V : \ms{Var} \to \ms{Val} \}$
and $\ms{Heap} \triangleq \{ H \mid H: \ms{Loc} \to \ms{Val} \}$
for the set of stacks and heaps respectively. 

\textbf{Reachability}
\label{sect:reachability}
Before we define the rules for the cost semantics, we relate the heap locations to 
values with the 3-place reachability relation $reach(H,v,L)$ on $\ms{Heap} \times \ms{Val} \times \wp(\ms{Loc})$, where $\wp$ is the powermultiset. 
This is read as ``under heap $H$, the value $v$ reaches the multiset 
of locations $L$''. 
Write $L = reach_H(v)$ to indicate this is a functional relation 
justified by the (valid) mode $(+,+,-)$. We also say that the reachable set of $v$ is $L$. 
%
\begin{mathpar}
\inferrule{
	A = reach_H(v_1)\\
	B = reach_H(v_2)
}{
	A \uplus B = reach_H(\pairexcst{v_1}{v_2}) 
} 

\inferrule{
	A = reach_H(H(l))\\
}{
	\{l\} \uplus A = reach_H(l)
} 

\inferrule{
	v \in \mathbb{N} \cup \{\irl{T},\irl{F},\irl{Null}\}
}{
	\emptyset = reach_H(v)
} 
\end{mathpar}
%
In the rules, $\uplus$ is multiset union. $L$ is a multiset because we need to keep track of
the \emph{number} of ways a location might be reached in order to prove soundness. However, the
cost semantics can be read by truncating any multiset to a set.
Furthermore, we will sometimes mix
multiset and set operations as the situation calls for. For example, we will write 
$l \in S$ for a multiset $S$ if $S(l) \ge 1$. Complete definitions and notations can
be found in the appendix.

The notion of reachability naturally lifts to expressions and contexts:
\begin{align*}
  &reach_H(V) = \biguplus\limits_{x \in dom(V)} reach_H(V(x))
  &&locs_{V,H}(e) = reach_H(V\restriction_{FV(e)})
\end{align*}
Where $FV : \ms{Exp} \to \mathcal{P}(\ms{Var})$ denotes the set of free-variables of expressions as usual.\\

\textbf{Towards the Garbage Collection Cost Semantics}
Now we are ready to give a first attempt to modeling the cost semantics for a
tracing garbage collector. Before we present our new semantics, we explain an
existing cost semantics we experimented with~\cite{DBLP:journals/entcs/Minamide99}. Judgements have the form
%
$V,H,R \vdash e \Downarrow^s v,H'$,
%
which can be read as follows. Under stack $V \in \ms{Stack}$, heap $H \in \ms{Heap}$, 
and continuation set $R \subseteq \ms{Loc}$, $e$ evaluates to $v$ 
and $H'$ using $s$ heap locations. The idea is that $R$ keeps track of the set of locations 
necessary to complete the evaluation \emph{after} $e$ is evaluated (hence the name continuation).
For example, we have the let rule: 
%
\[
	\inferrule{
		V,H,R \uplus locs_{V,H}(x.e_2) \vdash e_1 \Downarrow^{s_1} v_1,H_1\\
		V[x \mapsto v_1],H,R \vdash e_2 \Downarrow^{s_2} v_2,H_2\\
	}{
		V,H,R \vdash \irl{let}(e_1; x : \tau.e_2) \Downarrow^{\max{s_1,s_2}} v_2,H_2
	}
\]

Notice that to evaluate $e_1$, we have to extend the continuation $R$ with locations in $e_2$, which
will be used \emph{after} $e_1$ is evaluated. The total space used is the max of the 
component, indicating that locations used for $e_1$ can be reused for $e_2$. 
This is clear when we look at the variable rule:
%
\[
	\inferrule{
		V(x) = v
		}{
			V,H,R \vdash x \Downarrow^{|dom(R \uplus reach_H(v))|} v,H
			}
\]
%
It states that evaluating a variable $x$ requires the locations reachable from $x$ as well as 
the continuation set $R$. While this way of counting heap locations does model a tracing garbage 
collector, it is not compatible with the existing type systems for amortized analysis. In these
systems, such as RaML,
the type rules count the heap locations as data is created, i.e.\ at each data constructor.
Thus looking up a variable incurs no cost, since it was accounted for during creation.
On the other hand, the cost of indexing a variable in the semantics includes the cost of
the entire continuation set, which is potentially unbounded. This mismatch
between the dynamics and statics of language prevents us from proving the soundness of the analysis.
We give a new cost semantics that is 1) compatible with the type system and 2) also a more
concrete model of a garbage collector since costs are realized with explicit locations. 

%------------------------------------------------------------------------------

\section{Garbage Collection Cost Semantics}
\label{sect:semantics}

In this section, we present our novel cost semantics by combining
\emph{freelist semantics} from~\cite{Hofmann:2003:SPH:604131.604148}
with the cost semantics for modeling perfect
GC~\cite{DBLP:journals/entcs/Minamide99} that we discussed in the
previous section. The resulting semantics, called \gcSem, is well suited for
proving the soundness of the novel type-based bound analysis.

The garbage collection cost semantics \gcSem{} is defined by a collection of judgement of the form
\[
\mathcal{C} \; \vdash_{P : \Sigma} e \Downarrow v, H', F'
\]

Where $\mathcal{C} \in \ms{Stack} \times \ms{Heap} \times
\wp(\ms{Loc}) \times \mathcal{P}(\ms{Loc})$ is a \emph{configuration}
usually written with variables $V,H,R,F$. 
Because the signature $\Sigma$ for the mapping of function names to first-order functions 
does not change during evaluation, we drop the subscript $P:\Sigma$ from $\vdash_{P:\Sigma}$ 
when the context of evaluation is clear. Given a configuration $\mathcal{C} = (V,H,R,F)$,
the evaluation judgment states that under stack $V$, heap $H$, continuation (multi)set $R$,
freelist $F$, and program $P$ with signature $\Sigma$, the expression $e$ evaluates to value $v$, 
and engenders a new heap $H'$ and freelist $F'$. In comparison with the attempt from 
the previous section, the key ingredient we added is the freelist, which serves 
as the set of available locations. Similar to the predicate $reach$, 
We call $R$ a (multi)set since the fact that 
it's a multiset is only useful during the soundness proof. For evaluation, it is 
convenient to just view $R$ as a set. Define a \emph{computation} as a pair
$(\mathcal{C},e)$ of a configuration $\mathcal{C}$ and an expression $e$.
Next, we give some coherence conditions to a configuration.
For a configuration $(V,H,R,F)$, denote the
garbage w.r.t. a set of locations $L$ 
as $collect(R,L,H,F) = \{l \in H \mid l \notin F \cup R \cup L\}$.

\begin{definition} A configuration $(V,H,R,F)$ is well-formed if 
	\begin{enumerate}
		\item $dom(H) \subseteq reach_H(V) \cup R \cup F$
		\item $reach_H(V) \cup R \subseteq dom(H) \setminus F$
		\item $collect(R,reach_H(V),H,F) = \emptyset$
	\end{enumerate}
\end{definition}

The well-formed conditions ensure the stack and continuation sets are within the active region
of the heap $H \setminus F$, and that
the active region of the heap does not contain garbage -- all garbage locations 
are already in the freelist. From now on, all configurations are implicitly assumed to be coherent
in the sense defined above.

The semantics \gcSem{} is designed to model the heap usage of a program running with a 
tracing counting garbage collector: whenever a heap cell becomes unreachable from the 
root set, it becomes collected and added to the freelist as available for reallocation.
As before, the continuation set $R$ represents the set of locations 
required to compute the continuation \emph{excluding} the current expression.
We define the  \emph{root set} as the union of the locations in the continuation set $R$ 
and the locations in the current expression $e$. 

The inference rules for the semantics are given in Figure~\ref{fig:costsem}.
For example, the rule F:CondT states that, to evaluate a conditional, 
look in the stack for the value of the branching boolean.
In the case it is true, we proceed to evaluate the first branch.
Furthermore, we collect cells in the heap
that are not reachable from the root set ($R \cup locs_{V',H}(e_1)$) 
or already in the current free-list
$F$, and add them ($g$) to the available cells for evaluating $e_1$. 

Another example is the rule F:Let for let expressions:
to evaluate the expressions $\irl{let}(e_1; x {:} \tau.e_2)$, we evaluate the first 
expression with the corresponding restricted stack $V_1$ and an expanded continuation set $R'$. 
The extra locations come from the free variables of $e_2$ (not including the bound variable $x$),
which we cannot collect during the evaluation of $e_1$. Next, we restrict the extended stack 
to only free variables of $e_2$, and evaluate $e_2$ with this stack and the original continuation 
set $R$. The other rules are similar. 

\begin{figure}[t!]
  \centering
\small
\begin{mathpar}
\inferrule{
	V_1 = V\restriction_{FV(e_1)}\\
  R' = R \cup locs_{V,H}(\irl{lam}(x : \tau.e_2))\\
  V_1,H,R',F \vdash e_1 \Downarrow v_1,H_1,F_1\\
	V_2 = (V[x \mapsto v_1])\restriction_{FV(e_2)}\\
  g = \{ l \in H_1 \mid l \notin F_1 \cup R \cup locs_{V_2,H_1}(e_2) \}\\
  V_2,H_1,R, F_1 \cup g \vdash e_2 \Downarrow v_2,H_2,F_2 \\
}{
  V,H,R,F \; \vdash \irl{let}(e_1; x : \tau.e_2) \Downarrow v_2,H_2,F_2
}(\text{F:Let})

\inferrule{
  V(x) = \irl{T}\\
	V' = V\restriction_{FV(e_1)}\\
  g = \{l \in H \mid l \notin F \cup R \cup locs_{V',H}(e_1)\}\\
  V',H,R,F \cup g\; \vdash e_1 \Downarrow v, H',F'
}{
  V,H,R,F \; \vdash \ifexabt{x}{e_1}{e_2} \Downarrow v, H',F'
}(\text{F:CondT})

\inferrule{
	V(x) = \irl{F}\\
	V' = V\restriction_{FV(e_2)}\\
  g = \{l \in H \mid l \notin F \cup R \cup locs_{V',H}(e_2)\}\\
  V',H,R,F \cup g \; \vdash e_2 \Downarrow v, H',F'
}{
  V,H,R,F \; \vdash \ifexabt{x}{e_1}{e_2} \Downarrow v, H' ,F'
}(\text{F:CondF})

% function

\inferrule{
  V(x) = v'\\
  P(f) = (y_f,e_f)\\
	V' = ([y_f \mapsto v']) \restriction_{FV(e_f)}\\
  g = \{l \in H \mid l \notin F \cup R \cup locs_{V,H}(e_f)\}\\
  V'H,R,F \cup g \; \vdash e_f \Downarrow v,H',F'\\
}{
	V,H,R,F \; \vdash  \irl{ap}(f;x)  \Downarrow v,H',F'
}(\text{F:App})

% lists

\inferrule{
}{
  V,H,R,F \; \vdash \nilexabt \Downarrow \irl{val(Null)},H,F
} (\text{F:Nil})

\inferrule{
  v = \pairexcst{V(x_1)}{V(x_2)}\\
	l \in F\\
  H' = H\{l \mapsto v\}
}{
	V,H,R,F \; \vdash \consexcst{x_1}{x_2} \Downarrow l,H' ,F \setminus \{l\}
}(\text{F:Cons})



\inferrule{
  V(x) = \irl{Null}\\
	V' = V\restriction_{FV(e_1)}\\
  g = \{l \in H \mid l \notin F \cup R \cup locs_{V',H}(e_1)\}\\
  V',H,R,F \cup g \; \vdash e_1 \Downarrow v, H',F' \\
}{
  V,H,R,F \; \vdash \listcaseexabt{x}{e_1}{x_h}{x_t}{e_2} \Downarrow v,H',F'
}(\text{F:MatNil})

\inferrule
{ V(x) = v\\
}
{V,H,R,F \; \vdash x \Downarrow v,H,F}(\text{F:Var})

\inferrule{
  V(x) =  l\\
  H(l) = \pairexcst{v_h}{v_t} \\
	V' = (V[x_h \mapsto v_h, x_t \mapsto v_t])\restriction_{FV(e_2)}\\
  g = \{l \in H \mid l \notin F \cup R \cup locs_{V',H}(e_2)\}\\
  V',H,R,F \cup g \; \vdash e_2 \Downarrow v, H',F' \\
}{
  V,H,R,F \; \vdash \listcaseexabt{x}{e_1}{x_h}{x_t}{e_2} \Downarrow v,H',F'
}(\text{F:MatCons})


\inferr{
  V,H,R,F \; \vdash \shareabt{x}{x_1}{x_2}{e} \Downarrow v,H',F'
}{
	V(x) = v'\\
	V' = (V[x_1 \mapsto v',x_2 \mapsto v']) \restriction_{FV(e)}\\
	g = \{l \in H \mid l \notin F \cup R \cup locs_{V',H}(e)\}\\
  V',H,R,F \cup g \; \vdash e \Downarrow v,H',F'
}(\text{F:Share})
\end{mathpar}
  \caption{Cost Semantics for Perfect Garbage Collection}
  \label{fig:costsem}
\end{figure}
Note that in contrast to the semantics in the previous section, evaluating a variable does not incur
any cost. This ensures that we will be able prove the soundness of the type system. 
Also, since we don't allow local function definitions, we do not create closures
during evaluation. % However, our implementation uses closures to implement the global block of 
% function definitions.
Also note that we restrict the domain of
the stack to the appropriate variables during evaluation. This is only
to facilitate the proof of the linearity of the copying semantics introduced later, and not
necessary for the implementation. 

For example, we can implement the \texttt{append} and \texttt{appTwice} function, 
which has variable sharing. First, we analyze the heap usage of \texttt{append} under 
\gcSem{}. We case on the first component of the input. In case it's nil, 
we just return \texttt{l2}, and there are no allocations or deallocations. In case it's
cons of \texttt{x} and \texttt{xs}, we need to allocate one heap location for the
cons cell binding \texttt{x} 
and the recursive result, for which we can use the just matched-on cell. Again, 
the net overhead is zero. Thus, the total space overhead of \texttt{append} is zero.

%
For \texttt{appTwice}, we first share the list \texttt{l} as \texttt{l1} and 
\texttt{l2}. In the first \texttt{let}, the locations in \texttt{l2} are added to the
continuation set, which prevents the 
first call to \texttt{append} from destructing \texttt{l1}. Thus size of \texttt{l1} 
new locations are allocated from the freelist to construct \texttt{l1'}. 
The second call has no net increase in heap allocations since \texttt{l2} can be 
destructed along the way. 
The return value is a pair which is stack-allocated and doesn't require a heap 
allocation. Thus, the total space overhead for \texttt{appTwice} 
is size of the input list \texttt{l}.

From this, we see that the minimum size for the initial freelist to successively evaluate 
a call to \texttt{appTwice} is exactly the length of the input. In general, we 
define the cost of a closed program to be the minimum size of the initial freelist that
guarantees successful evaluation, which is
equivalent to the cost annotation in the previous cost semantics introduced in 
Section~\ref{sect:fop}.

\section{Automatic Amortized Heap-Space Analysis with GC}
\label{sect:aara}

{\bf Automatic Amortized Resource Analysis (AARA)}
%
The idea of AARA~\cite{Jost03,Jost10,HoffmannAH10,HoffmannW15} is to automate the potential method of amortized
analysis using a type system.  Types introduce potential functions that
map data structures of the given type to non-negative numbers. The
type rules ensure that there is always sufficient potential to cover
the evaluation cost of the next step and the potential of the
next program state.

To illustrate the idea, we informally explain the linear potential method for the functions in Figure~\ref{fig:dfs}.
We will use the allocation/heap metric which simply counts the number of cons constructor calls during the evaluation.%
\footnote{This is in contrast to the highwater mark for the GC semantics \gcSem{} that is targeted by our new analysis.}
With this metric, the cost of evaluating \texttt{append(l1,l2)} is $m$, where $m$ is the number 
of cons constructors in \texttt{l1}, and the resource annotated type of \texttt{append} is 
$\prodtycst{L^1(\irl{int})}{L^0(\irl{int})} \xrightarrow{0/0} L^0(\irl{int})$.
This type says that to type \texttt{append(l1,l2)}, we need \texttt{l1} 
to have 1 potential per element, \texttt{l2} to have 0 per element, and the result 
will be a list with 0 potential per element.
Additionally, the function uses 0 constant potential, and 
leaves 0 constant potential after evaluating. This translates to a bound which states that 
the number of allocations \texttt{append} makes is bounded by 1 times size of the first list.
For \texttt{appTwice(l)}, the cost under the heap metric is $2m$, where $m$ is the number of cons 
constructors in \texttt{l}. This is because we have to share the input list across 
two calls of \texttt{append}, which each requires lists with unit potential per element.
For example, if $\texttt{l} : L^2(\irl{int})$, then \texttt{l1} and 
\texttt{l2} both get 1 potential per element so that $\texttt{l1} : L^1(\irl{int})$,
$\texttt{l2} : L^1(\irl{int})$, which covers the cost of the next 2 calls to \texttt{append}, 
and the resulting pair of lists both have 0 potential per element.

More generally, we can give the following types to \texttt{append} and \texttt{appTwice}:
\begin{align*}
	&\texttt{append} : \prodtycst{L^p(\irl{int})}{L^q(\irl{int})} \xrightarrow{r/r'} L^s(\irl{int}), \text{ 
	where } p \ge s + 1,\; q \ge s \text{ and } r \ge r' \\
	&\texttt{appTwice} : L^p(\irl{int}) \xrightarrow{q/q'} \prodtycst{L^r(\irl{int})}{L^s(\irl{int})},
	\text{ where } p \ge r + s + 2 \text{ and } q \ge q'
\end{align*}

\begin{wrapfigure}{r}{0.4\textwidth}
	\vspace{-15pt}
		\begin{center}
\begin{verbatim}
let rec append (l1, l2) =
  match l1 with
  | [] -> l2
  | x::xs -> x::(append (xs, l2))

let appTwice l = 
    share l as l1,l2 in
    let l1' = append (l1, []) in 
    let l2' = append (l2, []) in 
    (l1',l2')
\end{verbatim}
			\end{center}
				\vspace{-15pt}
			\caption{Functions \texttt{append} and \texttt{appTwice}}
		\vspace{-10pt}
\label{fig:dfs}
\end{wrapfigure}

Notice that the constant potentials $r$ and $q$ are unconstrained since the 
functions don't use any potential in the base cases.
With AARA, the type system keeps track of this collection of constraints on
resource annotations and passes them to an off-the-shelf LP-solver 
which finds the minimum solution. This is then translated to concrete resource bounds
like the ones we derived by hand. It has been shown that this technique can be extended
to polynomial potential functions, user-defined data types, and higher-order functions while
still relying on linear constraint solving~\cite{HoffmannAH10,HoffmannW15}.
%

\textbf{Linear Potential Functions}\label{sect:lfp}
Before giving the type rules, we need to formalize linear potential as explained above.
Since potential is associated with the \emph{structure} of a value and not the particular heap 
locations, it is helpful to introduce a mapping from
heap values to semantic values of a type. 
First, we give a denotational semantics for (define the structures of) the first-order types: 
  \begin{minipage}{0.4\linewidth}
\begin{align*}
	\denote{\unittyabt} &= \{\val{\irl{Null}}\}\\
	\denote{\booltyabt} &= \{\val{\irl{T}}, \val{\irl{F}}\}\\
	\denote{\irl{nat}} &= \mathbb{N}\\
\end{align*}
  \end{minipage}%
\begin{minipage}{0.6\linewidth}
\begin{align*}
\denote{\prodtycst{A_1}{A_2}} &= \denote{A_1} \times \denote{A_2}\\
\nilexcst &\in \denote{L(A)}\\
\consexcst{a}{l} &\in \denote{L(A)} \text{ if } a \in \denote{A} \text{ and } l \in \denote{L(A)}\\
\end{align*}
  \end{minipage}\\
The meaning of each type is the least set such that the above holds. As usual, we write $[a_1,...,a_n]$ for $\consexcst{a_1}{,...,\consexcst{a_n}{\nilexcst}}$.

\begin{figure}[t!]
  \centering
  \small
\begin{mathpar}
\inferr{
  H \vDash \val{n} \mapsto n : \irl{nat}
}{
  n \in \mathbb{Z}
}(\text{V:ConstI})

\inferr{
	H \vDash \val{\irl{Null}} \mapsto \val{\irl{Null}} : \unittyabt
}{
}(\text{V:ConstI})

\inferr{
  H \vDash \val{\irl{Null}} \mapsto \val{\irl{Null}} : L(A)
}{
  A \in \ms{BType}
}(\text{V:Nil})

\inferr{
  H \vDash \val{\irl{T}} \mapsto  \val{\irl{T}} : \booltyabt
}{
}(\text{V:True})

\inferr{
  H \vDash \val{\irl{F}} \mapsto \val{\irl{F}}  : \booltyabt
}{
}(\text{V:False})

	\inferr{
		H \vDash \pairexcst{v_1}{v_2} \mapsto \pairexcst{a_1}{a_2} : \prodtycst{A_1}{A_2}
	}{
		H \vDash v_1 \mapsto a_1 : A_1 \\
		H \vDash v_2 \mapsto a_2 : A_2
	}(\text{V:Pair})
	
\inferr{
  H \vDash l \mapsto [a_1,\ldots,a_n] : L(A)
}{
  l \in \ms{Loc}\\
  H(l) = \pairexcst{v_h}{v_t}\\
  H \vDash v_h \mapsto a_1 : A\\
  H \vDash v_t \mapsto [a_2,\ldots,a_n] : L(A)
}(\text{V:Cons})
\end{mathpar}
  \caption{Mapping Locations to Semantic Values}
  \label{fig:semVal}
\end{figure}

In Figure~\ref{fig:semVal} we give the judgements relating heap values to semantic values, in the form \fbox{$H \vDash v \mapsto a : A$}, which can be read as follows: Under heap $H$, heap value $v$ defines the semantic value $a \in \denote{A}$.  
%
Given a stack $V$, we write $H \vDash V : \Gamma$ if $dom(V) \subseteq dom(\Gamma)$ and
for every $x \mapsto v \in V$, 
$H \vDash V(x) \mapsto a : \Gamma(x)$ for some $a \in \llbracket A \rrbracket$.

We introduce linear potential for structures corresponding to the base types. The definition of
linear potential is standard~\cite{Hoffmann11}. Below is the grammar for resource-annotated types:
%
\[
\begin{array}{r l l l c r l l l}
\ms{BTypes} & A \,\,\,\,\, ::= &  \hspace{8em}     &  & \ms{FTypes} & \rho \,\,\,\,\, ::= \\
	& \ldots &    & & 	 &\irl{arr}(A_1;A_2;p;q) 				& A_1 \xrightarrow{p/q} A_2\\ 	
	&\irl{list}^p(A)		& L^p(A)		
\end{array}
\]
%
The intended meaning is that a list of $L^p(A)$ has $p$ units of potential per 
cons cell, and a function of type $A \xrightarrow{p/q} B$ takes constant potential 
$p$ to run and $q$ is the constant potential left afterwards.

With linear potential, each component of a structure is associated with a constant amount of 
potential.  Given a structure $a$ in a heap $H$, where  $H \vDash v \mapsto a : A$, we define 
its potential $\Phi_H(a : A)$ by recursion on $A$: 
%
\begin{align*}
	&\Phi_H(v : A) = 0 &\text{ if } A \in \{\unittycst, \booltyabt, \irl{nat}\}\\
&\Phi_H(\pairexcst{v_1}{v_2} : \prodtycst{A_1}{A_2}) = \Phi_H(v_1 : A_1) + \Phi_H(v_2 : A_2)\\
	&\Phi_H(l : L^p(A)) = p + \Phi_H(v_h : A) + \Phi_H(v_T : L^p(A)) &\text{ if } 
		H(l) = \pairexcst{v_h}{v_h}
	%p\cdot n + \sum_{1 \le i \le n} \Phi_H(a_i : A)  
\end{align*}
%
Write $\Phi_{V,H}(\Gamma)$ for $\Sigma_{x \in dom(V)} \Phi_H(V(x) : \Gamma(x))$.\\
Now define $A \curlyvee A_1,A_2,n$ as the sharing relation for resource-annotated types:
\begin{align*}
	&L^p(A) \curlyvee^n L^q(A_1),L^r(A_2) & \text{if } p = q + r + n \;\text{and}\; 
			A \curlyvee^n A_1,A_2\\
	&\prodtycst{A}{B} \curlyvee^n \prodtycst{A_1}{B_1}, \prodtycst{A_2}{B_2}
		&\text{ if } A \curlyvee^n A_1,A_2 \text{ and } B \curlyvee^n B_1,B_2\\
	&A \curlyvee^n  A,A& \text{ if } A \in \{\unittycst, \booltycst, \irl{nat}\}
\end{align*}
The sharing relation captures the amount of potential needed to copy a type $A$ where each 
cons node in any structure in $\llbracket A \rrbracket$ has a copying overhead $n$.

\textbf{Type Rules}
\label{sect:typing}
The type system $\fogc$ consists of rules of the form \fbox{$\Sigma;\Gamma \sststile{q'}{q} e : A$}, 
read as under signature $\Sigma : \ms{Var} \to \ms{FTypes}$, 
typing environment $\Gamma : \ms{Var} \to \ms{BTypes}$, $e$ has type $A$ starting with $q$ units of 
constant potential and ending with $q'$ units.

Our type system is based on the one of classic linear AARA~\cite{Jost03}. 
We give a review of the rules in Figure~\ref{fig:typeRules}.
Since we are interested in the number of heap locations, 
there is an implicit side condition in all rules
which ensures all constants are assumed to be nonnegative.
	
For example, L:Cons states that to add an element to a list with $p$ potential per element, 
we need $p+1$ units of constant potential: $p$ to maintain the potential of the list,
and 1 for allocating the cons cell. L:MatL states that matching on a list with type $L^p(A)$,
we need to type the nil case with the same constant potentials, and we need to type
the cons case with an additional $p$ units of constant potential, since we get 
the spill of $p$ from the definition of linear potential. 
As the last example, we look at L:Share, which states that to share 
a variable $x$ of type $A$, we need to split the potential between $A_1$ and $A_2$, and type the 
rest of the expression with the two new variables $x_1: A_1$, $x_2 : A_2$.

\begin{figure}[t!]
  \centering
\small
\begin{mathpar}
\inferr{
  \Sigma; x : B \sststile{q}{q} x : B
}{
}(\text{L:Var})

\inferr{
  \Sigma; x : A \sststile{q'}{q} f(x) : B
}
{
  \Sigma(f) = A \xmapsto{q/q'} B
}(\text{L:Fun})

\inferr{
  \Sigma; \Gamma, x : \irl{bool} \sststile{q'}{q} \ifexcst{x}{e_t}{e_f} : B
}{
  \Sigma; \Gamma \sststile{q'}{q} e_t : B \\
  \Sigma; \Gamma \sststile{q'}{q} e_f : B
}(\text{L:Cond})

\inferr{
  \Sigma; x_1 : A_1, x_2 : A_2 \sststile{q}{q} \pairexcst{x_1}{x_2} : \prodtycst{A_1}{A_2}
}{
}(\text{L:Pair})

\inferr{
  \Sigma; \Gamma, x : (A_1,A_2) \sststile{q'}{q} \paircasecst{x}{x_1}{x_2}{e} : B
}{
  \Sigma; \Gamma, x_1 : A_1, x_2 : A_2 \sststile{q'}{q} e : B
}(\text{L:MatP})

\inferr{
  \Sigma; \emptyset \sststile{q}{q} \irl{nil} : L^p(A)
}{
}(\text{L:Nil})

\inferr{
  \Sigma; x_h : A, x_t : L^p(A) \sststile{q}{q+p+1} \consexcst{x_h}{x_t} : L^p(A)
}{
}(\text{L:Cons})

\inferr{
  \Sigma; \Gamma, x : L^p(A) \sststile{q'}{q} \listcaseexcst{x}{e_1}{x_h}{x_t}{e_2} : B
}{
  \Sigma; \Gamma \sststile{q'}{q} e_1 : B \\
  \Sigma; \Gamma, x_h : A, x_t : L^p(A) \sststile{q'}{q + p} e_2 : B
}(\text{L:MatL})

\inferr{
  \Sigma; \Gamma, x : A \sststile{q'}{q} \sharecpcst{x}{x_1}{x_2}{e} : B
}{
  A \;\curlyvee \;A_1, A_2\\
  \Sigma; \Gamma, x_1 : A_1, x_2 : A_2 \sststile{q'}{q} e : B
}(\text{L:Share})

\inferr{
  \Sigma; \Gamma_1, \Gamma_2 \sststile{q'}{q} \irl{let}(e_1; x : \tau.e_2) : B
}{
  \Sigma; \Gamma_1 \sststile{p}{q} e_1 : A \\
  \Sigma; \Gamma_2, x : A \sststile{q'}{p} e_2 : B
}(\text{L:Let})
\end{mathpar}
  
  \caption{Type Rules of Classic AARA~\cite{Jost03}}
  \label{fig:typeRules}
\end{figure}

{\bf New Rules}
%
The new type system for programs with garbage collection replaces the rules L:MatL and L:Share. The observation is that if we ensure 
that locations are used linearly, we can use destructive pattern matching to model 
local garbage collection by returning the potential associated with the constructor location
(notice the extra $+1$ in the second premise):
%
{\small \[
\inferr{
  \Sigma; \Gamma, x : L^p(A) \sststile{q'}{q} \listcaseexcst{x}{e_1}{x_h}{x_t}{e_2} : B
}{
  \Sigma; \Gamma \sststile{q'}{q} e_1 : B \\
  \Sigma; \Gamma, x_h : A, x_t : L^p(A) \sststile{q'}{q + p + 1} e_2 : B
}(\text{L:MatLD})
\]}

This is validated by the fact (Lemma \ref{itm:na}) that in the auxiliary copying semantics
(introduced in later), once a cons-cell is matched on, 
there can be no live references from the root set to it, and thus 
we are justified in restituting the potential to type the subexpression $e_2$.

However, the rule L:MatLD is not sound for programs with aliasing of data. We address this issue by 
replacing the rule L:Share with the rule L:ShareCopy:
%
{\small \[
\inferr{
  \Sigma; \Gamma, x : A \sststile{q'}{q} \sharecpcst{x}{x_1}{x_2}{e} : B
}{
  A \;\curlyvee^1 \;A_1, A_2\\
  \Sigma; \Gamma, x_1 : A_1, x_2 : A_2 \sststile{q'}{q} e : B
}(\text{L:ShareCopy})
\]}

To share a variabe of type $A$, we need to split the potential between two new annotated types 
$A_1$ and $A_2$ as usual. In addition, we have to pay an ``overhead'' of 1 for every cons node 
in any structure in $\llbracket A \rrbracket$. The idea is that we treat data as if it is
actually copied. This is sound w.r.t the copying semantics because the size of the domain of the
reachable set of a value $v$ is exactly the linear potential of $v : A$ with all resource 
annotations set to 1.

For example, we can give the following derivations for \texttt{append} and \texttt{appTwice}.
For each function, let $e_{\texttt{f}}$ denote the body of the function $\texttt{f}$. The mappings
$P$ and $\Sigma$ denote the program and signature respectively. 

\[
P = [\texttt{append} \mapsto e_{\texttt{append}}] \quad\quad
\Sigma = [\texttt{append} \mapsto \prodtycst{L^p(A)}{L^p(A)} \xrightarrow{q/q} \L^p(A)]
\]

\begin{tiny}
\[
\infer[\text{L:MatL}]{
	\Sigma; l_1 : L^p(A), l_2 : L^p(A) \sststile{q}{q} 
    \listcaseexabt{l_1}{l_2}{x}{xs}{\uletabt{r}{\texttt{append}(xs,l_2)}{x::r }} : L^p(A)
}{
	\infer[\text{L:Var}]{
		\Sigma; l_2 : L^p(A) \sststile{q}{q} l_2 : L^p(A)
	}{
	}&
	\infer[\text{L:Let}]{
		\Sigma; l_2 : L^p(A), x : A, xs : L^p(A) \sststile{q}{q + p + 1} 
        \uletabt{r}{\texttt{append}(xs,l_2)}{x::r} : L^p(A)
	}{
		\infer[\text{L:App}]{
			\Sigma; L_2 : L^p(A), xs : L^p(A) \sststile{q+p+1}{q+p+1} \texttt{append}(xs,l_2) : L^p(A)
		}{
			\texttt{append} : \xrightarrow{q/q} \prodtycst{L^p(A)}{L^p(A)} \to \L^p(A) \in \Sigma
		}&
		\infer[\text{L:Cons}]{
			\Sigma; x : A, r : L^p(A) \sststile{q}{q+p+1} x::r : L^p(A)
		}{
		}
	}
}
\]
\end{tiny}

\[
P = [\texttt{appTwice} \mapsto e_{\texttt{appTwice}}] \quad\quad
\Sigma = [\texttt{appTwice} \mapsto L^{r+s+1}(A) \xrightarrow{q/q} \prodtycst{L^r(A)}{L^s(A)},
\texttt{append} \mapsto \prodtycst{L^p(A)}{L^p(A)} \xrightarrow{q/q} \L^p(A)]
\]

\begin{tiny}
\begin{mathpar}
\infer[\text{L:ShareCopy}]{
  \Sigma; l : L^{r+s+1}(A) \sststile{q}{q}
  \shareabt{l}{l1}{l2}{\uletabt{l1'}{\texttt{append}(l1,[])}{\uletabt{l2'}{\texttt{append}(l2,[])}{\pairexcst{l1'}{l2'}}}}
  : \prodtycst{L^r(A)}{L^s(A)}
}{
\inferrule*[vdots=5.5em,rightskip=5em]{
L^{r+s+1}(A) \curlyvee^1 L^r(A), L^s(A)}{}
&
  \infer[\text{L:Let}]{
  \Sigma; l1 : L^r(A), l2 : L^s(A) \sststile{q}{q}
  \uletabt{l1'}{\texttt{append}(l1,[])}{\uletabt{l2'}{\texttt{append}(l2,[])}{\pairexcst{l1'}{l2'}}}
  : \prodtycst{L^r(A)}{L^s(A)}
}{
  \infer[\text{L:Fun}]
  {
    \Sigma; l1 : L^r(A) \sststile{q}{q} \texttt{append}(l1,[]) : L^r(A)
  }{
    \pairexcst{l1}{[]} : \prodtycst{L^r(A)}{L^r(A)}&
    \Sigma(\texttt{append}) = \prodtycst{L^r(A)}{L^r(A)} \xrightarrow{q/q} \L^r(A)
    }
    &
    \inferrule*[right=\begin{tiny}\text{L:Let}\end{tiny},vdots=4.5em,leftskip=25em]{
 \infer[\text{L:Fun}]
   {
     \Sigma;l2 : L^s(A) \sststile{q}{q} \texttt{append}(l2,[]) : L^s(A)
   }{
    \inferrule*[vskip=1.5em,rightskip=15em]{
    \pairexcst{l2}{[]} : \prodtycst{L^s(A)}{L^s(A)}}{}&
    \Sigma(\texttt{append}) = \prodtycst{L^s(A)}{L^s(A)} \xrightarrow{q/q} \L^s(A)
  }
  \\
  \infer[\text{L:Pair}]{
    \Sigma;l1' : L^r(A), l2' : L^s(A) \sststile{q}{q} \pairexcst{l1'}{l2'} :  \prodtycst{L^r(A)}{L^s(A)}
  }
  {}
}{
   \Sigma;l2 : L^s(A),l1' : L^r(A) \sststile{q}{q} \uletabt{l2'}{\texttt{append}(l2,[])}{\pairexcst{l1'}{l2'}}
  : \prodtycst{L^r(A)}{L^s(A)}
}    
}
}
\end{mathpar}
\end{tiny}

From these derivations,
we get the improved space overhead bound to \texttt{append} and \texttt{appTwice}:
\begin{align*}
	&\texttt{append} : \prodtycst{L^p(\irl{int})}{L^q(\irl{int})} \xrightarrow{r/r'} L^s(\irl{int}),
	\text{ where } p \ge s,\; q \ge s, \text{ and } r \ge r'\\
	&\texttt{appTwice} : L^p(\irl{int}) \xrightarrow{q/q'} \prodtycst{L^r(\irl{int})}{L^s(\irl{int})},
	\text{ where } p + q \ge r + s + 1 \text{ and } q \ge q'
\end{align*}

{\bf Cost Metrics}
In previous versions of AARA~\cite{Jost10,HoffmannAH10}, the typing judgment and cost semantics
are parametrized by a \emph{cost metric} 
$m : \ms{res\_const \to \mathbb{Q}}$, which assigns a constant cost to 
each step in the semantics. Thus we instantiate the previous type system with the heap metric,
the cost metric that measures heap cost, resulting in a concrete type system $\foheap$.
We give a full evaluation of the improvements of $\fogc$ over $\foheap$ in Section~\ref{sect:conclusion}.
Although we defined the constructor to cost
1 heap location (as shown in L:Cons and L:MatLD), it can be any constant as long as the introduction
and elimination rules agree on that constant. Thus we can extend the type system to accurately track
closure sizes and constructors which vary in size depending on the argument (more in 
Section~\ref{sect:conclusion}).

{\bf Type Inference} One of the benefits of AARA is efficient type
inference using off-the-shelve LP solvers~\cite{Jost03}, even for
non-linear potential functions~\cite{HoffmannAH10,HoffmannW15}. The
new rules do not complicate inference and previous techniques still
apply. In a nutshell, inference is performed in three steps: First,
perform a standard Hindley-Milner type inference for the base
types. Then, annotate the type derivation with (yet unknown) variables
for the potential annotations and collect linear constraints that are
derived from the type rules. Finally, solve the constraints with an LP
solver and minimize the potential annotations of the inputs. Details
can be found in previous work~\cite{Jost03,HoffmannW15}.


%------------------------------------------------------------------------------

\section{Soundness of $\fogc$}

We seek to prove the following theorem.

\begin{theorem}[Soundness]
\label{itm:soundness} Let $H \vDash V {:} \Gamma$, $\;\; \Sigma; \Gamma \sststile{q'}{q} e : B$,
and $V,H \vdash^{\mathcal{E}_{\ms{oper}}} e \Downarrow v, H'$.
Then for all configurations $W,Y,F,R$,
if $V,H \sim W,Y$ and $|F| \ge \Phi_{V,H}(\Gamma) + q$,
there exists a value $w$, and a freelist $F'$ such that
$$
\begin{array}{ccc}
	W,Y,R,F \vdash^{\gcSem} e \Downarrow w, Y', F'  & \text{ and } & \veq{H'}{Y'}{v}{w} \; .
\end{array}
$$
\end{theorem}

Here, $\mathcal{E}_{\ms{oper}}$ is a standard big-step semantics, with judgments of the form
$\fbox{$V,H \vdash e \Downarrow v,H'$}$
derived from \gcSem{}, $V,H \sim W,Y$ is context equivalence, and $\veq{H'}{Y'}{v}{w}$
is value equivalence (these are defined below). The theorem states that, given a terminating expression
and a freelist that is sufficiently large (as predicated by the type derivation), 
a run with \gcSem will normalize to an equivalent value.

To facilitate the proof, we define an intermediate semantics
\copySem{} which is semantically linear. The proof has two stages:
First, we show \copySem{} over-approximates \gcSem, meaning that any
computation that succeeds with \gcSem{} will succeed with an
equally-sized or smaller freelist with \gcSem{}. Then we show $\fogc$
is sound with respect to \copySem{}, and thus by the previous step sound with respect to
\gcSem{}.

As mentioned above, we introduce a big step semantics $\mathcal{E}_{\ms{oper}}$
that does not use freelists or account for garbage collection. We use
it to characterize expressions that normalize to values when initialized with a sufficient 
freelist.  This technique has also been employed in earlier work on AARA~\cite{Hofmann:2003:SPH:604131.604148}.
In the judgment $V,H \vdash e \Downarrow v,H'$, the ``freelist'' is the whole ambient set of
locations $\ms{Loc}$, thus we never run out of locations during evaluation. This introduces a
problem for value and context equivalence: when comparing evaluation results between a run
with \copySem{} and $\mathcal{E}_{\ms{oper}}$, the return values 
might not be syntactically equal. Consider the following expression
$e = \texttt{let \_ = [4] in [5]}$.
%
Let \ms{Loc} = $\mathbb{N}$, the natural numbers. Consider the evaluation
$\emptyset,\emptyset,\emptyset,\{1\} \vdash^{\copySem{}} e \Downarrow v_1,H_1,F_1$. 
First, 1 is allocated and mapped to $\texttt{[4]}$. 
Then, since the first subexpression $\texttt{[4]}$ is not used afterwards, we collect 1, and reuse it
and map again to $\texttt{[5]}$. Thus $v_1 = 1$.  In an evaluation
$\emptyset,\emptyset,\emptyset,\{1\} \vdash^{\mathcal{E}_{\ms{oper}}} e \Downarrow v_2,H_2,F_2$, 
we also first map 1 to $\texttt{[4]}$, but then 
allocate a new location, say 2, and map it to $\texttt{[5]}$, and $v_2 =  2$. Due to the 
difference in allocation strategies and the fact that both are nondeterministic, we need a more 
robust notion of equality for values. Luckily, the structures from the denotational semantics 
does the job. In both runs, the return value maps to the semantic value $\texttt{[5]}$.
Thus we use semantical equality above as the basis for value and context equivalence:

\begin{definition}[Value Equivalence]
Two values $v_1,v_2$ are equivalent (with the presupposition that they are well-formed w.r.t heaps $H_1,H_2$),
iff $H_1 \vDash v_1 \mapsto a : A$ and $H_2 \vDash v_2 \mapsto a : A$. 
Write value equivalence as $\veq{H_1}{H_2}{v_1}{v_2}$.
\end{definition}

\begin{definition}[Context Equivalence]
Two contexts $(V_1,H_1), (V_2,H_2)$ are equivalent
(with the presupposition that both are well-formed contexts) iff $dom(V_1) = dom(V_2)$ and 
for all $x \in dom(V_1)$, $\veq{H_1}{H_2}{V_1(x)}{V_2(x)}$. Write context equivalence as 
$\ctxeq{V_2,H_2}{V_2,H_2}$
\end{definition}

Stated simply, two contexts are equivalent when they have the same domain and equal variables bind equal 
semantic values (defined in Section~\ref{sect:lfp}).

\textbf{Linear Garbage Collection Cost Semantics}
\label{sect:copy}
To establish the soundness of the type system, we need an 
intermediary semantics \copySem{}, which is \emph{semantically linear}.  
As mentioned in Section~\ref{sect:fop}, this means that locations are treated linearly,
that is, no location can be 
used twice in a program. Variable sharing is achieved via \emph{copying}: 
the shared value is created by allocating a fresh set of locations from the freelist and copying the 
locations of the original value one by one. This is also sometimes referred to as deep copying.
Let $copy(H,L,v,H',v')$ be a 5-place relation on 
$\ms{Heap} \times \mathcal{P}(\ms{Loc}) \times \ms{Val} \times \ms{Heap} \times \ms{Val}$. 
Similar to reachability, we write this as 
$H',v = copy(H,L,v)$ to signify the intended mode for this predicate: $(+,+,+,-,-)$.
{ \small \begin{mathpar}
	\inferr{
		H,v = copy(H,L,v)	
	}{
		v \in \{n,\irl{T},\irl{F},\irl{Null}\}
	}

	\inferr{
		H'\{l' \mapsto v\},l' = copy(H,L,l) 
	}{
		l' \in L\\
		H',v = copy(H,L \setminus \{l'\},H(l)) 
	}

\inferr{
	H_2,\pairexcst{v_1'}{v_2'} = copy(H,L,\pairexcst{v_1}{v_2})
}{
	L_1 \sqcup L_2 \subseteq L\\
	|L_1| = |dom(reach_H(v_1)|\\
	|L_2| = |dom(reach_H(v_2)|\\
	H_1,v_1' = copy(H,L_1,v_1)\\
	H_2,v_2' = copy(H_1,L_2,v_2)\\
}
\end{mathpar}}

Primitives require no cells to copy; a location value is copied recursively; 
a pair of values is copied sequentially, and the total number of cells required 
is the size of the reachable set of the value.  
Now, consider \gcSem{} with the share rule F:Share replaced with the following rule.
{\small \[
\inferrule{
	V(x) = v'\\
  L \subseteq F\\
  |L| = |dom(reach_H(v'))|\\
  H',v'' = copy(H,L,v')\\
	V' = (V[x_1 \mapsto v',x_2 \mapsto v'']) \restriction_{FV(e)}\\
	F' =	F \setminus L\\
	g = \{l \in H \mid l \notin F' \cup R \cup locs_{V',H}(e)\}\\
 	V',H',R,F' \sqcup g \; \vdash e \Downarrow v,H'',F''
}{
  V,H,R,F \; \vdash \sharecpcst{x}{x_1}{x_2}{e} \Downarrow v,H'',F''
}(\text{E:Share})
\]}

To share a variable, we first copy the shared value. The number of cells required is equal to the
size of the reachable set from the value. This copying sharing semantics is what justifies the 
analysis to restitute the potential when matching on a cons node, 
since even if the node was shared, we had to pay for the cost by copying the node when sharing the 
original value. Next, we restrict the stack to the appropriate variables. 
Lastly, any locations not reachable from the current subexpression $e$ are collected. This is 
for the case when a variable is shared but not used later.  

Recall that a \emph{computation} is a pair $(\mathcal{C},e)$ consisting of a configuration
$\mathcal{C} = (V,H,R,F)$ and an expression $e$. 
Since any reasonable semantics can only \emph{preserve} the linearity of a computation,
we restrict our attention to computations that are linear initially, and show that
\copySem{} respects the linearity of any initially linear computation. This motivates the following
definitions:

\begin{definition}(Linear context)
Given a context $(V,H)$, let
$x,y \in dom(V)$, $x \ne y$, and $r_x = reach_H(V(x))$, $r_y = reach_H(V(y))$.
	It is \emph{linear} given that  $\ms{set}(r_x)$, $\ms{set}(r_y)$, and $r_x \cap r_y = \emptyset$.
\end{definition}

Where $\ms{set}(S)$ means $S$ a proper set ($\forall x, S(x) \le 1$). 
Denote this by $\na{V,H}$. Whenever $\na{V,H}$ holds,
there is at 
most one path from a variable on the stack $V$ to any location in $H$. Now we can 
formalize our intuition for linear computations: 

\begin{definition}[Linear computation]
Given a configuration $\mathcal{C} = (V,H,R,F)$ and an expression $e$, 
we say the 5-tuple $(\mathcal{C},e)$ is a \emph{computation}; it is a \emph{linear computation} 
given that  $dom(V) = FV(e)$, $\na{V,H}$, and $\dist{\{R,F,locs_{V,H}(e)\}}$.
And we write $\wfc{V}{H}{R}{F}{e}$ (equivalently $\linearComp{\mathcal{C}}{e}$) to denote this fact.
\end{definition}

Intuitively, we expect that any terminating compuation
with \copySem{} has a corresponding run with \gcSem{} that can be instantiated with 
an equally-sized or smaller freelist. Although this seems quite straightforward to prove, a complete
characterization of the relationship between the space allocations of two runs with each 
semantics is necessary. To motivate this, consider the following proof attempt: 

\begin{attempt}
	Let $\mathcal{C}_2 = (V,H,R,F)$ be a configuration and $(\mathcal{C}_2, e)$ 
	be a linear computation. Given that 
	$\mathcal{C}_2 \vdash^{\copySem} e \Downarrow v,H',F'$, 
	for all configurations $\mathcal{C}_1 = (W,Y,R,M)$ such that $W,Y \sim V,H$ and $|M| = |F|$,
there exists a triple
$(w,Y',M') \in \ms{Val} \times \ms{Heap} \times \ms{Loc}$ such that
	\begin{center}
			$\mathcal{C}_1 \vdash^{\gcSem} e \Downarrow w,Y',M'$
		\hspace{3em} and \hspace{3em}	 $\veq{H'}{Y'}{v}{w}$
		\hspace{3em} and \hspace{3em}	 $|M'| \ge |F'|$ .
	\end{center}
\end{attempt}

We proceed with induction on the derivation of the judgment in \copySem. 
Almost every case goes through, save for E:Let. 
First, we get $W_1,Y \sim V_1,H$ and we have the following from induction on the first premise:
%
\begin{center}
	 $W_1,Y,R',M \vdash^{\gcSem} e \Downarrow w_1,Y_1,M_1$
   \hspace{3em} and \hspace{3em}	 $\veq{H_1}{Y_1}{v_1}{w_1}$
   \hspace{3em} and \hspace{3em}	 $|M_1| \ge |F_1|$
\end{center}
%
To instantiate the induction hypothesis on the second premise, we need to show that, among 
other things, $|M_1 \cup j| \ge |F_1 \cup g|$, where $j$ is the set of collected locations in 
the \gcSem{} judgment. We cannot show this precisely because $g$ might contain more cells 
then $j$ due to the linearity of \copySem{}, thus preventing a piecewise comparison. 
But of course $|j|$ is always less than $|g|$, since \gcSem{} doesn't copy to share 
values! This shows that there is a mismatch between the induction hypothesis and the relationship
between the sizes of the respective freelists and the garbage sets. Specifically, we need to
know exactly how much larger $M_1$ is compared to $F_1$ at any given step. 

Having a sense of what is missing, we formulate the
criteria which characterize the required equivalence between two configurations,
called \emph{copy extension}.
\begin{definition}
  A configuration $\mathcal{C}_2 = (V_2,H_2,R_2,F_2)$ is a \emph{copy extension} of
  another configuration
$\mathcal{C}_1 = (V_1,H_1,R_1,F_1)$ iff
\begin{enumerate}
\item $V_1,H_1 \sim V_2,H_2$
\item There is a proper partition $\gamma : dom(H_1) \setminus F_1 \to \mathcal{P}(dom(H_2) \setminus F_2)$ 
such that for all $l \in dom(\gamma)$, $|\gamma(l)| = reach_{H_1}(V_1)(l) + R_1(l)$
\item For all $l \in dom(\gamma)$, $x \in dom(V_1)$, valid sequence of directions $P$ w.r.t $V_1(x)$,
	$|reach_{H_2}(V_2(x;P)) \cap \gamma(l)| = reach_{H_1}(V_1(x;P))(l)$.
\item	For all $l \in dom(\gamma)$, $|\gamma(l) \cap R_2| = R_1(l)$
\item $|F_1| = |F_2| + |\oh{\gamma}|$, where 
	$\oh{\gamma} = \bigcup_{P \in ec(\gamma)} P \setminus (rep(P))$
\end{enumerate}
Write this as $\mathcal{C}_1 \preceq \mathcal{C}_2$.
\end{definition} 

The intention is that $\mathcal{C}_2$ is a configuration for initiating an evaluation using \copySem
, and $\mathcal{C}_1$ a configuration for \gcSem. 


The first condition is the straightforward context equivalence.
The second condition requires the existence of 
a mapping $\gamma$ that tells us given a location in $H_1 \setminus F_1$, which locations in 
$H_2 \setminus F_2$ are shared instances.

For example, consider the expression $\sharecst{x}{x_1}{x_2}{e}$ and
assume the stack is $[\texttt{x} \mapsto 1]$, and the heap equals 
$[1 \mapsto \pairexcst{0}{\irl{Null}}]$, i.e. \texttt{x} is the list \texttt{[0]}.
In an evaluation with \gcSem{}, the stack becomes 
$[\texttt{x1} \mapsto 1,\texttt{x2} \mapsto 1]$, and the heap does not change. With 
\copySem, we allocate a new location in the heap:
$[1 \mapsto \pairexcst{0}{\irl{Null}},2 \mapsto \pairexcst{0}{\irl{Null}}]$, and the 
stack changes accordingly: $[\texttt{x1} \mapsto 1,\texttt{x2} \mapsto 2]$.
Now $\gamma$ would map 1 to $\{1,2\}$, since both are shared instances of the former.

Thus, the image of $\gamma$ is a collection of disjoint subsets whose union is $dom(H_2) \setminus F_2$,
and each location in $dom(H_2) \setminus F_2$ belongs to a unique class whose preimage is the  
unique representative in $dom(H_1) \setminus F_1$. Furthermore, we noticed it is crucial to include the 
fact that the size of $\gamma(l)$ must be the sum of the number of references from the stack and 
the continuation set. Furthermore, we also require each subset $\gamma(l)$ (also referred to as class)
to be nonempty (this is the \emph{proper} partition condition).

While $\gamma$ gives us a relation between the active regions of two respective heaps, 
we still need to know 
exactly how variables on the stack factor in this relationship. Let $l \in H_1$. 
Specifically, we need to know that the number of references to $l$ from every \emph{sub}value
in $V_1$ is equal to the size of the corresponding part of the class $\gamma(l)$.  
First, we need to access 
subvalues of a value using directions: 

\begin{definition}
	Let \ms{Dir} be the set \{\ms{L},\ms{R},\ms{N}\}, denoting left, right, and next 
  respectively. We define the function 
  $get_H : 1 \oplus (\ms{Val} \times \ms{Dir}) \to 1 \oplus \ms{Val}$
  which indexes values via directions:
        $$
	\begin{array}{lclclcl}
		get_H(Just(\pairexcst{v_1}{v_2},\ms{L})) &=& Just(v_1) & \hspace{4em} &
		get_H(Just(l),\ms{N}) &=& Just(H(l)) \\
                get_H(Just(\pairexcst{v_1}{v_2},\ms{R})) &=& Just(v_2) &&
                get_H(Just(l), \_) &=& None\\
                get_H(Just(\pairexcst{v_1}{v_2}),\ms{N}) &=& None &&
		get_H(r,\_) &=& r
	\end{array}
        $$
  Let $P \in \mathcal{S}(\ms{Dir})$, where $\mathcal{S}(X)$ denotes the set of sequence
  with elements from $X$. We define 
  $find_H : 1 \oplus (\ms{Val} \times \mathcal{S}(\ms{Dir})) \to 1 \oplus \ms{Val}$ 
  to extend $get_H$ to sequences of directions:
	\begin{align*}
		find_H(v,D::P) &= find_H(get_H(v,D),P)\\
		find_H(v,[]) &= v
	\end{align*}
	Call $P$ valid w.r.t a value $v$ if $find_H(v,P) = Just (v')$ for some $v'$.
  Given a valid sequence $P$ w.r.t $V(x)$,
	write $V_H(x;P)$ for $fromJust(find_H(V(x),P))$
	and $reach_H(V(x;P))$ for $reach_H(V_H(x;P))$.
  Given a map $m : X \to \mathcal{S}(\ms{dir})$ from varibles to
  valid sequences of directions, 
	Define $reachPath_{V,H}(X,m) = \biguplus_{x \in X} reach_H(V(x;m(x)))$.
\end{definition}

With this, the third condition gives us a more fine grained restriction: for any subvalue in $V_1$,
the number of references from it to $l$ is equal to the size of 
the intersection of the reachable set of the corresponding subvalue in $V_2$
with the appropriate class $\gamma(l)$ .

The next condition simply states that the continuation sets respect $\gamma$. Lastly, 
we have that $F_1$ is greater than $F_2$, with the overhead $\oh{\gamma}$ being exactly the sum 
$\sum_{l \in \gamma} |\gamma(l)| - 1$ 
(since each class is non-empty, we use $rep(l)$ to choose an arbitrary element of the class $\gamma(l)$). 

Below we prove the expected properties of a copy extension: 
\begin{lemma}
	Let $V_1,H_1 \sim V_2,H_2$. Then for all $x \in dom(V_1)$ and 
  sequence of directions $P$, 
	Either $find_{H_1}(V_1(x),P) = find_{H_2}(V_2(x),P) = None$ or 
	$find_{H_1}(V_1(x),P) = v_1$, $find_{H_2}(V_2(x),P) = v_2$ and
	$\veq{H_1}{H_2}{v_1}{v_2}$
\end{lemma}

\begin{lemma}\label{itm:aux}
Let $V_2,H_2,R_2,F_2 \vdash^{\mathsf{copy}} e \Downarrow v,H',F'$, and 
$V_1,H_1,R_1,F_1 \preceq V_2,H_2,R_2,F_2$, where $\gamma$ is the partition satisfying 
the copy extension property. Then the following hold:
for all $l \in dom(H_1) \setminus F_1$, 
	$X \subseteq dom(V)$, $m : X \to \mathcal{S}(\ms{dir})$, $l \in dom(\gamma)$,
	$\gamma(l) \subseteq collect(R_2,\mathcal{C}_2,reachPath_{V_2,H_2}(X,m),H_2,F_2)$ iff
	$l \in collect(R_1,reachPath_{V_1,H_1}(X,m),H_1,F_1)$.
\end{lemma}

Now we can state the key lemma:

\begin{lemma}
	Let $(\mathcal{C}_2,e)$ be a linear computation. Given that 
	$\mathcal{C}_2 \vdash^{\copySem{}} e \Downarrow v,H',F'$,
	for all configurations $\mathcal{C}_1$ such that $\mathcal{C}_1 \preceq \mathcal{C}_2$,
there exists a triple
$(w,Y',M') \in \ms{Val} \times \ms{Heap} \times \ms{Loc}$ and 
	$\gamma' : dom(Y') \setminus M' \to \mathcal{P}(dom(H') \setminus F')$ s.t.
	\begin{enumerate}
			\item $\mathcal{C}_1 \vdash^{\gcSem{}} e \Downarrow w,Y',M'$
			\item $\veq{H'}{Y'}{v}{w}$
			\item $\gamma'$ is a proper partition, such that for all $l \in dom(\gamma')$, 
				$|\gamma'(l)| = |reach_{Y_1}(w_1)(l)| + S(l)$
      \item For all $P \in \mathcal{S}(\ms{Dir})$ that is valid w.r.t $v$, 
        $|reach_{H'}(find_{H'}(v;P)) \cap \gamma'(l)| = 
				reach_{Y'}(find_{Y'}(w;P))(l)$
			\item For all $l \in dom(\gamma')$, $\gamma'(l) \cap R = \gamma(l) \cap R$
			\item $|M'| = |F'| + |\oh{\gamma'}|$
	\end{enumerate}
\end{lemma}

\begin{proof}
	Induction on the evaluation judgment $\vdash^{\copySem{}}$. We illustrate the 
  ideas with the case CondT:
\item[\textbf{Case}: 
\inferrule{
  V(x) = \irl{T}\\
	V' = V\restriction_{FV(e_1)}\\
  g = \{l \in H \mid l \notin F \cup R \cup locs_{V',H}(e_1)\}\\
  V',H,R,F \cup g\; \vdash e_1 \Downarrow v, H',F'
}{
  V,H,R,F \; \vdash \ifexabt{x}{e_1}{e_2} \Downarrow v, H',F'
}(\text{F:CondT})]
From the case, we have $V,H,R,F \; \vdash^{\copySem} \ifexabt{x}{e_1}{e_2} \Downarrow v, H',F'$. Let $W,Y,S,M$ be a configuration such that 
$W,Y,S,M \preceq V,H,R,F$. Define $W' = W \restriction_{dom(V')}$
and $j = \{l \in Y | l \notin M \cup S \cup locs_{W,Y}(e_1) \}$.
To instantiate the induction hypothesis, we need to show that 
  $W',Y,S,M \cup j \preceq V',H,R,F \cup g$, giving us 5 obligations:
  \begin{align*}
		&\emph{(1)}\quad W',Y \sim V',H\\
		&\emph{(2)}\quad \text{Need to find a proper partition } 
\gamma' : dom(Y) \setminus (M \sqcup j) \to \mathcal{P}(dom(H)\setminus (F \cup g))\\
		&\emph{(3)}\quad \text{Let $l \in dom(\gamma'), x \in dom(W')$, 
			$P$ valid sequence w.r.t $W'(x)$. We need to show that }\\
    &|reach_{H}(V'(x;P)) \cap \gamma'(l)| = reach_{Y}(W'(x;P))(l) \\
		&\emph{(4)}\quad S \subseteq dom(Y) \setminus (M \cup j) \text{ since } S \cap j = \emptyset\\
		&\emph{(5)}\quad |M \cup j| = |F \cup g| + |\oh{\gamma'}|
  \end{align*}
  \emph{(1)} is satisfied since $W,Y \sim V,H$. For \emph{(2)}, we take 
  $\gamma'(l) = \gamma \restriction_{dom(Y)\setminus(M \sqcup j)}(l) \setminus g$. 
  First, we show that  $\gamma'$ is a partition. 
	Let $l, l' \in dom(Y) \setminus (M \sqcup j)$ be two arbitrary locations. Then 
  $\gamma'(l) \cap \gamma'(l') = \emptyset$ since $\gamma$ is a partition. Now 
  Consider the image of $\gamma'$: 
  \begin{align*}
		&\quad \gamma'(dom(Y) \setminus (M \sqcup j)) = \gamma(dom(Y) \setminus (M \sqcup j)) \setminus g\\
		&\quad = (\bigsqcup_{l \in dom(Y) \setminus M} \gamma(l) \setminus \bigsqcup_{l \in j} \gamma(l)) 
			\setminus g\\
		&\quad = ((dom(H) \setminus F) \setminus (\bigsqcup_{l \in j} \gamma(l))) \setminus g 
			\tag{$\gamma$ is a partition}\\
		&\quad = (dom(H) \setminus F) \setminus g 
			\tag{$\bigsqcup_{l \in j} \gamma(l) \subseteq g$ by lemma \ref{itm:aux}}\\
		&\quad = dom(H) \setminus (F \sqcup g)
  \end{align*}
  Hence $\gamma'$ is a partition. Next we need to show it is proper, or that 
  every class is non empty.
  Let $l \in dom(Y) \setminus (M \sqcup j)$ be any location. Since 
  $\gamma'(l) = \gamma(l) \setminus g$, it sufficies to show 
  that $l$'s class isn't all not collected. For the sake of contradiction, assume 
  $\gamma(l) \subseteq g$. But then $l \in j$ by Lemma \ref{itm:aux}, and 
  we have a contradiction since we assumed $l \notin j$.  
  Lastly, we need to show that $|\gamma'(l)| = reach_{Y}(W')(l) + S(l)$.
	Let $l \in dom(\gamma')$. By definition, we have 
  $|\gamma'(l)| = |\gamma(l)| - |\gamma(l) \cap g|$, which by 
  the second condition of $W,Y,S,M\preceq V,H,R,F$, 
  is $reach_Y(W)(l) + S(l) - |\gamma(l) \cap g|$. Next, note that 
	$g = reach_H(V\restriction_{dom(V) \setminus FV(e_1)})$; combined with the 
  third condition of  $W,Y,S,M\preceq V,H,R,F$, we have
  $|\gamma(l) \cap g| = reach_Y(W\restriction_{dom(W)\setminus FV(e_1)})(l)$
	Thus, we have that $|\gamma'(l)| = 
			reach_Y(W)(l) + S(l) - reach_Y(W\restriction_{dom(W)\setminus FV(e_1)})(l) =
  reach_Y(W\restriction_{FV(e_1)})(l) +  S(l) = reach_Y(W')(l) +  S(l)$, which is
  the condition we needed. The conditions \emph{(3)} and \emph{(4)} proceed similarly
  to the arguments above.

  Lastly, we need to show that the overhead is preserved: 
  $|M| + |j| = |F| + | g| + |\oh{\gamma'}|$.
	By assumption, $|M| = |F| + |\oh{\gamma}|$, so it suffices to show 
  $|j| + |\oh{\gamma}| = |g| + |\oh{\gamma'}|$. We do this by giving a bijection 
  $f : j \oplus \oh{\gamma} \to g \sqcup \oh{\gamma'}$. 
  By Lemma \ref{itm:aux}, we have $g = (\bigsqcup_{l \in j} \gamma(l)) \sqcup L $ for some
  $L$. 
	Let $\mathcal{C}_1 = \{\gamma(l) \mid l \in j\}$, 
				$\mathcal{C}_2 = ec(\gamma) \setminus \mathcal{C}_1$. Then we have 
		$\oh{\gamma} = \bigsqcup_{C  \in \mathcal{C}_1} C \setminus rep(C) 
    \sqcup \bigsqcup_{C  \in \mathcal{C}_2} C \setminus rep(C)$. 
		Next, let $D_1 = \bigsqcup_{C  \in \mathcal{C}_1} C \setminus rep(C)$,  
		$D_2 = \bigsqcup_{C  \in \mathcal{C}_2} C \setminus rep(C)$.
		We define the bijection $f$ by parts: 
			$f_1 : j \oplus D_1 \to \bigsqcup_{C \in \mathcal{C}_2} C, f_2 : D_2 \to L \sqcup \oh{\gamma'}$. First, $f_1$ is defined as follows:
  \begin{align*}
		&\quad f_1(x) =  
		\begin{cases}
			rep(\gamma(l)) &x = (\ms{inl},l)\\
			l &x = (\ms{inr},l)
		\end{cases}
  \end{align*}
		Clearly, $f_1$ is a bijection, and $|j| + |D_1| = 
    |\bigsqcup_{C \in \mathcal{C}_1} C|$. To avoid the problem of maintaining 
    a single representative for a class (which might be collected),
    note that
  \begin{align*}
    |\mathcal{C}_2| &= |ec(\gamma) \setminus \{\gamma(l) \mid l \in j\}|\\
    &=|ec(\gamma \restriction_{dom(Y) \setminus (M \sqcup j)})|\\
    &= |ec(\gamma')|
  \end{align*}
		Which means that $\mathcal{C}_2$  has the same number of classes as $\gamma'$
		(note the actual classes might be different). 
		Since both $\gamma$ and $\gamma'$  are proper partitions, we just keep class
    representatives for each class and still obtain a bijection:
    \begin{align*}
      &|D_2| = |L \sqcup \oh{\gamma'}|\\
      &\iff |\bigsqcup_{C  \in \mathcal{C}_2} C \setminus rep(C)| = 
			|L \sqcup \bigsqcup_{C \in ec(\gamma')} C \setminus rep(C)|\\
      &\iff |\bigsqcup_{C  \in \mathcal{C}_2} C| = 
        |L \sqcup \bigsqcup_{C \in ec(\gamma')} C|
  \end{align*}
		In fact, the latter two sets are equal. 
		Let $l' \in \bigsqcup_{C  \in \mathcal{C}_2} C$. 
		By definition of partition, $l' \in H \setminus F$. Suppose $ l \in g$. 
		Then by definition of $\mathcal{C}_2$, $l' \notin \bigsqcup_{l \in j} \gamma(l)$, 
    and $l' \in L$ by definition of $g$. Hence 
    $l' \in L \sqcup \bigsqcup_{C \in ec(\gamma')} C$. 
		Otherwise,  $l' \notin g$, and $l' \in H \setminus (F \sqcup g)$. 
		By definition of partition, there exists a class $C \in ec(\gamma')$ s.t. $l' \in C$.
		Then $l' \in \bigsqcup_{C \in ec(\gamma')} C$, and
		$l' \in L \sqcup \bigsqcup_{C \in ec(\gamma')} C$.
		For the other direction, let $ l' \in L \sqcup \bigsqcup_{C \in ec(\gamma')} C$.
		Suppose $l' \in L$. Then $l' \in H \setminus F$ since $L \subseteq g$.
    Since $L \cap  \bigsqcup_{C \in \mathcal{C}_1} C = \emptyset$, 
    there exists a class $C \in \mathcal{C}_2$ s.t. $l' \in C$. Thus 
    $l' \in \bigsqcup_{C \in \mathcal{C}_2} C$.
		Otherwise, $l' \in \bigsqcup_{C \in ec(\gamma')} C$. 
		By definition of partition, $l' \in H \setminus (F \sqcup g)$. 
    Since $\bigsqcup_{C \in \mathcal{C}_1} C \subseteq g$, there is a class 
    $C \in \mathcal{C}_2$ s.t. $l' \in C$, and again 
    $l' \in \bigsqcup_{C \in \mathcal{C}_2} C$.
    
    Hence we show that $|D_2| = |L \sqcup \oh{\gamma'}|$, and together with the previous 
		equality, $|j| + |\oh{\gamma}| = |g| + |\oh{\gamma'}|$. 
		Thus we have $W',Y,S,F \cup j \preceq V',H,R,F \cup g$. 
  Now we instantiate the induction hypothesis to obtain the triple $(w,Y',M')$ and 
  new partition $\gamma''$ with the expected properties. Applying the rule F:CondT 
  to the first property given by induction, we inherit the required conditions for the 
  case.
\end{proof}

Thus, we have shown that we can execute a computation using 
\gcSem{} if the computation suceeded in a run with \copySem{}, and that indeed 
\copySem{} is an over approximation of \gcSem{}.

\textbf{Soundness of $\fogc$}
\label{sect:soundcopy}
For the second part of the proof, we show $\fogc$ is sound w.r.t. \copySem{}. Below
we give the lemmas used in the soundness theorem:

\begin{lemma}\label{itm:wellFormed}
	Let $H \vDash V : \Gamma$, $\Sigma;\Gamma \vdash e : A$, and $V,H \vdash e \Downarrow v,H'$. Then 
	$H' \vDash v : A$.
\end{lemma}

% main lemma
 \begin{definition}[Stability]
Given heaps $H,H'$, a set of locations is \emph{stable} if $\forall l \in R$. $H(l) = H'(l)$. Denote this by
$\stable{R,H,H'}$.
\end{definition}

\begin{lemma}\label{itm:stable}
Let $H \vDash v \mapsto a : A$. For all sets of locations $R$, if $reach_H(v) \subseteq R$ and $\stable{R,H,H'}$, then $H' \vDash v \mapsto a : A$ and $reach_H(v) = reach_{H'}(v)$.
\end{lemma}

\begin{lemma}[Stability of copying]\label{itm:copyStable}
	Let $H',v' = copy(H,L,v)$. For all $l \in H$, if $l \notin L$, then $H(l) = H'(l)$. 
	Further, $reach_{H'}(v') \subseteq L$.
\end{lemma}

\begin{lemma}[Copy is copy]
	Let $H',v' = copy(H,L,v)$. If $H \vDash v \mapsto a : A$, then $H' \vDash v' \mapsto a : A$.
\end{lemma}

\begin{lemma}\label{itm:shareSize}
	Let $A \curlyvee^n A_1,A_2$, $H \vDash v : A$, 
  $\veq{H}{H}{v}{v_1}$, and $\veq{H}{H}{v}{v_2}$. Then $\Phi_{H}(v : A) = 
	\Phi_{H}(v_1 : A_1) + \Phi_{H}(v_2 : A_2) + n\cdot |dom(reach_H(v))|$
\end{lemma}

\begin{lemma}[Linearity of \copySem{}]\label{itm:na}
  Let $\mathcal{C}$ be a configuration, $\mathcal{C} \; \vdash^{\copySem{}} e \Downarrow v, H', F'$, and
  $\Sigma; \Gamma \vdash e : B$. Given that $\linearComp{\mathcal{C}}{e}$,
  we have that $\ms{set}(reach_{H'}(v))$ and $\dist{\{R,F',reach_{H'}(v)\}}$.
\end{lemma}

\begin{theorem}[Soundness]
\label{b} let $H_o \vDash V_o : \Gamma$, $\Sigma; \Gamma \sststile{q'}{q} e : B$,
$V_o,H_o \; \vdash e \Downarrow v_o, H_o'$.
Then $\forall C \in \mathbb{Q}^{+}$ and configuration $(V,H,R,F)$ s.t.
\begin{enumerate} 
\item $V_o,H_o \sim V,H$
\item $\wfc{V}{H}{R}{F}{e}$
\item $|F| \ge \Phi_{V,H}(\Gamma) + q + C$ 
\end{enumerate}
then there exists a triple $(v,H',F')$, and a freelist $F'$ s.t.
\begin{enumerate}
  \item $V,H,R,F \vdash^{\copySem{}} e \Downarrow v, H', F'$
	\item $\veq{H_o'}{H'}{v_o}{v}$
  \item $|F'| \ge \Phi_{H'}(v:B) + q' + C$
\end{enumerate}
\end{theorem}

In other words, given a terminating expression (verified by succeeding with the run using $\mathcal{E}_{\ms{oper}}$)
and given a freelist that is sufficiently large (as predicated by the type derivation), 
a run with \copySem will normalize to an equivalent value, and the resulting freelist 
will be sufficiently large (as predicated by the type derivation).
%------------------------------------------------------------------------------


\section{Implementation and Evaluation}
\label{sect:implementation}

{\bf Implementation}
We have implemented the novel cost semantics and the type system in
Resource Aware ML (RaML). The implementation covers full RaML,
including user-defined data types, higher-order functions, and
polynomial potential functions. However, there is no destructive match
for function closures and analyzing the heap-space usage of closures
still amounts to counting allocations only. The main changes that
where necessary have been in the rules for sharing and pattern
matching as described earlier. We also needed to change some
elaboration passes that were no longer cost preserving with
the GC cost model.

The garbage collection cost semantics is implemented as an alternative evaluation module inside
RaML. As mentioned before, RaML leverages the syntax of OCaml programs.
First, we take the OCaml type checked abstract syntax tree and perform a series of transformations. 
The evaluation modules operate on the resulting RaML syntax tree. 
In the gc evaluation module, \texttt{evaluate} has the following signature:
{\small%
\begin{verbatim}
 evaluate : ('a, unit) Expressions.expression -> int -> (('a value * 'a heap * Int.Set.t) option) 
\end{verbatim}
}
Here, the second argument \texttt{int} specifies the size of the initial freelist.
The result is an option triple of the return value, heap, and freelist; \texttt{None} is returned
in case the freelist was not sufficient for the evaluation.
Whereas the normal evaluation boxes every value (everything evaluates to a location), 
the gc module follows the cost semantics and only boxes data constructors. The rationale is
that the size for other values can be computed statically and thus stack allocated. One difference
between the cost semantics and its implementation is that while in the language presented here
list is the only data type, our implementation supports user defined data types. The extension
is straightforward except the treatment of the nil constructor, or generally ``empty'' constructors
that have arity zero. For simplicity of presentation, we evaluate all nil constructors to
the same null value in the cost semantics. This is natural for lists because all nil constructors 
are the same, and every list has at most one nil node. However, for custom data types that have 
more than one kind of empty constructor, it is not possible to map every constructor to the same 
null value. Thus, the implementation treats all constructors uniformly, so each empty constructor
also costs one heap location. 

As mentioned before, all functions used in a program are declared in a global mutually 
recursive block, and we do not account for the constant space overhead for this block in 
the cost semantics.  In order to implement this global function block, we allow closure creation
during program evaluation. However, we allocate all closures from a separate freelist into 
a separate heap.  This ensures that data constructors are allocated from the correct freelist 
and no space overhead is created by allocating closures for function declarations.


\label{sect:evaluation}
\begin{wraptable}{r}{0.5\textwidth}
\small
	\vspace{-20pt}
		\begin{center}
	\begin{tabular}{ll}
		\hline
		\textit{\textbf{function}} & type \\ \hline
		quicksort & {[}'a -\textgreater 'a -\textgreater bool; 'a list{]} -\textgreater 'a list \\
		mergesort & {[}{[}'a; 'a{]} -\textgreater bool; 'a list{]} -\textgreater 'a list \\
		ocamlsort & {[}{[}'a; 'a{]} -\textgreater bool; 'a list{]} -\textgreater 'a list \\
		selection sort & int list -\textgreater int list \\
		eratosthenes & int list -\textgreater int list \\
		dfs & {[}btree; int{]} -\textgreater btree option \\
		bfs & {[}btree; int{]} -\textgreater btree option \\
		transpose & 'a list list -\textgreater 'a list list \\
		map\_it & {[}'a -\textgreater 'b; 'a list list{]} -\textgreater 'b list list * 'b list list\\
		pairs & 'a list -\textgreater ('a * 'a) list \\ \hline
	\end{tabular}
			\end{center}
				\vspace{-10pt}
			\caption{Signature of Test Functions}
		\vspace{-10pt}
\label{table:sig}
\end{wraptable}

\textbf{Evaluation}
We evaluated our new analysis on a number of functions. Table~\ref{table:sig} contains a representative compilation.
It shows the type signature for each function.
Table~\ref{table:bounds} presents the test data that
showcase the difference between $\foheap$, the previous RaML type system instantiated with the
heap metric (the old analysis which only counts 
heap allocations), and $\fogc$, which includes deallocations and copying cost for sharing.
For each type system, we show the heap space bound computed by RaML, 
the number of constraints generated, and the time elapsed during analysis. The last column gives
the expression for the exact heap high watermark derived by hand and verified by running the 
cost semantics.

Except for bfs and dfs, all functions in the table take a \emph{principal} argument of type list. 
The variables in the table refer to this argument (for example, the type of the 
principal argument of 
quicksort is 'a list). In general, M refers to the number of cons constructors of the principal 
argument (or the number of \emph{outer} cons nodes in case of nested lists); L refers to the
maximum number of cons nodes of the inner lists.

For the sorting functions, aside from mergesort, the new analysis using the gc metric
derived asymptotically better bounds when compared to the heap metric. Furthermore,
all bounds are \emph{exact} with respect to the cost semantics. In regards to mergesort, 
the analysis was not able to derive a tight bound due to the limitations of AARA in deriving 
logarithmic bounds. A particularly nice result is that for quicksort, we derive that
the space usage is exactly 0, which justifies its use as a zero space-overhead 
(or ``in  place'') sorting algorithm.

Next, we have have the graph search algorithms operating on a binary tree. Again, the gc metric
was able to derive exact space overheads, while the heap metric derived linear bounds for both.
%
For transpose, the gc metric derived an asymptotically better bound, but was not able to derive 
the exact overhead. We implement matrices as lists-of-lists in row-major order. 
The transpose function is implemented tail-recursively, with the accumulator starting as the 
empty list. When ``flipping'' the first row $r$ of the input and appending this to the accumulator, 
we need to create $|r|$ many new nil and cons constructors to store the row as a column. While this
overhead only occurs once, RaML is unable to infer this from the source code, and thus the cost
is repeated over the entire input matrix, resulting in the linear bound (w.r.t the size of the 
matrix). This artifact is unrelated to the new extension; it is a limitation
due to the implementation of RaML. 

The last two functions demonstrate how the gc metric performs when there is variable sharing.
map\_it maps the input function across each list in the principal argument twice, returning a
tuple of nested lists. The gc metric dictates that every outer data constructor in the 
principal argument needs to be copied, and thus gives the linear bound M + 1. In this case,
the bound is exact. The function ``pairs'' takes a list and outputs all pairs of the input list 
which are ordered ascending in input position. For example, 
pairs [1;2;3;4] = [(1,2);(1,3);(1,4);(2,3);(2.4);(3,4)]. For pairs, the gc metric derived a bound
that is asymptotically the same as the heap metric, but with better constants. An exact bound 
could not be derived because the deallocation potential from the pattern match in the 
definition of pairs is wasted since the matched body could already be typed with zero cost. 
However, this deallocation is used as usual in the cost semantics. Thus the slack in the bound 
totals to the size of the input. % This example shows a weakness in the new gc metric and analysis; 
% we discuss possible solutions and different approaches in the next sections. 




% Please add the following required packages to your document preamble:
% \usepackage{booktabs}
\begin{table}[]
	\begin{adjustbox}{width=1\textwidth, center=\textwidth}
  \begin{tabular}{@{}llllllllll@{}}
		\toprule
		 & \multicolumn{3}{l}{$\foheap$} & \multicolumn{3}{l}{$\fogc$} &  \\ \midrule
		 \textit{\textbf{function}} & computed bound & constraints & time & computed bound &  constraints & time & optimal \\
		 quicksort & $1.00 + 3.50M + 1.50M^2$ & 8515 & 0.52 & 0 & 8519 & 0.48 & 0 \\
		 mergesort & $1.00 - 4.67M + 6.33M^2$ & 9572 & 0.64 & $-0.50M + 0.50M^2$ & 9578 & 0.58 & $\lfloor \log(M) \rfloor$ \\
		 ocamlsort & $7.50 + 5.50M + 1.00M^2$ & 8565 & 0.51 & $1.00 + 1.00M$ & 8573 & 0.50 & $M+1$ \\
		 selection sort & $2.00 + 3.00M + 1.00M^2$ & 639 & 0.06 & 0 & 642 & 0.05 & 0 \\
		 eratosthenes & $1.00 + 1.50M + 0.50M^2$ & 515 & 0.06 & 0 & 517 & 0.04 & 0 \\
		 dfs & $3.00 + 2.00M$ & 5481 & 0.90 & 2 & 5483 & 0.36 & 2 \\
		 bfs & $5.00 + 10.00M$ & 24737 & 4.15 & 4 & 24742 & 1.62 & 4 \\
		 transpose & $1.00 + 3.50LM + 0.50LM^2$ & 10680 & 0.50 & $1.00 + 2.00LM$ & 10684 & 0.50 & $\max{(0,2L-1)}$ \\
		 map\_it & $2.00 + 2.00LM + 4.00M$ & 30699 & 1.58 & $1.00M + 1.00$ & 30703 & 1.57 & M + 1 \\
		 pairs & $1.00 + 1.00M^2$ & 10214 & 0.60 & $0.50M + 0.50M^2$ & 10217 & 0.64 & $0.5M^2-1.5M+2$ \\ \midrule
	\end{tabular}
	\end{adjustbox}
	\caption{Automatic Bound Analysis with RaML}
\label{table:bounds}
\end{table}

\iffalse
\begin{table}[]
	\begin{adjustbox}{center=\textwidth}
  \begin{tabular}{@{}llllllllll@{}}
		\toprule
		 & \multicolumn{4}{l}{heap metric} & \multicolumn{4}{l}{gc metric} &  \\ \midrule
		 \textit{\textbf{function}} & computed bound & asymptotic & constraints & time & computed bound & asymptotic & constraints & time & optimal \\
		 quicksort & $1.00 + 3.50M + 1.50M^2$ & $O(M^2)$ & 8515 & 0.52 & 0 & $O(1)$ & 8519 & 0.48 & 0 \\
		 mergesort & $1.00 - 4.67M + 6.33M^2$ & $O(M^2)$ & 9572 & 0.64 & $-0.50M + 0.50M^2$ & $O(M^2)$ & 9578 & 0.58 & $\lfloor \log(M) \rfloor$ \\
		 ocamlsort & $7.50 + 5.50M + 1.00M^2$ & $O(M^2)$ & 8565 & 0.51 & $1.00 + 1.00M$ & $O(M)$ & 8573 & 0.50 & $M+1$ \\
		 selection sort & $2.00 + 3.00M + 1.00M^2$ & $O(M^2)$ & 639 & 0.06 & 0 & $O(1)$ & 642 & 0.05 & 0 \\
		 eratosthenes & $1.00 + 1.50M + 0.50M^2$ & $O(M^2)$ & 515 & 0.06 & 0 & $O(1)$ & 517 & 0.04 & 0 \\
		 dfs & $3.00 + 2.00M$ & $O(M)$ & 5481 & 0.90 & 2 & $O(1)$ & 5483 & 0.36 & 2 \\
		 bfs & $5.00 + 10.00M$ & $O(M)$ & 24737 & 4.15 & 4 & $O(1)$ & 24742 & 1.62 & 4 \\
		 transpose & $1.00 + 3.50LM + 0.50LM^2$ & $O(LM^2)$ & 10680 & 0.50 & $1.00 + 2.00LM$ & $O(LM)$ & 10684 & 0.50 & $\max{(0,2L-1)}$ \\
		 map\_it & $2.00 + 2.00LM + 4.00M$ & $O(LM)$ & 30699 & 1.58 & $1.00M + 1.00$ & $O(M+N)$ & 30703 & 1.57 & M + 1 \\
		 pairs & $1.00 + 1.00M^2$ & $O(M^2)$ & 10214 & 0.60 & $0.50M + 0.50M^2$ & $O(M^2+MN)$ & 10217 & 0.64 & $0.5M^2-1.5M+2$ \\ \midrule
	\end{tabular}
	\end{adjustbox}
	\caption{Automatic Bound Analysis with RaML}
\label{table:bounds}
\end{table}
\fi

\section{Conclusion and Future Work}
\label{sect:conclusion}

In this article, we introduced a novel operational cost semantics that models a perfect tracing 
garbage collector and an extension to AARA that is sound with respect to the new semantics.
We implemented the new semantics and analysis as modules in RaML and found through 
experimental testing that the extended AARA was able to derive asymptotically better bounds 
for several commonly used functions and programming patterns; often, the bounds are optimal 
with respect to the cost semantics.

One direction for future work is using the \emph{cost free} metric $\ms{cf}$ to model global garbage 
collection. In $\ms{cf}$, all resource constants, including constructor nodes, are set to 0.
A cost-free typing judgment then captures how an expression 
manipulates the structures in the context into
the structure induced by its type. Using this fact, we could express the \emph{maximum}
space usage in the sequential
composition $\irl{let}(e_1; x : \tau.e_2)$ by analyzing $e_1$ twice---once with the cost-free metric 
and once with the regular metric---and assign potential to $x$ using the result type in the cost-free typing.
In prior work \cite{Hoffmann:2015:ASC:2769448.2769449}, the authors have successfully employed this 
cost-free metric to analyze parallel programs. Here, the difficulty is showing
the simultaneous soundness of both destructive pattern matching and the cost-free composition. 
Another complication is the choice between local variable sharing and global context sharing.
We leave the exploration of this area to future work.

Another direction for future work are function closures. The current
treatment in our implementation is unsatisfactory since there is no
equivalent to the destructive pattern match for closures.  As a
result, the GC metric in RaML only accounts for allocation of
closures, which is not an improvement over the existing
implementation.  Ideally, we would like to account for deallocation at
function applications and treat closures similar to other data
structures in sharing. However, the size of closures cannot be
determined easily statically and closures can not capture
potential and are currently shared freely in RaML.  As a result, the techniques
we developed here do not directly carry over to closures.

Finally, we are interested in exploring if our work can be used to
improve the efficiency of garbage collection in languages like
OCaml. A guaranteed upper bound on the heap space can be used in
different ways to control the frequency of the collections and the
total memory that is requested from the operating system.

% we are inspired to write the following rule,
% which states that to type a composition, we need to be able to type the first expression. 
% { \small \[
% \inferr{
%   \Sigma; \Gamma_1, \Gamma_2 \sststile{q'}{q} \irl{let}(e_1; x : \tau.e_2) : B
% }{
%   \Sigma; \Gamma_1 \sststile{p}{q} e_1 : A \\
%   \Sigma; \Gamma_1 \sststile{}{\ms{cf}} e_1 : A' \\
%   \Sigma; \Gamma_2, x : (A' - 1) \sststile{q'}{p} e_2 : B
% }(\text{L:Let'})
% \]}
% Note that instead of paying for every allocation in $e_1$, 
% we only need to pay for the unit potenital for each constructor in the result $A$.
% Thus we also type $e_1$ with the cost-free metric, so the result type $A'$
% contains the same amount of potential as the context $\Gamma_1$, and pay for the 
% constructors by removing unit potential from every node in $A$, and type $e_2$ with 
% the resulting type $A'-1$. This cost-free composition rule would bring the type system closer 
% to modeling the composition in the garbage collection cost semantics.

\section*{Acknowledgments}

This article is based on research supported by the United States Air
Force under DARPA AA Contract FA8750-18-C-0092 and DARPA STAC Contract
FA8750-15-C-0082, and by the National Science Foundation under SaTC
Award 1801369 and SHF Award 1812876.
%
Yue Niu has been supported by Carnegie Mellon's Undergraduate Research
Office through a Summer Undergraduate Research Fellowship (SURF).
%
Any opinions, findings, and conclusions contained in this document are
those of the authors and do not necessarily reflect the views of the
sponsoring organizations.




\label{sect:bib}
\bibliographystyle{plain}
%\bibliographystyle{alpha}
%\bibliographystyle{unsrt}
%\bibliographystyle{abbrv}
\bibliography{easychair,lit}

%------------------------------------------------------------------------------
\appendix\label{sect:appendix}

\section{Notation}
\label{sect:notation}
For a finite mapping $f : A \to B$, we write $dom$ for the defined values of $f$. Sometimes we shorten $x \in dom(f)$ to $x \in f$. We write $f[x \mapsto y]$ for the extension of $f$ where $x$ is mapped to $y$, with the constraint that $x \notin dom(f)$. 

Given possibly non-disjoint sets $A,B$, let the disjoint union be $A \oplus B$ defined by 
$\{(\ms{inl},a) \mid a \in A\} \cup \{(\ms{inr},b) \mid b \in B\}$.

Let a multiset be a function $S : A \to \mathbb{N}$, i.e. a map of the multiplicity of each element in the domain.  Write $x \in S$ iff $S(x) \ge 1$. If for all  $s \in S$, $\mu(s) = 1$, then $S$ 
is a property set, and we denote this by $\ms{set}(S)$. Addtionally, $A \uplus B$ denotes 
counting union of sets where $(A \uplus B) (s) = A (s) + B(s)$, similarly, 
$(A \cap B)(s) = \min{A(s),B(s)}$. Furthermore, $A \cup B$ denotes the usual union where 
$(A \cup B)(s) = \max{(A(s),B(s))}$.  For the union of disjoint multi-sets $A$ and $B$, 
we write $A \sqcup B$ to emphasize the disjointness.  For a collection of pairwise disjoint 
multi-sets $\mathcal{C}$, i.e. $\forall X,Y \in \mathcal{C}$. $X \cap Y = \emptyset$, we write $\dist{\mathcal{C}}$.

In the rest of the paper, 
we sometimes treat a set $A$ sets as multiset $A : A \to \mathbb{N}$ via 
$x \mapsto \begin{cases} 1 &\text{ if } x \in A \\0 &\text{ o.w.}\end{cases}$ when convenient. 
For instance, if an operation defined on multisets is used on sets and multisets, the set 
is thus promoted.

Given a set $A$, let $\mathcal{P}(A)$ be the powerset of $A$. Given a multiset $A$, let 
$\wp(A)$ be the power multiset of $A$, i.e. the set of all submultisets of $A$.

For a partition $f : A \to \mathcal{P}(B)$, we write the set of equivalence classes
as $ec(f) = \{f(x) \mid x \in A\} = f(A)$, i.e. the image of $f$ on its domain $A$.
Furthermore, a partition is \emph{proper} if for any $x \in A$, $f(x) \neq \emptyset$.

Given a proper partition $f : A \to \mathcal{P}(B)$, for every $a \in A$, 
we can choose an arbitrary 
$b \in f(a)$ to be the representative for that part; call this $rep(a)$.

\section{Linearity of Copy Semantics}

In the soundness proof of $\fogc$, we used an important lemma: that \copySem is 
semantically linear, i.e. locations are used linearly. 
To see why, consider the second premise in the rule L:MatLD. In addition to the 
$p$ units of potential justified by the definition of linear potential, we get 1 unit 
from deallocating the cons cell itself. This is only sound if in the corresponding rule in 
\copySem a location was actually collected. Consider the evaluation in question:

\[
\infern{
  V(x) =  l\\
  H(l) = \pairexcst{v_h}{v_t} \\
	V'' = (V[x_h \mapsto v_h, x_t \mapsto v_t])\restriction_{FV(e_2)}\\
  g = \{l \in H \mid l \notin F \cup R \cup locs_{V'',H}(e_2)\}\\
  V'',H,R,F \cup g \; \vdash e_2 \Downarrow v, H',F' \\
}{
  V,H,R,F \; \vdash \listcaseexcst{x}{e_1}{x_h}{x_t}{e_2} \Downarrow v,H',F'
}
\]

If all the variables in $V$ was mapped to values with disjoint reachable sets, 
then we see that $l$ is only in the reachable set of $x$ (assuming that well-typed expressions
don't have duplicate occurences of variables, i.e. $x \notin FV(e_1) \cup FV(e_2)$. 
Then it follows that $l \in g$ given that locations in $V$, $R$, and $F$ are also all disjoint, 
and this is what we needed to justify the rule L:MatL.
Thus we have to show that \copySem preserves the linearity invariant: given a \emph{linear} 
computation, the evaluation result is also linear. 

First, we characterize semantically linear contexts: 

\begin{definition}(Linear context)
Given a context $(V,H)$, let
$x,y \in dom(V)$, $x \ne y$, and $r_x = reach_H(V(x))$, $r_y = reach_H(V(y))$.
	It is \emph{linear} given that:
\begin{enumerate}
\item $\ms{set}(r_x), \ms{set}(r_y)$
\item $r_x \cap r_y = \emptyset$
\end{enumerate}
Denote this by $\na{V,H}$.
\end{definition}

Whenever $\na{V,H}$ holds, visually, one can think of the 
stack as a collection of disjoint, directed trees with locations as nodes; 
consequently, there is at 
most one path from a variable on the stack $V$ to any location in $H$. Now we can 
formalize our intuition for linear computations: 

\begin{definition}[Linear computation]
Given a configuration $\mathcal{C} = (V,H,R,F)$ and an expression $e$, 
we say the 5-tuple $(\mathcal{C},e)$ is a \emph{computation}; it is a \emph{linear computation} 
given the following:
\begin{enumerate}
\item $dom(V) = FV(e)$
\item $\na{V,H}$
\item $\dist{\{R,F,locs_{V,H}(e)\}}$
\end{enumerate} 
And we write $\wfc{V}{H}{R}{F}{e}$ to denote this fact.
\end{definition}

% main lemma
Given a semantically linear computation 
(one with no sharing between the underlying locations), the resulting value is linear 
(expressed by item 1. and 2. below):
\begin{lemma}[Linearity of \copySem]\label{itm:na}
For all stacks $V$ and heaps $H$, let  $V,H,R,F \; \vdash e \Downarrow v, H', F'$ 
and $\Sigma; \Gamma \vdash e : B$. Then given that $\wfc{V}{H}{R}{F}{e}$, we have the follwoing: 
\begin{enumerate}
\item $\ms{set}(reach_{H'}(v))$
\item $\dist{\{R,F',reach_{H'}(v)\}}$, and
\item $\stable{R,H,H'}$
\end{enumerate}
\end{lemma}

Where $\ms{stable}$ is a predicate on $\mathcal{P}(\ms{Loc}) \times \ms{Heap} \times \ms{Heap}$, defined
below. The premises of this lemma is a subset of the premises of the soundness theorem. 
Thus, we could have
merged the proof of this lemma directly into the soundness proof. However, we think this makes the 
presentation clearer; furthermore, the linearity of \copySem is an interesting in itself, 
regardless of the accompanying type system. Some auxiliary lemmas:


Define $\dagger :  L^p(A) \mapsto L(A)$ as the map that erases resource annotations. 
This gives a simplified jugdment \fbox{$\Sigma^{\dagger}; \Gamma^{\dagger} \vdash e : B^{\dagger}$}
used in proofs where the resource annotations are not necessary.

\begin{lemma}
\label{a} If $\Sigma; \Gamma \sststile{q'}{q} e : B$, then $\Sigma^{\dagger}; \Gamma^{\dagger} \vdash e : B^{\dagger}$.
\end{lemma}

\begin{proof}
Induction on the typing judgement.
\end{proof}

Define $FV^{\star} : \ms{Exp} \to \wp(\ms{Var})$, the multiset of free variables of expressions,
as the usual $FV$ inductively over the structure of $e$. This version of $FV$ reflects 
the multiplicity of variable occurences.

\begin{lemma}\label{itm:linear}
\label{a} If $\Sigma; \Gamma \sststile{q'}{q} e : B$, then $\set{FV^{\star}(e)}$ and $dom(\Gamma) = FV(e)$.
\end{lemma}

\begin{proof}
Induction on the typing judgement.
\end{proof}

\begin{definition}[Stability]
Given heaps $H,H'$, a set of locations is \emph{stable} if $\forall l \in R$. $H(l) = H'(l)$. Denote this by
$\stable{R,H,H'}$.
\end{definition}

\begin{lemma}
Let $H \vDash v \mapsto a : A$. For all sets of locations $R$, if $reach_H(v) \subseteq R$ and $\stable{R,H,H'}$, then $H' \vDash v \mapsto a : A$ and $reach_H(v) = reach_{H'}(v)$.
\end{lemma}

\begin{proof}
Induction on the structure of $H \vDash v \mapsto a : A$.
\end{proof}

\begin{corollary}
Let $H \vDash V : \Gamma$. For all sets of locations $R$, if $\bigcup_{x \in V} reach_H(V(x)) \subseteq R$ and $\stable{R,H,H'}$, then $H' \vDash V : \Gamma$.
\end{corollary}

\begin{proof}
Follows from Lemma $\ref{itm:stable}$.
\end{proof}

% copy

\begin{lemma}[stability of copying]
	Let $H',v' = copy(H,L,v)$. For all $l \in H$, if $l \notin L$, then $H(l) = H'(l)$. 
	Further, $reach_{H'}(v') \subseteq L$.
\end{lemma}

\begin{lemma}[copy is copy]
	Let $H',v' = copy(H,L,v)$. If $H \vDash v \mapsto a : A$, then $H' \vDash v' \mapsto a : A$.
\end{lemma}

\begin{lemma}
	Let $A \curlyvee^n A_1,A_2$, $H \vDash v_1 : A_1$, $H \vDash v_2 : A_2$, 
	and $H \vDash v : A$. Then $\Phi_{H}(v : A) = 
	\Phi_{H}(v_1 : A_1) + \Phi_{H}(v_2 : A_2) + n\cdot |dom(reach_H(v))|$
\end{lemma}

\begin{lemma}
	Let $H \vDash V : \Gamma$, $\Sigma;\Gamma \vdash e : A$, and $V,H \vdash e \Downarrow v,H'$. Then 
	$H' \vDash v : A$.
\end{lemma}

Now the proof for linearity of \copySem{}:
\begin{proof}
Nested induction on the evaluation judgement and the typing judgement.\\
\begin{description}
  \item[Case 1: E:Var]
  \begin{align*}
  &\text{Suppose } H \vDash V : \Gamma, dom(V) = FV(e), \na{V,H}, \dist{\{R,F,locs_{V,H}(e)\}}\\
  &\ms{set}(reach_{H}(v)) \tag{$\na{V,H}$}\\
  &\dist{\{R,F,reach_{H}(v)\}} \tag{$\dist{\{R,F,locs_{V,H}(e)\}}$}\\
  &\na{V,H} \tag{Sp.}\\
  &\stable{R,H,H'} \tag{$H = H'$}
  \end{align*}
  \item[Case 2: E:Const*]
  Due to similarity, we show only for E:ConstI
  \begin{align*}
  &\text{Suppose } H \vDash V : \Gamma, dom(V) = FV(e), \na{V,H},\dist{\{R,F,locs_{V,H}(e)\}}\\
  &\ms{set}(reaach_{H}(v)) \tag{$reach_H(v) = \emptyset$}\\
  &\dist{\{R,F,\emptyset\}} \tag{$\dist{R,F}$}\\
  &\na{V,H} \tag{Sp.}\\
  &\stable{R,H,H'} \tag{$H = H'$}
  \end{align*}
  \item[Case 4: E:App]
  \item[Case 5: E:CondT] Similar to E:MatNil
  \item[Case 6: E:CondF] Similar to E:CondT
  \item [Case 7: E:Let]
  \begin{align*}
  &V,H,R,F \; \vdash \irl{let}(e_1; x : \tau.e_2) \Downarrow v_2,H_2,F_2 \tag{case}\\
  &V_1,H,R',F \vdash e_1 \Downarrow v_1,H_1,F_1 \tag{ad.}\\
  &\Sigma; \Gamma_1,\Gamma_2 \vdash \irl{let}(e_1; x : \tau.e_2) : B \tag{case}\\
  &\Sigma; \Gamma_1 \vdash e_1 : A \tag{ad.}\\
  &\text{Suppose } H \vDash V : \Gamma, dom(V) = FV(e), \na{V,H}, \dist{\{R,F,locs_{V,H}(e)\}}\\ 
  &H \vDash V_1 : \Gamma_1 \tag{def of W.D.E and Lemma $~\ref{itm:linear}$}\\
		&\text{By IH, we have invariant on the first premise}\\
		&\text{NTS (1) - (3) to instantiate invariant on the first premise}\\
  &\emph{(1)}\quad dom(V_1) = FV(e_1) \tag{def of $V_1$}\\
  &\emph{(2)}\quad \na{V_1,H} \tag{$\na{V,H}$ and $V_1 \subseteq V$}\\
  &\emph{(3)}\quad \dist{R',F,locs_{V,H}(e_1)}\\
  &F \cap R' = \emptyset \tag{$F \cap locs_{V,H}(e) = \emptyset$ and $locs_{V_2,H}(\irl{lam}(x : \tau. e_2)) \subseteq locs_{V,H}(e)$}\\
  &FV(e_1) \cap FV(\irl{lam}(x : \tau. e_2)) = \emptyset \tag{Lemma ~\ref{itm:linear}}\\
  &locs_{V,H}(e_1) \cap locs_{V_2,H}(\irl{lam}(x : \tau. e_2)) = \emptyset \tag{$\na{V,H}$}\\
  &R' \cap locs_{V,H}(e_1) = \emptyset \tag{$\dist{\{R,locs_{V,H}(e)\}}$}\\
  &F \cap locs_{V,H}(e_1) = \emptyset \tag{Sp.}\\
  &\text{Thus we have } \dist{R',F,locs_{V,H}(e_1)}\\
  &\text{By IH, }\\
  &\emph{1.(1)}\quad \ms{set}(reach_{H_1}(v_1))\\
  &\emph{1.(2)}\quad \dist{\{R',F_1,reach_{H_1}(v_1)\}}\\
  &\emph{1.(3)}\quad \stable{R',H,H_1}\\
  &V_2',H_1,R, F_1 \cup g \vdash e_2 \Downarrow v_2,H_2,F_2 \tag{ad.} \\
  &\Sigma; \Gamma_2, x : A \vdash e_2 : B \tag{ad.}\\
		&H_1 \vDash V_2' : (\Gamma_2, x : A) \tag{Lemma~\ref{itm:wellFormed}}\\
  &\text{By IH, we have invariant on the second premise } \\
		&\text{NTS (1) - (3) to instantiate invariant on the second premise}\\
  &\emph{(1)}\quad dom(V_2') = FV(e_2) \tag{def of $V_2'$}\\
  &\emph{(2)}\quad \na{V_2',H_1}\\
  &\text{Let } x_1, x_2 \in V2', x_1 \ne x_2 \text{ be arb.}\\
  &\textbf{case: } x_1 \ne x, x_2 \ne x\\
  &\quad reach_H(V_2'(x_1)) \subseteq R' \tag{$reach_H(V_2'(x_1)) \subseteq locs_{V_2',H}(\irl{lam}(x : \tau. e_2))$}\\
  &\quad reach_H(V_2'(x_2)) \subseteq R' \tag{$reach_H(V_2'(x_2)) \subseteq locs_{V_2',H}(\irl{lam}(x : \tau. e_2))$}\\
  &\quad reach_H(V_2'(x_1)) = reach_{H_1}(V_2'(x_1)),reach_H(V_2'(x_2)) = reach_{H_1}(V_2'(x_2)) \tag{$\stable{R',H,H_1}$ and Lemma $~\ref{itm:stable}$}\\
  &\quad reach_{H_1}(V_2'(x_1)) = reach_{H}(V(x_1)),reach_{H_1}(V_2'(x_2)) = reach_{H}(V(x_2)) \tag{$\stable{R',H,H_1}$ and Lemma $~\ref{itm:stable}$}\\
  &\quad \na{V_2',H_1} \tag{$\na{V,H}$}\\
  &\textbf{case: } x_1 = x, x_2 \ne x\\
  &\quad reach_{H_1}(V_2'(x_1)) = reach_{H_1}(v_1) \tag{def of $V_2'$}\\
  &\quad reach_{H_1}(V_2'(x_2)) \subseteq R' \tag{same as above}\\
  &\quad \ms{set}(reach_{H_1}(v_1)) \tag{IH 1.1}\\
  &\quad reach_{H_1}(V_2'(x_2)) = reach_{H}(V(x_2)) \tag{same as above}\\
  &\quad \ms{set}(reach_{H_1}(V_2'(x_2))) \tag{$\na{V,H}$}\\
  &\quad reach_{H_1}(V_2'(x_1)) \cap reach_{H_1}(V_2'(x_2)) = \emptyset \tag{$\dist{\{R',reach_{H_1}(v_1)\}}$}\\
  &\text{Thus we have } \na{V_2',H_1}\\
  &\emph{(3)}\quad \dist{\{R,F_1 \cup g,locs_{V_2',H_1}(e_2)\}}\\
  &R \cap F_1 = \emptyset \tag{$\dist{\{R', F_1\}}$ from 1.2 and $R \subseteq R'$}\\
  &R \cap (F_1 \cup g) = \emptyset \tag{def of $g$}\\
  &\text{NTS } (F_1 \cup g) \cap locs_{V_2',H_1}(e_2) = \emptyset\\
  &\text{Let } l \in locs_{V_2',H_1}(e_2) \text{ be arb.}\\
  &l \in reach_{H_1}(V_2'(x')) \text{ for some } x' \in V_2'\\
  &\textbf{case: } x' \ne x\\
  &\quad reach_H(V_2(x')) = reach_{H_1}(V_2'(x')) \tag{same as above}\\
  &\quad reach_{H_1}(V_2'(x')) \subseteq R' \tag{def of $R'$}\\
  &\quad reach_{H_1}(V_2'(x')) \cap F_1 = \emptyset \tag{$\dist{\{R', F_1\}}$ from 1.2}\\
  &\text{case: } x' = x\\
  &\quad reach_{H_1}(V_2'(x')) = reach_{H_1}(v_1) \tag{def of $V_2'$}\\
  &\quad reach_{H_1}(V_2'(x')) \cap F_1 = \emptyset \tag{$\dist{\{F_1,reach_{H_1}(v_1)\}}$ from 1.2}\\
  &reach_{H_1}(V_2'(x')) \subseteq locs_{V_2',H_1}(e_2) \tag{def of $locs_{V,H}$}\\
  &reach_{H_1}(V_2'(x')) \cap g = \emptyset \tag{def of $g$}\\
  &\text{Thus } reach_{H_1}(V_2'(x')) \cap (F_1 \cup g) = \emptyset\\
  &\text{NTS } R \cap locs_{V_2',H_1}(e_2) = \emptyset\\
  &\text{Let } l \in locs_{V_2',H_1}(e_2) \text{ be arb.}\\
  &l \in reach_{H_1}(V_2'(x')) \text{ for some } x' \in V_2'\\
  &\textbf{case: } x' \ne x\\
  &\quad reach_H(V_2(x')) = reach_{H_1}(V_2'(x')) \tag{same as above}\\
  &\quad l \in locs_{V,H}(e) \tag{def of $locs_{V,H}$}\\
  &\quad l \notin R \tag{$\dist{\{R,locs_{V,H}(e)\}}$ from 0.3}\\
  &\textbf{case: } x' = x\\
  &\quad reach_{H_1}(V_2'(x')) = reach_{H_1}(v_1) \tag{def of $V_2'$}\\
  &\quad reach_{H_1}(V_2'(x')) \cap R = \emptyset \tag{$\dist{\{R', reach_{H_1}(v_1)\}}$ from 1.2 and $R \subseteq R'$}\\
  &\text{Thus } reach_{H_1}(V_2'(x')) \cap R = \emptyset\\
  &\text{Hence we have }\emph{(3)}\quad \dist{R,F_1 \cup g,locs_{V_2',H_1}(e_2)}\\
  &\text{By instantiating the invariant on the second premise } , \text{ we have }\\
  &\emph{2.(1)}\quad \ms{set}(reach_{H_2}(v_2))\\
  &\emph{2.(2)}\quad \dist{\{R,F_2,reach_{H_2}(v_2)\}}\\
  &\emph{2.(3)}\quad \stable{R,H_1,H_2}\\
  &\text{Lastly, showing (1) - (3) holds for the original case }:\\
  &\emph{(1)}\quad \ms{set}(reach_{H_2}(v_2)) \tag{By 2.1}\\
  &\emph{(2)}\quad \dist{\{R,F_2,reach_{H_2}(v_2)\}} \tag{By 2.2}\\
  &\emph{(3)}\quad \stable{R,H_1,H_2}\\
  &\text{Let } l \in R \text{ be arb. }\\
  &H(l) = H_1(l) \tag{$\stable{R',H,H_1}$ from 1.3}\\
  &H_1(l) = H_2(l) \tag{$\stable{R,H_1,H_2}$ from 2.3}\\
  &H(l) = H_2(l)\\
  &\text{Hence } \stable{R,H,H_2}\\
  \end{align*}
  \item[Case 8: E:Pair]
  Similar to E:Var
  \item[Case 9: E:MatP]
  Similar to E:MatCons
  \item[Case 10: E:Nil]
  Similar to E:Const*
  \item[Case 11: E:Cons]
  \begin{align*}
  &V,H,R,F \; \vdash e \Downarrow l,H'',F' \tag{case}\\
  &\text{Suppose } H \vDash V : \Gamma, dom(V) = FV(e), \na{V,H}, \dist{\{R,F,locs_{V,H}(e)\}}\\
  &\text{NTS (1) - (3) holds after evaluation }\\
  &\emph{(1)} \quad \ms{set}(reach_{H''}(l))\\
  &\stable{\{locs_{V,H}(e)\},H,H''} \tag{$\dist{\{F,locs_{V,H}(e)\}}$ and $copy$ only updates $l \in L \subseteq F$}\\
  &reach_H(V(x_i)) = reach_{H''}(V(x_i)) \tag{$reach_H(V(x_i)) \subseteq locs_{V,H}(e)$ and $~\ref{itm:stable}$ for $i = 1,2$}\\
  &reach_{H''}(l) = \{l\} \cup reach_{H''}(V(x_1))\cup reach_{H''}(V(x_2)) \tag{def of $reach_H$}\\
  &\set{reach_{H''}(l)} \tag{$l \notin locs_{V,H}(e)$ and $\na{V,H}$}\\ 
  &\emph{(2)} \quad \dist{\{R,F',reach_{H''}(l)\}}\\
  &R \cap F' = \emptyset \tag{$F' \subseteq F$ and $\dist{\{R,F\}}$}\\
  &R \cap reach_{H''}(l) = \emptyset \tag{$l \in F$ and $\dist{\{R,locs_{V,H}(e)\}}$}\\
  &F' \cap reach_{H''}(l) = \emptyset\tag{$F' \subseteq F$ and $\dist{\{F,locs_{V,H}(e)\}}$}\\
  &\text{Thus we have }\emph{(2)} \quad \dist{\{R,F',reach_{H''}(l)\}}\\
  &\emph{(3)} \quad \stable{R,H,H''} \tag{since copy only updates $l \in L \subseteq F$ and $F \cap R = \emptyset$}\\
  \end{align*}
  \item[Case 12: E:MatNil]
  \begin{align*}
  &\text{Suppose } H \vDash V : \Gamma, dom(V) = FV(e), \na{V,H}, \dist{\{R,F,locs_{V,H}(e)\}}\\
  &\Sigma; \Gamma' \vdash e_1 : B \tag{ad.}\\
  &V',H,R,F \cup g \; \vdash e_1 \Downarrow v, H',F' \tag{ad.}\\
  &H \vDash V' : \Gamma' \tag{def of W.D.E}\\
  &\text{By IH, we have invariant on the premise } \\
  &\text{NTS (1) - (3) to instantiate invariant on the premise } \\
  &\emph{(1)}\quad dom(V') = FV(e_1) \tag{def of $V'$}\\
  &\emph{(2)}\quad \na{V',H} \tag{$\na{V,H}$ and $V' \subseteq V$}\\
  &\emph{(3)}\quad \dist{\{R,F,locs_{V',H}(e_1)\}} \tag{$\dist{\{R,F,locs_{V,H}(e)\}}$ and $locs_{V',H}(e_1) \subseteq locs_{V,H}(e)$}\\
  &\text{Instantiating invariant on premise } ,\\
  &\emph{(1)}\quad \ms{set}(reach_{H'}(v))\\
  &\emph{(2)}\quad \dist{\{R,F_1,reach_{H'}(v)\}}\\
  &\emph{(3)}\quad \stable{R,H,H'}
  \end{align*}
  \item [Case 13: E:MatCons]
  \begin{align*}
  &V(x) = l \tag{ad.}\\
  &H(l) = \pairexcst{v_h}{v_t} \tag{ad.}\\
  &\Gamma = \Gamma', x : L(A) \tag{ad.}\\
  &\Sigma; \Gamma', x_h : A, x_t : L(A) \vdash e_2 : B \tag{ad.}\\
  &V'',H,R,F \cup g \; \vdash e_2 \Downarrow v_2, H_2, F' \tag{ad.} \\
  &\text{Suppose } H \vDash V : \Gamma, dom(V) = FV(e), \na{V,H},\dist{\{F,R,locs_{V,H}(e)\}}\\
  &H \vDash V(x) : L(A) \tag{def of W.D.E}\\
  &H\vDash v_h : A,\; H \vDash v_t : L(A) \\
  &H \vDash V'' : \Gamma', x_h : A, x_t : L(A) \tag{def of W.D.E}\\
  &\text{By IH, we have invariant on the premise} \\
  &\text{NTS (1) - (3) to instantiate invariant on the premise} \\
  &\emph{(1)}\quad dom(V'') = FV(e_2) \tag{def of $V''$}\\
  &\emph{(2)}\quad \na{V'',H} \\
  &\text{Let } x_1, x_2 \in V'', x_1 \ne x_2, r_{x_1} = reach_H(V''(x_1)), r_{x_2} = reach_H(V''(x_2))\\
  & \textbf{case: } x_1 \notin \{x_h,x_t\}, x_2 \notin \{x_h,x_t\}\\
  &\quad (1), (2) \text{ from } \na{V,H}\\
  & \textbf{case: } x_1 = x_h, x_2 \notin \{x_h,x_t\}\\
  &\quad \ms{set}(r_{x_1}) \tag{ since $\ms{set}(reach_H(V(x)))$ from  $\na{V,H}$}\\
  &\quad \ms{set}(r_{x_2}) \tag{since  $\na{V,H}$}\\
  &\quad x_2 \in FV(e) \tag{def of $FV$}\\
  &\quad reach_H(V(x)) \cap r_{x_2} = \emptyset \tag{def of $reach$ and $\na{V,H}$}\\
  &\quad \text{hence } r_{x_1} \cap r_{x_2} = \emptyset\\
  &\textbf{case: } x_1 = x_h, x_2 = x_t\\
  &\quad \ms{set}(r_{x_1}) \text{ since } \ms{set}(reach_{H}(V(x))) \text{ from } \na{V,H}\\
  &\quad \ms{set}(r_{x_2}) \text{ since } \ms{set}(reach_H(V(x))) \text{ from } \na{V,H}\\
  &\quad r_{x_1} \cap r_{x_2} = \emptyset \tag{$\ms{set}(reach_H(V(x))$}\\
  & \textbf{case: otherwise} \\
  &\quad \text{similar to the above}\\
  &\text{Thus we have } \na{V'',H}\\
  &\emph{(3)}\quad \dist{\{R,F \cup g,locs_{V'',H}(e_2)\}}\\
  &(F \cup g) \cap R = \emptyset \tag{ since $F \cap R = \emptyset$ and by def of $g$}\\
  &\text{NTS } R \cap locs_{V'',H}(e_2) = \emptyset\\
  &\text{Let } l' \in locs_{V'',H}(e_2) \text{ be arb.}\\
  &\textbf{case: }  l' \in reach_{H}(V''(x')) \text{ for some $x' \in FV(e_2)$ where } x' \notin \{x_h,x_t\}\\
  &\quad x' \in V \tag{def of $V''$}\\
  &\quad l' \in reach_{H}(V(x'))\\
  &\quad x' \in FV(e) \tag{def of $FV$}\\
  &\quad l' \in locs_{V,H}(e) \tag{def of $locs_{V,H}$}\\
  &\quad l' \notin R \tag{$\dist{\{R,F,locs_{V,H}(e)\}}$}\\
  &\textbf{case: }  l' \in reach_{H}(V''(x_h)) \\
  &\quad l' \in reach_{H}(v_h)\\
  &\quad l' \in reach_{H}(V(x)) \tag{def of $reach$}\\
  &\quad l' \in locs_{V,H}(e) \tag{def of $locs_{V,H}$}\\
  &\quad l' \notin R \tag{since $\dist{\{F,R,locs_{V,H}(e)\}}$}\\
  &\textbf{case: }  l' \in reach_{H}(V''(x_t)) \\
  &\quad \text{similar to above}\\
  &\text{Hence } R \cap locs_{V'',H}(e_2) = \emptyset\\
  &F \cap locs_{V'',H}(e_2) = \emptyset \tag{Similar to above}\\
  &g \cap locs_{V'',H}(e_2) = \emptyset \tag{def. of $g$}\\
  &(F \cup g) \cap locs_{V'',H}(e_2) = \emptyset\\
  &\text{Thus } \dist{\{R,F \cup g,locs_{V'',H}(e_2)\}}\\
  &\text{Instantiating invariant on the premise} ,\\
  &\emph{(1)} \quad \ms{set}(reach_{H'}(v))\\
  &\emph{(2)} \quad\dist{\{R,F',reach_{H'}(v)\}}\\
  &\emph{(3)} \quad\stable{R,H,H'}\\
  \end{align*}
	\item [Case 13: E:Share]
  \begin{align*}
  &e = \sharecpcst{x}{x_1}{x_2}{e'} \tag{case}\\
  &\text{Suppose } H \vDash V : \Gamma, dom(V) = FV(e), \na{V,H}, \dist{\{R,F,locs_{V,H}(e)\}} 
		\tag{def. of wfc} \\
		&\text{Let } V_2 = (V[x_1 \mapsto v', x_2 \mapsto v''])\restriction_{FV(e')}\\
	&\text{We show the subsequent computation is also well-formed to invocate the IH:}\\
  &\emph{(1)} \quad dom(V_2) = FV(e') \tag{$dom(V) = FV(e)$ and def of $FV$}\\
		&\emph{(2)} \quad \na{(V[x_1 \mapsto v', x_2 \mapsto v''])\restriction_{FV(e')},H}\\
  &\quad \text{Let } x' \mapsto v''' \in V'[x_1 \mapsto v']. 
		\text{STS } reach_{H'}(v''') \cap reach_{H'}(v'') = \emptyset\\
	&\quad reach_{H'}(v'') \subseteq L \subseteq F \tag{definition of copy}\\
	&\quad reach_{H'}(v''') \subseteq locs_{V'[x_1\mapsto v'],H'}(e') \subseteq locs_{V,H}(e) 
		\tag{By Lemma~\ref{itm:copyStable}}\\ 
	&\quad \text{but since } F \cap locs_{V,H}(e) = \emptyset, \text{we have the result.}
		 \tag{$\wfc{V}{H}{R}{F}{e}$}\\
  &\emph{(3)} \quad \dist{\{R,F \setminus L,locs_{V_2,H'}(e')\}}\\
	&\quad \text{Disjointedness involving $F$ follows from assumption. Last one follows since }
		locs_{V_2,H'}(e') \subseteq locs_{V,H}(e) \cup L\\
	&\text{By IH:}\\
  &\emph{(1)} \quad \set{reach_{H''}(v)}\\
  &\emph{(2)} \quad \dist{\{R,F',reach_{H''}(v)\}}\\
  &\emph{(3)} \quad \stable{R,H',H''}\\
		&\text{STS } \stable{R,H,H'}, \text{ which follows from $L \cap R = \emptyset$ and Lemma~\ref{itm:copyStable}}\\
  \end{align*}
  \end{description}
\end{proof}

\section{Soundness}
\begin{theorem}[Soundness]
\label{b} let $H_o \vDash V_o : \Gamma$, $\Sigma; \Gamma \sststile{q'}{q} e : B$,
$V_o,H_o \; \vdash e \Downarrow v_o, H_o'$.
Then $\forall C \in \mathbb{Q}^{+}$ and configuration $V,H,R,F$ s.t.
\begin{enumerate} 
\item $V_o,H_o \sim V,H$
\item $dom(V) = FV(e)$
\item $\na{V,H}$
\item $\dist{\{R,F,locs_{V,H}(e)\}}$
\item $|F| \ge \Phi_{V,H}(\Gamma) + q + C$ 
\end{enumerate}
then there exists a triple $(v,H',F')$, and a freelist $F'$ s.t.
\begin{enumerate}
  \item $V,H,R,F \vdash e \Downarrow v, H', F'$
	\item $\veq{H_o'}{H'}{v_o}{v}$
  \item $|F'| \ge \Phi_{H'}(v:B) + q' + C$
\end{enumerate}
Call this the existence clause.
\end{theorem}

\begin{proof}
Nested induction on the evaluation judgement and the typing judgement.\\
\begin{description}
  \item[Case 1: E:Var]
  \begin{align*}
  &V_o,H_o \; \vdash x \Downarrow V_o(x),H_o \tag{case}\\
  &\Sigma; x : B \sststile{q}{q} x : B \tag{case}\\
		&\text{Let } C \in \mathbb{Q}^+, \text{well-formed configuration } V,H,R,F \text{ s.t. }
		V_o,H_o \sim V,H
			\text{ and }|F| \ge \Phi_{V,H}(x : B) + q + C\\
		&\text{NTS the conclusions for the existence clause: }\\
		&\emph{(1) }V,H,R,F \vdash e \Downarrow V(x),H,F \tag{E:Var}\\
		&\emph{(2) }\veq{H_o}{H}{V_o(x)}{V(x)} \tag{assumption}\\
		&\emph{(3) }\text{And we have } F \ge \Phi_{V,H}(x : B) + q + C\\
	&\quad = \Phi_{H}(V(x) : B) + q + C \tag{definition of $\Phi$}\\
  \end{align*}
  \item[Case 2: E:Const*] Similar to E:Var
  \item[Case 4: E:App]
		\begin{align*}
			&V_o,H_o \vdash f(x) \Downarrow v_o,H_o' \tag{case}\\
			&V_o(x) = v_o' \tag{admissibility}\\
			&\text{Let } P(f) = (y_f,e_f)\\
			&[y_f \mapsto v_o'],H_o \vdash e_f \Downarrow v_o,H_o' \tag{admissibility}\\
			&\Sigma; x : A \sststile{q'}{q} f(x) : B \tag{case}\\
			&\Sigma(f) = A \xrightarrow{q/q'} B \tag{admissibility}\\
		&\text{Let } C \in \mathbb{Q}^+, \text{well-formed configuration } V,H,R,F \text{ s.t. }
		V_o,H_o \sim V,H
			\text{ and }|F| \ge \Phi_{V,H}(x : A) + q + C\\
			&\Sigma; y_f : A \sststile{q'}{q} e_f : B \\
			&\text{Let } V(x) = v', g = collect(R,locs_{V,H}(e_f),H,F)\\
			&\text{By IH on } [y_f \mapsto v'],H,R,F\cup g, \text{ have the  existence clause. NTS the
				following conditions: }\\
			&\emph{(1) }[y_f \mapsto v_o'],H_o \sim [y_f \mapsto v'],H 
				\tag{$\veq{H_o}{H}{v_o'}{v'}$ by assumption}\\
			&\emph{(2) - (4) } \text{Have by assumption }\\
			&\emph{(5) } \text{NTS } |F \cup g| \ge \Phi_{[y_f \mapsto v'],H}(x : A) + q + C\\
			&\quad \text{STS } |F| \ge  \Phi_{[y_f \mapsto v'],H}(y_f : A) + q + C\\
			&\quad |F| \ge \Phi_{V,H}(x : A) + q + C\\
			&\quad = \Phi_H(v' : A) + q + C\\
			&\quad = \Phi_{[y_f \mapsto v'],H}(y_f : A) + q + C\\
			&\text{Applying the existence clause and E:App, we're done. }
		\end{align*}
  \item[Case 5: E:CondT]
  \begin{align*}
  &\Gamma = \Gamma', x : \irl{bool} \tag{ad.}\\
  &H \vDash V : \Gamma' \tag{def of W.F.E}\\
  &\Sigma; \Gamma' \sststile{q'}{q} e_t : B \tag{ad.}\\
  &V,H,R,F \cup g\; \vdash e_t \Downarrow v, H',F' \tag{ad.}\\
  &|F \cup g| - |F'| \le \Phi_{V,H}(\Gamma) +q - (\Phi_{H'}(v:B) + q') \tag{IH}\\
  &|F| - |F'| \le \Phi_{V,H}(\Gamma) +q - (\Phi_{H'}(v:B) + q') \\
  \end{align*}
  \item[Case 6: E:CondF] 
  Similar to E:CondT
  \item[Case 7: E:Let]
  \begin{align*}
  &V_o,H_o \vdash e \Downarrow v_o'',H_o'' \tag{case}\\
		&V_o' = V_o\restriction_{dom(FV(e_1)} \tag{ad.}\\
  &V_o',H_o \vdash e_1 \Downarrow v_o',H_o' \tag{ad.}\\
		&\Sigma; \Gamma \sststile{q'}{q} \irl{let}(e_1; x : \tau.e_2) : B \tag{case}\\
		&\Gamma = \Gamma_1,\Gamma_2 \tag{ad.}\\
  &\Sigma; \Gamma_1 \sststile{p}{q} e_1 : A \tag{ad.}\\
  &H \vDash V_o' : \Gamma_1 \tag{def of $\vDash$}\\
		&\text{Let } C \in \mathbb{Q}^+, \text{well-formed configuration } V,H,R,F \text{ s.t. }
		V_o,H_o \sim V,H
			\text{ and }|F| \ge \Phi_{V,H}(\Gamma) + q + C\\
  &\text{NTF } v_2,H_2,F_2 \text{ s.t. }\\
  &\quad 1. V,H,R,F \vdash e \Downarrow v_2, H_2,F_2 \text{ and }\\ 
	&\quad 2. \veq{H_o''}{H_2}{v_o''}{v_2}\\
  &\quad 3. |F_2| \ge \Phi_{H_2}(v_2:B) + q' + C\\
	&\text{Let } R' = R \cup locs_{V,H}(FV(e_2) \setminus \{x\})\\
  &\dist{\{R',F,locs_{V,H}(e_1)\}} \tag{Similar to case in Lemma $~\ref{itm:na}$}\\
	&\text{Let } V_1 = V\restriction_{dom(FV(e_1)}\\
  &\text{Instantiate IH with } C = C + \Phi_{V_2,H}(\Gamma_2), V = V_1, H = H, F = F, R = R'\\ 
	&\quad\text{ we get existence clause on the first premise }\\
  &\text{NTS (1) - (4) to instantiate existence clause on the first premise: } \\
	&\emph{(1) } V_o',H_o \sim V_1, H \tag{assumption}\\
		&\emph{(2) - (4)} \text{Same as in \ref{itm:na}}\\
  &\emph{(4) } |F| \ge \Phi_{V_1,H}(\Gamma_1) + q + C + \Phi_{V,H}(\Gamma_2) \tag{$|F| \ge \Phi_{V,H}(\Gamma) + q + C$ and $\Phi_{V,H}(\Gamma) \ge \Phi_{V_1,H}(\Gamma_1) + \Phi_{V,H}(\Gamma_2)$}\\
  &\text{Instantiating existence clause on the first premise } , \text{ we get } 
		v_1,H_1,F_1 \text{ s.t. }\\
		&\quad \text{Fact 1. } V_1,H,R',F \vdash e_1 \Downarrow v_1, H_1,F_1\\
		&\quad \text{Fact 2. } \veq{H_o'}{H_1}{v_o'}{v_1}\\
		&\quad \text{Fact 3. } |F_1| \ge \Phi_{H_1}(v_1:A) + p + C + \Phi_{V_2,H_1}(\Gamma_2)\\
  &\text{For the second premise: }\\
	&V_o'' = (V_o[x \mapsto v_o'])\restriction_{FV(e_2)} \tag{ad.}\\
  &V_o'',H_o' \vdash e_2 \Downarrow v_o'',H_o'' \tag{ad.}\\
  &\Sigma; \Gamma_2, x : A \sststile{q'}{p} e_2 : B \tag{ad.}\\
	&H_1 \vDash v_o' : A \tag{By Lemma~\ref{itm:stable} and~\ref{itm:wellFormed}}\\ 
	&H_1 \vDash V_2 : \Gamma_2, x : A \tag{def of $\vDash$}\\
	&\text{Let } V_2 =  (V[x \mapsto v_1])\restriction_{FV(e_2)}\\
  &\text{Let } g = \{l \in H_1 \mid l \notin F_1 \cup R \cup locs_{V_2,H_1}(e_2)\}\\ 
  &\text{Instantiate IH with } C = C, V = V_2, H = H_1, F = F_1 \cup g, R = R, 
		\text{ we get existence clause on the second premise}\\
  &\text{NTS (1) - (4) to instantiate existence clause on the second premise: }\\
	&\emph{(1) } V_o'',H_o' \sim V_2,H_1 \tag{assumption and Fact 2.}\\
	&\emph{(2) - (4)} \text{ Same as Lemma $\ref{itm:na}$}\\
	&\emph{(5) }  |F_1 \cup g| \ge \Phi_{V_2,H_1}(\Gamma_2,x : A) + p + C\\
	&\quad \text{STS } |F_1| \ge \Phi_{V_2,H_1}(\Gamma_2,x : A) + p + C\\
		&\quad \text{Have } |F_1| \ge
			\Phi{V_2,H_1}(\Gamma_2) + \Phi_{H_1}(v_1:A) + p + C \tag{By Fact 3.}\\
		&\text{Instantiate the existence clause on the second premise and apply E:Let and we're done}\\
		\iffalse
  &\emph{(4)} \quad |F'' \cup g| \ge \Phi_{V_2',H_1}(\Gamma_2,x: (\cf{A} - 1)) + p + C\\
  &\quad \text{STS } |F'' \cup g| \ge \Phi_{V_2,H_1}(\Gamma_2) + \Phi_{H_1}(v_1 : (\cf{A} - 1)) + p + C\\
  &\quad |F'' \cup g| \ge \ssize{H}{V_1} + |F| - \ssize{H_1}{v_1} \tag{conservation lemma}\\
  &\quad \ge \Phi_{V,H}(\Gamma) + q + C + \ssize{H}{V_1} - \ssize{H_1}{v_1} 
    \tag{$|F| \ge \Phi_{H}(V) + q + C$ }\\
  &\quad \text{STS } \Phi_{V_1,H}(\Gamma_1) + q + C \ssize{H}{V_1} - \ssize{H_1}{v_1} \ge \Phi_{H_1}(v_1 : (\cf{A} - 1)) + p + C\\
  &\quad \Phi_{V_1,H}(\Gamma_1) \ge \Phi_{H_1}(v_1 : (\cf{A} - 1)) \tag{lemma about cf typing}\\
  &\quad \text{STS } \ssize{H}{V_1} - \ssize{H_1}{v_1} + q \ge p \tag{done by aux lemma}\\
  &\text{Instantiating existence clause on the second premise} , \text{ we get } F^{(3)} \text{ s.t. }\\
  &\quad 1. V_2',H_1,R, F'' \cup g \vdash e_2 \Downarrow v_2,H_2,F^{(3)} \\
  &\quad 2. |F^{(3)}| \ge \Phi_{H_2}(v_2:B) + q' + C\\
  &\text{Take } F' = F^{(3)}\\
  &V,H,R,F \vdash e \Downarrow v_2, H_2,F' \text{ and } \tag{E:Let}\\ 
  &|F'| \ge \Phi_{H_2}(v_2:B) + q' + C \tag{from IH}\\
		\fi
  \end{align*}
	\item[Case 8: E:Pair]
  Similar to E:Const*
  \item[Case 9: E:MatP]
  Similar to E:MatCons
  \item[Case 10: E:Nil]
  Similar to E:Const*
  \item[Case 11: E:Cons]
  \begin{align*}
		&V_o,H_o \vdash \consexabt{x_1}{x_2} \Downarrow l_o, H_o' \tag{case}\\
		&H_o'(l_o) = \pairexcst{V_o(x_1)}{V_o(x_2)} \tag{admissibility}\\
  	&\Sigma; x_1 : A, x_2 : L^p(A) \sststile{q}{q+p+1} \consexcst{x_1}{x_2} : L^p(A)\\
		&\text{Let } C \in \mathbb{Q}^+, \text{well-formed configuration } V,H,R,F \text{ s.t. }\\
		&\quad V_o,H_o \sim V,H
			\text{ and }|F| \ge \Phi_{V,H}(x_1:A,x_2 : L^p(A)) + (q + p + 1) + C\\
		&\text{Let } v = \pairexcst{V(x_1)}{V(x_2)}
		,l \in F, H' = H\{l \mapsto v\}, F' = F\setminus\{l\}\\
		&\emph{(1) } V,H,R,F \vdash \consexabt{x_1}{x_2} \Downarrow l, H',F' \tag{E:Cons}\\ 
		&\emph{(2) } \veq{H_o'}{H'}{l_o}{l} \tag{assumption}\\
		&\emph{(3 } |F'| \ge \Phi_{H'}(l : L^p(A)) + q + C \\
		&\quad |F| \ge \Phi_{V,H}(x_1:A,x_2:L^p(A)) + (p + q + 1) + C\\
		&\quad = \Phi_{H'}(l : L^p(A)) + q + 1 + C\\
		&\quad |F'| = |F| - 1 \ge \Phi_{H'}(l : L^p(A)) + q + C\\
  \end{align*}
  \item[Case 12: E:MatNil]
  Similar to E:Cond*
  \item[Case 13: E:MatCons]
  \begin{align*}
  &V_o(x) = l_o \tag{ad.}\\
  &H_o(l_o) = \pairexcst{v_o'}{v_o''} \tag{ad.}\\
  &\Gamma = \Gamma', x : L^p(A) \tag{ad.}\\
  &\Sigma; \Gamma', x_h : A, x_t : L^p(A) \sststile{q'}{q + p + 1} e_2 : B \tag{ad.}\\
	&V_o' = (V_o[x_h \mapsto v_o', x_t \mapsto v_o''])\restriction_{FV(e_2)}\tag{ad.}\\
  &V_o',H_o \; \vdash e_2 \Downarrow v_o, H' \tag{ad.}\\
  &H \vDash V(x) : L^p(A) \tag{def of $\vDash$ }\\
  &H\vDash v_h : A,\; H \vDash v_t : L^p(A) \tag{Inversion on $\vDash$}\\
  &H \vDash V_o' : \Gamma', x_h : A, x_t : L^p(A) \tag{def of W.D.E}\\
&\text{Let } C \in \mathbb{Q}^+, \text{well-formed configuration } V,H,R,F \text{ s.t. }
		V_o,H_o \sim V,H
			\text{ and }|F| \ge \Phi_{V,H}(\Gamma) + q + C\\
  &\text{NTF } v,H',F' \text{ s.t. }\\
  &\quad 1. V,H,R,F \vdash e \Downarrow v, H',F' \text{ and }\\ 
	&\quad 2. \veq{H_o'}{H'}{v_o}{v}\\
  &\quad 2. |F'| \ge \Phi_{H'}(v:B) + q' + C\\
	&\text{Let } V(x) =  l\\
		&H(l) = \pairexcst{v_h}{v_t} \tag{$\veq{H_o}{H}{l_o}{l}$ by assumption}\\
	&\text{Let } V' = (V[x_h \mapsto v_h, x_t \mapsto v_t])\restriction_{FV(e_2)}\\
	&\text{Let } g = \{l \in H \mid l \notin F \cup R \cup locs_{V',H}(e_2)\}\\
  &\text{NTS $g$ nonempty, in particular, that } l \in g\\
	&\quad l \notin F \cup R \tag{$l \in locs_{V,H}(e)$ and $\dist{\{R,F,locs_{V,H}(e)\}}$}\\
  &\quad \text{AFSOC } l \in locs_{V',H}(e_2)\\
		&\quad \text{Then } l \in reach_H(V'(x')) \text{ for some } x' \in dom(V')\\
		&\textbf{case }x' \in \{x_h,x_t\}:\\
  &\quad \text{WLOG let } x' = x_h\\
		&\quad \text{But then } reach_H(V(x))(l) \ge 2 \text{ and } \ms{set}(reach_(\overline V(x))) \text{ doesn't hold}\\
		&\textbf{case } x' \notin \{x_h,x_t\}:\\
		&\quad x' \in dom(V)\\
		&\quad x = x' \tag{$l \in reach_H(V(x))$ and $\na{V,H}$}\\
		&\text{Contradiction, } x \notin domv(V')\\
  &\quad l \notin locs_{V'',H}(e_2)\\
  &\text{Hence } l \in g\\
	&\text{By IH with } C' = C, V = V', H = H, R = R, F_1 = F \cup g 
		\text{ we have the existence clause. NTS the following: } \\
	&\emph{(1) } V_o',H_o \sim V',H \tag{assumption} \\
	&\emph{(2) - (4) } \text{Same as Lemma~\ref{itm:na}}\\
		&\emph{(5) } |F_1| \ge \Phi_{V',H}(\Gamma',x_h:A,x_t:L^p(A)) + q + p + 1 + C:\\
	&\quad |F_1| = |F \cup g|\\
	&\quad = |F| + |g| \tag{$F$ and $g$ disjoint}\\
	&\quad \ge \Phi_{V,H}(\Gamma) + q + C + |g| \tag{assumption}\\
		&\quad = \Phi_{V,H}(\Gamma',x_h:A,x_t:L^p(A)) + q+ p + C + |g| \tag{definition of $\Phi$}\\
	&\quad = \Phi_{V,H}(\Gamma',x_h:A,x_t:L^p(A)) + q + p + 1 + C \tag{$g$ nonempty}\\
		&\quad\text{By existence clause have } v,H',F' \text{ s.t. }\\
		&\quad \text{Fact 1 }. V',H,R,F\cup g \vdash e_2 \Downarrow v,H',F'\\
		&\quad \text{Fact 2 }. |F'| \ge \Phi_{H'}(v:B) + q' + C\\
	&\text{Apply E:MatCons and we're done}
  \end{align*}
  \item[Case 14: E:Share]
	\begin{align*}
	&V_o,H_o \vdash \sharecpcst{x}{x_1}{x_2}{e'}  \Downarrow v_o,H_o' \tag{case}\\
	&V_o(x) = v_o' \tag{ad.}\\
	&V_o' = (V_o[x_1 \mapsto v_o',x_2 \mapsto v_o']) \restriction_{FV(e')}\\
	&V_o', H_o \vdash e' \Downarrow v_o,H_o' \tag{ad}\\
	&\Sigma;\Gamma,x:A \sststile{q'}{q} \sharecpcst{x}{x_1}{x_2}{e'}: B \tag{case}\\
	&A \curlyvee A_1,A_2,1 \tag{ad.}\\
	&\Sigma; \Gamma,x_1:A_1,x_2:A_2 \sststile{q'}{q} e' : B \tag{ad.}\\
&\text{Let } C \in \mathbb{Q}^+, \text{well-formed configuration } V,H,R,F \text{ s.t. }
		V_o,H_o \sim V,H
			\text{ and }|F| \ge \Phi_{V,H}(\Gamma,x:A) + q + C\\
  &\text{NTF } v,H'',F'' \text{ s.t. }\\
	&\quad 1. V,H,R,F \vdash e \Downarrow v, H'',F'' \text{ and }\\ 
		&\quad 2. \veq{H_o'}{H''}{v_o}{v}\\
  &\quad 3. |F''| \ge \Phi_{H''}(v:B) + q' + C\\
		&\text{Let } V(x) = v',
  L \subseteq F,
  |L| = |dom(reach_H(v'))|,
  H',v'' = copy(H,L,v'),
	V' = (V[x_1 \mapsto v',x_2 \mapsto v'']) \restriction_{FV(e)}\\
		&\quad F' =	F \setminus L,
		g = \{l \in H \mid l \notin F' \cup R \cup locs_{V',H'}(e)\}\\
		&\text{By IH with } C, V',H',R,F'\cup g \text{, have the existence clause. NTS the following: }\\
		&\emph{(1) } V_o',H_o \sim V',H' \tag{By Lemma~\ref{itm:copyStable} and assumption}\\
		&\emph{(2) - (4) } \text{ same as lemma~\ref{itm:na}}\\ 
		&\emph{(5) } |F' \cup g| \ge \Phi_{V',H'}(\Gamma,x_1 : A_1,x_2 : A_2) + q + C\\
		&\text{STS } |(F\setminus L) \cup g| \ge \Phi_{V', H'}(\Gamma,x_1 : A_1,x_2 : A_2) + q + C\\
		&\quad \iff (|F| - |L|) + |g| \ge \Phi_{V',H'}(\Gamma) + 
			\Phi_{V',H'}(x_1 : A_1) + \Phi_{V',H'}(x_2 : A_2) + q + C\\
		&\quad \text{STS } |F| \ge \Phi_{V',H'}(\Gamma) + 
			\Phi_{V',H'}(x_1 : A_1) + \Phi_{V',H'}(x_2 : A_2) + |L| + q + C\\
	&\quad \iff |F| \ge \Phi_{V',H'}(\Gamma) + 
			\Phi_{V,H}(x : A) + q + C \tag{By Lemma~\ref{itm:shareSize}}\\
		&\quad \iff |F| \ge \Phi_{V,H}(\Gamma,x:A) + q + C \tag{By Lemma~\ref{itm:copyStable}}\\
		&\text{Instantiate the existence clause and apply E:Share, and we're done}
	\end{align*}
  \end{description}
\end{proof}

\section{\copySem{} over-approximates \gcSem{}}

\begin{definition} A configuration $(V,H,R,F)$ is well-formed if 
	\begin{enumerate}
		\item $dom(H) \subseteq reach_H(V) \cup R \cup F$
		\item $reach_H(V) \cup R \subseteq dom(H) \setminus F$
		\item $collect(R,reach_H(V),H,F) = \emptyset$
	\end{enumerate}
\end{definition}

For a context $(V,H,R,F)$, denote the
garbage w.r.t a set of locations $L$ 
as $collect(R,L,H',F') = \{l \in H' \mid l \notin F' \cup R \cup L\}$.
\begin{lemma}\label{itm:eager}
	Given a well-formed context $(V,H,R,F)$ and $V,H,R,F \vdash e \Downarrow v,H',F'$, 
	$dom(H') \subseteq reach_H(v) \cup R \cup F'$,
	$reach_H(v) \cup R \subseteq dom(H') \setminus F'$ and
	$collect(R,reach_H'(v),H',F') = \emptyset$.
\end{lemma}

Now consider two well-formed configurations $\mathcal{C}_1 = (V_1,H_1,R_1,F_1),
 \mathcal{C}_2 = (V_2,H_2,R_2,F_2)$.\\

A mapping $f : A \to \mathcal{P}(B)$ is a \emph{partition} on $B$ the image of 
$A$ forms a disjoint union of $B$ 
(e.g. $\forall x,y \in A, f(x) \cap f(y) = \emptyset \land \bigcup f(A) = B$). Furthermore,
a partition is \emph{proper} if for any $x \in A$, $f(x) \neq \emptyset$.\\
Given a proper partition $f$, we can choose an arbitrary 
$b \in f(a)$ to be the representation for that part; call this 
singlet set $\{b\}$ $rep(a)$.\\

A simple corollary is the fact that if $V_2,H_2$ is a linear context (e.g. $\na{V_2,H_2}$ holds), then
$|\gamma(l)| = |(reach_{H_1}(V_1))(l)|$, where $ reach_{H_1}(V_1) = \biguplus_{x \in dom(V)} reach_{H_1}(x)$. 
In general for a multiset $S$, when this holds, we say that 
$\gamma$ is a \emph{counting partition} for $S$.\\

For a partition $f : A \to \mathcal{P}(B)$, we write the set of equivalence classes
as $ec(f) = \{f(x) \mid x \in A\} = f(A)$, i.e. the image of $f$ on its domain $A$.\\

\begin{definition}
	Let \ms{dir} be the set \{\ms{L},\ms{R},\ms{N}\}, denoting left, right, and next 
	respectively. We can index values via directions:
	\begin{align*}
		get_H(Just(\pairexcst{v_1}{v_2},\ms{L})) &= Just(v_1)\\
		get_H(Just(\pairexcst{v_1}{v_2},\ms{R})) &= Just(v_2)\\
		get_H(Just(\pairexcst{v_1}{v_2}),_) &= None\\
		get_H(Just(l),\ms{N}) &= Just(H(l)) \\
		get_H(Just(l), \_) &= None\\
		get_H(r,\_) &= r
	\end{align*}
	Let $P$ be a sequence of directions. Extend $get$ to sequence of directions:
	\begin{align*}
		find_H(v,D::P) &= find_H(get_H(v,D),P)\\
		find_H(v,[]) &= v
	\end{align*}
	Call $P$ valid w.r.t a value $v$ if $find_H(v,P) = Just (v')$ for some $v'$.
	Write $V_H(x;P)$ for $fromJust(find_H(V(x),P))$ given a valid sequence $P$ w.r.t $V(x)$,
	and $reach_H(V(x;P))$ for $reach_H(V_H(x;P))$.
	Given a map $m : X \to \mathcal{S}(\ms{dir})$ from varibles to valid sequences of directions, 
	Define $reachPath_{V,H}(X,m) = \biguplus_{x \in X} reach_H(V(x;m(x)))$.
	
\end{definition}

\begin{lemma}
	Let $V_1,H_1 \sim V_2,H_2$. Then for all $x \in dom(V_1)$ and sequence of directions $P$, 
	Either $find_{H_1}(V_1(x),P) = find_{H_2}(V_2(x),P) = None$ or 
	$find_{H_1}(V_1(x),P) = v_1$, $find_{H_2}(V_2(x),P) = v_2$ and
	$\veq{H_1}{H_2}{v_1}{v_2}$
\end{lemma}

\begin{proof}
	Induction on length of $P$ and then $H \vdash v \mapsto a : A$.
\end{proof}

\begin{definition}
A configuration $\mathcal{C}_2 = (V_2,H_2,R_2,F_2)$ is a \emph{copy extension} of another configuration
$\mathcal{C}_1 = (V_1,H_1,R_1,F_1)$ iff
\begin{enumerate}
\item $V_1,H_1 \sim V_2,H_2$
\item There is a proper partition $\gamma : dom(H_1) \setminus F_1 \to \mathcal{P}(dom(H_2) \setminus F_2)$ 
such that for all $l \in dom(\gamma)$, $|\gamma(l)| = reach_{H_1}(V_1)(l) + R_1(l)$
\item for all $l \in dom(\gamma)$, $x \in dom(V_1)$, valid sequence of directions $P$ w.r.t $V_1(x)$,
	$|reach_{H_2}(V_2(x;P)) \cap \gamma(l)| = reach_{H_1}(V_1(x;P))(l)$.
\item for all $l \in dom(\gamma)$, $|\gamma(l) \cap R_2| = R_1(l)$
\item $|F_1| = |F_2| + |\oh{\gamma}|$, where 
	$\oh{\gamma} = \bigcup_{P \in ec(\gamma)} C \setminus rep(C)$
\end{enumerate}
Write this as $\mathcal{C}_1 \preceq \mathcal{C}_2$.
\end{definition} 

Note that $\preceq$ is reflexive. Now the key lemma:

\begin{lemma}
	Let $(\mathcal{C}_2,e)$ be a linear computation. Given that 
	$\mathcal{C}_2 \vdash^{\mathsf{copy}} e \Downarrow v,H',F'$, 
	for all well-formed configurations $\mathcal{C}_1$ such that $\mathcal{C}_1 \preceq \mathcal{C}_2$,
there is exists a triple
$(w,Y',M') \in \ms{Val} \times \ms{Heap} \times \ms{Loc}$ and 
	$\gamma' : dom(Y') \setminus M' \to \mathcal{P}(dom(H') \setminus F')$ s.t.
	\begin{enumerate}
			\item $\mathcal{C}_1 \vdash^{\mathsf{free}} e \Downarrow w,Y',M'$
			\item $\veq{H'}{Y'}{v}{w}$
			\item $\gamma'$ is a proper partition, such that for all $l \in dom(\gamma')$, 
				$|\gamma'(l)| = reach_{Y_1}(w_1)(l) + S(l)$
			\item For all $P$ valid w.r.t $v$, $|reach_{H'}(find_{H'}(v;P)) \cap \gamma'(l)| = 
				reach_{Y'}(find_{Y'}(w;P))(l)$
			\item $l \in dom(\gamma')$, 
					$\gamma'(l) \cap R = \gamma(l) \cap R$ 
			\item $|M'| = |F'| + |\oh{\gamma'}|$
	\end{enumerate}
\end{lemma}

\begin{lemma}
Let $V_2,H_2,R_2,F_2 \vdash^{\mathsf{copy}} e \Downarrow v,H',F'$, and 
$V_1,H_1,R_1,F_1 \preceq V_2,H_2,R_2,F_2$ because $(-,\gamma,\eta,-,-)$. Then the following hold:
for all $l \in dom(H_1) \setminus F_1$, 
	$X \subseteq dom(V)$, $m : X \to \mathcal{S}(\ms{dir})$, $l \in dom(\gamma)$,
	$\gamma(l) \subseteq collect(R_2,\mathcal{C}_2,reachPath_{V_2,H_2}(X,m),H_2,F_2)$ iff
	$l \in collect(R_1,reachPath_{V_1,H_1}(X,m),H_1,F_1)$.
\end{lemma}

\begin{proof}
	$\implies$
	\begin{align*}
		&\gamma(l) \cap (F_2 \cup R_2 \cup reachPath_{V_2,H_2}(X,m)) = 
			\emptyset \tag{definition of $clean$}\\
		&\text{NTS } l \notin F_1 \cup R_1 \cup reach_{H_1}(X)\\
		&\emph{(1) } l \notin F_1 \tag{assumption}\\
		&\emph{(2) } l \notin R_1\\
		&\quad \text{Know } \gamma(l) \cap R_2 = \emptyset\\
		&\quad |\gamma(l) \cap R_2| = R_1(l) = 0 \tag{condition 4. of $\preceq$}\\
		&\quad l \notin R_1\\
		&\emph{(3) } l \notin reachPath_{V_1,H_1}(X,m)\\
		&\quad \text{Know } \gamma(l) \cap reachPath_{V_2,H_2}(X,m) = \emptyset\\
		&\quad \text{Let } x \in X\\
		&\quad \gamma(l) \cap reach_{H_2}(V_2(x;m(x))) = \emptyset\\
		&\quad |\gamma(l) \cap reach_{H_2}(V_2(x;m(x)))| = reach_{H_1}(V_1(x;m(x)))(l) 
			\tag{condition 3. of $\preceq$}\\
		&\quad reach_{H_1}(V_1(x;m(x)))(l) = 0\\
		&\quad reachPath_{V_1,H_1}(X,m)(l) = 0\\
		&\quad l \notin reachPath_{V_1,H_1}(X,m)\\
		&\quad \text{Thus, } l \in collect(R_1,reachPath_{V_1,H_1}(X,m),H_1,F_1)
	\end{align*}
	$\Longleftarrow$
	\begin{align*}
		&l \notin (F_1 \cup R_1 \cup reachPath_{V_1,H_1}(X,m))\\
		&\text{NTS } \gamma(l) \cap (F_2 \cup R_2 \cup reachPath_{V_2,H_2}(X,m)) = \emptyset\\
		&\emph{(1) } \gamma(l) \cap F_2 = \emptyset \tag{assumption}\\
		&\emph{(2) } \gamma(l) \cap R_2 = \emptyset\\
		&\quad |\gamma(l) \cap R_2| = R_1(l) \tag{condition 4. of $\preceq$}\\ 
		&\quad = 0 \tag{assumption}\\
		&\quad \gamma(l) \cap R_2 = \emptyset\\
		&\emph{(3) } \gamma(l) \cap reachPath_{V_2,H_2}(X,m) = \emptyset\\
		&\quad \text{Let } x \in X\\
		&\quad |\gamma(l) \cap reach_{H_2}(V_2(x;m(x)))| = reach_{H_1}(V_1(x;m(x)))(l) 
			\tag{condition 3. of $\preceq$}\\
		&\quad = 0 \tag{assumption}\\
		&\quad\gamma(l) \cap reach_{H_2}(V_2(x;m(x))) = \emptyset\\
		&\quad\gamma(l) \cap reachPath_{V_2,H_2}(X,m) = \emptyset\\
		&\quad\gamma(l) \cap (F_2 \cup R_2 \cup reachPath_{V_2,H_2}(X,m)) = \emptyset\\
		&\quad\gamma(l) \in collect(R_2,reachPath_{V_2,H_2}(X,m),H_2,F_2)
	\end{align*}
\end{proof}

\begin{lemma}\label{itm:copyRel}
	Given  a proper partition $\gamma : dom(Y) \setminus M \to \mathcal{P}(dom(H)\setminus F)$, 
	equivalent values $\veq{H}{Y}{v}{w}$, and the 
	following:
	\begin{enumerate}
		\item $L \subseteq F$
		\item $|L| = |dom(reach_H(v))|$
		\item $H',v' = copy(H,L,v)$
		\item $F' =	F \setminus L$
	\end{enumerate}
	there is a proper partition $\gamma' : dom(Y) \setminus M \to \mathcal{P}(dom(H) \setminus F')$ 
	s.t.
	$|\gamma'(l)| = |\gamma(l)| + reach_Y(w)(l)$, 
	$|reach_H(v) \cap \gamma'(l)| = |reach_H(v') \cap \gamma'(l)| = |reach_H(v) \cap \gamma(l)|$.
\end{lemma}

\begin{proof}
	Induction on $copy$.
\end{proof}

Now the proving \copySem{} over approximates \gcSem{}:
\begin{proof}
Induction on the evaluation judgement.\\
\begin{description}
  \item[Case 1: E:Var] Trivial
  \item[Case 2: E:Const*] Trivival
  \item[Case 4: E:App] Similar to E:CondT
  \item[Case 5: E:CondT]
  \begin{align*}
		&V,H,R,F \; \vdash^{\copySem} \ifexabt{x}{e_1}{e_2} \Downarrow v, H',F' \tag{case}\\
		&\text{Let } W,Y,S,M \preceq V,H,R,F \\
		&\text{Let } W' = W \restriction_{dom(V')}\\
		&\text{Let } j = \{l \in Y | l \notin M \cup S \cup locs_{W,Y}(e_1) \}\\
		&\text{NTS } W',Y,S,M \cup j \preceq V',H,R,F \cup g\\
		&\emph{(1)}\quad W',Y \sim V',H \tag{$W,Y \sim V,H$}\\
		&\emph{(2)}\quad \text{NTF a proper partition }
		 \gamma' : dom(Y) \setminus (M \sqcup j) \to \mathcal{P}(dom(H)\setminus (F \cup g))  \\
		&\quad \text{Let } \gamma'(l) = \gamma \restriction_{dom(Y)\setminus(M \sqcup j)}(l) \setminus g\\
		&\quad \text{First, show $\gamma'$ is a partition}\\
		&\quad \text{Let } l, l' \in dom(Y) \setminus (M \sqcup j)\\
		&\quad \gamma'(l) \cap \gamma'(l') = \emptyset \tag{$\gamma$ is partition}\\
		&\quad \gamma'(dom(Y) \setminus (M \sqcup j)) = \gamma(dom(Y) \setminus (M \sqcup j)) \setminus g\\
		&\quad = (\bigsqcup_{l \in dom(Y) \setminus M} \gamma(l) \setminus \bigsqcup_{l \in j} \gamma(l)) 
			\setminus g\\
		&\quad = ((dom(H) \setminus F) \setminus (\bigsqcup_{l \in j} \gamma(l))) \setminus g 
			\tag{$\gamma$ is partition}\\
		&\quad = (dom(H) \setminus F) \setminus g 
			\tag{$\bigsqcup_{l \in j} \gamma(l) \subseteq g$ by lemma \ref{itm:aux}}\\
		&\quad = dom(H) \setminus (F \sqcup g)\\
		&\quad \text{Hence } \gamma' \text{ is a partition}\\
		&\quad \gamma' \text{ is also proper: }\\
		&\quad \text{Let } l \in dom(Y) \setminus (M \sqcup j)\\
		&\quad \gamma'(l) = \gamma(l) \setminus g\\
		&\quad \text{AFSOC } \gamma(l) \subseteq g\\ 
		&\quad l \in j \tag{By Lemma \ref{itm:aux}}\\
		&\quad \text{Contradiction since assumed } l \notin j\\ 
		&\quad \text{Now, NTS } |\gamma'(l)| = reach_{Y}(W')(l) + S(l)\\
		&\quad \text{Let } l \in dom(\gamma')\\
		&\quad \gamma'(l) = \gamma(l) \setminus g \tag{definition}\\ 
		&\quad |\gamma'(l)| = |\gamma(l)| - |\gamma(l) \cap g|\\
		&\quad = reach_Y(W)(l) + S(l) - |\gamma(l) \cap g|\\
		&\quad g = reach_H(V\restriction_{dom(V) \setminus FV(e_1)})\\
		&\quad |\gamma(l) \cap g| = reach_Y(W\restriction_{dom(W)\setminus FV(e_1)})(l) 
			\tag{condition 3. of $\preceq$}\\
		&\quad \text{Thus, } |\gamma'(l)| = 
			reach_Y(W)(l) + S(l) - reach_Y(W\restriction_{dom(W)\setminus FV(e_1)})(l)\\
		&\quad = reach_Y(W\restriction_{FV(e_1)})(l) +  S(l)\\
		&\quad = reach_Y(W')(l) +  S(l)\\
		&\emph{(3)}\quad \text{Let $l \in dom(\gamma'), x \in dom(W')$, 
			$P$ valid sequence w.r.t $W'(x)$. NTS }\\ 
		&|reach_{H}(V'(x;P)) \cap \gamma'(l)| = reach_{Y}(W'(x;P))(l)\\ 
		&\quad \text{STS } |reach_{H}(V'(x;P)) \cap (\gamma(l) \setminus g)| = reach_{Y}(W'(x;P))(l) \\
		&\quad g \cap reach_H(V'(x;P)) = \emptyset \tag{definition of $g$}\\
		&\quad |reach_{H}(V'(x;P)) \cap (\gamma(l) \setminus g)| = 
				|(reach_{H}(V'(x;P)) \setminus g) \cap \gamma(l)|\\
		&\quad = |reach_{H}(V'(x;P)) \cap \gamma(l)|\\
		&\quad = |reach_{H}(V(x;P)) \cap \gamma(l)|\\
		&\quad = reach_{Y}(W(x;P))(l) \tag{condition 3. of $\preceq$}\\
		&\quad = reach_{Y}(W'(x;P))(l) \\
		&\emph{(4)}\quad S \subseteq dom(Y) \setminus (M \cup j) \text{ since } S \cap j = \emptyset\\
		&\quad \text{Let } l \in S \text{. NTS } |\gamma'(l) \cap R| = S(l)\\
		&\quad \text{STS } |(\gamma(l)\setminus g) \cap R| = S(l)\\
		&\quad (\gamma(l)\setminus g) \cap R = \gamma(l) \cap (R \setminus g)\\
		&\quad = \gamma(l) \cap R \tag{$g \cap R = \emptyset$}\\
		&\quad |\gamma(l) \cap R| = S(l) \tag{condition 4. of $\preceq$}\\
		&\emph{(5)}\quad \text{NTS } |M \cup j| = |F \cup g| + |\oh{\gamma'}|\\
		&\quad \text{STS } |M| + |j| = |F| + | g| + |\oh{\gamma'}|\\
		&\quad \text{By assumption }, |M| = |F| + |\oh{\gamma}|\\
		&\quad \text{STS } |j| + |\oh{\gamma}| = |g| + |\oh{\gamma'}|\\
		&\quad \text{NTF a bijection } f : j \oplus \oh{\gamma} \to g \sqcup \oh{\gamma'}\\
		&\quad \text{First, we know that } g = (\bigsqcup_{l \in j} \gamma(l)) \sqcup L 
			\text{ for some } L \tag{By \ref{itm:aux}}\\
		&\quad \text{Let } \mathcal{C}_1 = \{\gamma(l) \mid l \in j\},
				\mathcal{C}_2 = ec(\gamma) \setminus \mathcal{C}_1\\
		&\quad \text{Clearly, } \oh{\gamma} = 
		\bigsqcup_{C  \in \mathcal{C}_1} C \setminus rep(C) \sqcup \bigsqcup_{C  \in \mathcal{C}_2} C \setminus rep(C)\\
		&\quad \text{Let } D_1 = \bigsqcup_{C  \in \mathcal{C}_1} C \setminus rep(C), 
		D_2 = \bigsqcup_{C  \in \mathcal{C}_2} C \setminus rep(C)\\
		&\quad \text{We define the bijection } 
			f \text{ by parts: } 
			f_1 : j \oplus D_1 \to \bigsqcup_{C \in \mathcal{C}_2} C, f_2 : D_2 \to L \sqcup \oh{\gamma'}\\
		&\quad f_1(x) =  
		\begin{cases}
			rep(\gamma(l)) &x = (\ms{inl},l)\\
			l &x = (\ms{inr},l)
		\end{cases}\\
		&\quad \text{Clearly, } f_1 \text{ is a bijection, and } |j| + |D_1| = |\bigsqcup_{C \in \mathcal{C}_1} C|\\
		&\quad \text{To avoid the problem of maintaining a single representative for a class (which might be 
		collected), }\\
		&\quad \text{note the following: }\\
		&\quad |\mathcal{C}_2| = |ec(\gamma) \setminus \{\gamma(l) \mid l \in j\}|\\
		&\quad = |ec(\gamma \restriction_{dom(Y) \setminus (M \sqcup j)})|\\
		&\quad = |ec(\gamma')|\\
		&\text{Meaning that } \mathcal{C}_2 \text{ has the same number of classes as } \gamma' 
			\text{(note these classes might be different)}\\
		&\text{Since both } \gamma,\gamma' \text{ are proper partitions we have the following: }\\
		&|D_2| = |L \sqcup \oh{\gamma'}| \text{ iff } 
			|\bigsqcup_{C  \in \mathcal{C}_2} C \setminus rep(C)| =
			|L \sqcup \bigsqcup_{C \in ec(\gamma')} C \setminus rep(C)|
			\text{ iff }
		|\bigsqcup_{C  \in \mathcal{C}_2} C| = |L \sqcup \bigsqcup_{C \in ec(\gamma')} C|\\ 
		&\quad \text{In fact, the latter two sets are equal: }\\
		&\quad \text{let } l' \in \bigsqcup_{C  \in \mathcal{C}_2} C\\
		&\quad l' \in H \setminus F \tag{Def. of partition}\\
		&\quad \textbf{case } l \in g\\
		&\quad\quad l' \notin \bigsqcup_{l \in j} \gamma(l) \tag{Def. of $\mathcal{C}_2$}\\
		&\quad\quad l' \in L \tag{Def. of $g$}\\
		&\quad\quad l' \in L \sqcup \bigsqcup_{C \in ec(\gamma')} C\\
		&\quad \textbf{case } l' \notin g\\
		&\quad\quad l' \in H \setminus (F \sqcup g)\\
		&\quad\quad \text{Exists } C \in ec(\gamma') \text{ s.t. } l' \in C \tag{Def. of partition}\\
		&\quad\quad l' \in \bigsqcup_{C \in ec(\gamma')} C\\
		&\quad\quad l' \in L \sqcup \bigsqcup_{C \in ec(\gamma')} C\\
		&\quad\text{For the other direction, let } l' \in L \sqcup \bigsqcup_{C \in ec(\gamma')} C\\
		&\quad\textbf{case } l' \in L\\
		&\quad\quad l' \in H \setminus F \tag{Def. of $L$}\\
		&\quad\quad \text{Exists } C \in ec(\gamma) \text{ s.t. } l' \in C \tag{Def. of partition}\\
		&\quad\quad l' \in \bigsqcup_{C \in ec(\gamma)} C\\
		&\quad\textbf{case } l' \in \bigsqcup_{C \in ec(\gamma')} C\\
		&\quad\quad l' \in H \setminus (F \sqcup g) \tag{Def. of partition}\\
		&\quad\quad l' \in H \setminus F \\
		&\quad\quad \text{Exists } C \in ec(\gamma) \text{ s.t. } l' \in C \tag{Def. of partition}\\
		&\quad\quad l' \in \bigsqcup_{C \in ec(\gamma)} C\\
		&\quad\text{Hence we show that } |D_2| = |L \sqcup \oh{\gamma'}|, \text{ and together with the previous 
		equality, } |j| + |\oh{\gamma}| = |g| + |\oh{\gamma'}|\\
		&\text{Thus we have } W',Y,S,F \cup j \preceq V',H,R,F \cup g\\
  	&V',H,R,F \cup g\; \vdash^{\mathsf{copy}} e_1 \Downarrow v, H',F' \tag{case}\\
		&\text{By IH on $(V',H,R,F\cup g)$, we have } (w,Y',M',\gamma'') \text{ such that }\\
		&\emph{(1)}\quad  W',Y,S,M \cup j  \vdash^{\gcSem} e_1 \Downarrow w,Y',M'\\
		&\emph{(2)}\quad \veq{H'}{Y'}{v}{w}\\
		&\emph{(3)}\quad \gamma' \text{ is a proper partition, and } |\gamma''(l)| = 
			reach_{Y'}(w)(l) + R(l)\\
		&\emph{(4)}\quad \gamma''(l) \cap R = \gamma'(l) \cap R \\
		&\quad \gamma'(l) \cap R = (\gamma(l) \setminus g) \cap R= \gamma(l) \cap R\\
		&\emph{(5)}\quad |M'| = |F'| + |\oh{\gamma''}|\\
		&\text{Apply F:CondT to \emph{(1)}, we are done.}
  \end{align*}
  \item[Case 6: E:CondF] 
  Similar to E:CondT
  \item[Case 7: E:Let]
  \begin{align*}
		&V,H,R,F \; \vdash^{\copySem} \irl{let}(e_1; x : \tau.e_2) \Downarrow v_2,H_2,F_2 \tag{case}\\
		&W,Y,S,M \preceq V,H,R,F \tag{assumption}\\
		&V_1,H,R',F \vdash^{\copySem} e_1 \Downarrow v_1,H_1,F_1 \tag{admissibility}\\
		&\text{Let } W_1 = W \restriction_{FV(e_1)}, S' = S \uplus locs_{W,Y}(\irl{lam}(x : \tau.e_2))\\
		&\text{NTS } W_1,Y,S',M \preceq V_1,H,R',F\\
		&\emph{(1)}\quad W_1,Y \sim V_1,H \tag{condition 1. of $\preceq$}\\
		&\emph{(2)a.}\quad \gamma \text{ is a proper partition } \tag{condition 2. of $\preceq$}\\
		&\emph{(2).b}\quad \text{NTS } |\gamma(l)| = reach_Y(W')(l) + S'(l)\\
		&\quad |\gamma(l)| = reach_Y(W)(l) + S(l) \tag{condition 2. of $\preceq$}\\
		&\quad = reach_Y(W')(l) + reach_Y(W\restriction_{FV(e_2)\setminus \{x\}})(l) + S(l)\\
		&\quad = reach_Y(W')(l) + S'(l)\\
		&\emph{(3)}\quad \text{Let. } l \in dom(\gamma), x \in dom(W'), P \text{ valid sequence of 
		directions. Have }\\
		&\quad |reach_H(V'(x;P)) \cap \gamma(l) = reach_Y(W'(x;P))(l) 
			\tag{condition 3. of $\preceq$}\\
		&\emph{(4).a}\quad \text{NTS } S' \subseteq dom(Y)\setminus M\\
		&\quad S \subseteq dom(Y)\setminus M \tag{condition 4. of $\preceq$}\\
		&\quad locs_{W,Y}(\irl{lam}(x : \tau.e_2)) \subseteq reach_Y(W) \subseteq dom(Y) \setminus M
			\tag{well-formed configuration}\\
		&\quad S' \subseteq dom(Y)\setminus M\\ 
		&\emph{(4).b}\quad \text{Let } l \in S'. \text{ NTS } |\gamma(l) \cap R'| = S'(l)\\
		&\quad \text{STS }  |\gamma(l) \cap (R \cup reach_H(FV(e_2) \setminus \{x\})| = S(l) + 
			reach_Y(FV(e_2) \setminus \{x\})(l)\\
		&\quad \text{STS } |(\gamma(l) \cap R) \cup (\gamma(l) \cap 
			reach_H(V(FV(e_2) \setminus \{x\})))| 
			= S(l) + reach_Y(W(FV(e_2) \setminus \{x\}))(l)\\
		&\quad \text{STS } |(\gamma(l) \cap R)| + |\gamma(l) \cap reach_H(V(FV(e_2) \setminus \{x\}))| 
			= S(l) + reach_Y(W(FV(e_2) \setminus \{x\}))(l) 
			\tag{$R \cap reach_H(V(FV(e_2) \setminus \{x\})) = \emptyset$}\\
		&\quad \text{STS } |\gamma(l) \cap reach_H(V(FV(e_2) \setminus \{x\}))| 
			= reach_Y(W(FV(e_2) \setminus \{x\}))(l) \tag{condition 4. of $\preceq$}\\
		&\quad \text{STS } |\gamma(l) \cap \bigcup_{x' \in FV(e_2) \setminus \{x\}} reach_H(V(x'))|
			= (\biguplus_{x' \in FV(e_2) \setminus \{x\}} reach_Y(W(x')))(l)\\
		&\quad \text{Let } x' \in FV(e_2) \setminus \{x\}\\
		&\quad |\gamma(l) \cap reach_H(V(x'))| = reach_Y(W(x'))(l) \tag{condition 3. of $\preceq$}\\
		&\emph{(5)}\quad \text{Have } |M| = |F| + |\oh{\gamma}| \tag{condition 5. of $\preceq$}\\
		&\text{By IH on first premise, there is } (w_1,Y_1,M_1) \text{ and } \gamma_1 \text{ s.t. }\\
		&\text{Fact 1}. W',Y,S',M \vdash^{\gcSem} e \Downarrow w_1,Y_1,M_1\\
		&\text{Fact 2}. \veq{H_1}{Y_1}{v}{w}\\
		&\text{Fact 3}. \gamma_1 \text{ is a proper partition, such that for all } l \in dom(\gamma_1),\\
		&\quad|\gamma_1(l)| = |reach_{Y_1}(w_1)(l)| + S(l)\\
		&\text{Fact 4}. \text{For all } P, |reach_{H_1}(find_{H_1}(v_1;P)) \cap \gamma_1(l)| = 
				reach_{Y_1}(find_{Y_1}(w_1;P))(l)\\
		&\text{Fact 5}. \gamma_1(l) \cap R' = \gamma(l) \cap R' \text{ and } 
			S' \subseteq dom(Y_1) \setminus M_1\\
		&\text{Fact 6}. |M_1| = |F_1| + |\oh{\gamma_1}|\\
		&V_2,H_1,R, F_1 \cup g \vdash e_2 \Downarrow v_2,H_2,F_2 \tag{admissibility}\\
		&\text{Let } W_2 = (W[x \mapsto w_1])\restriction_{FV(e_2)}, 
			j = \{ l \in H_1 \mid l \notin M_1 \cup S \cup locs_{W_2,Y_1}(e_2) \}\\
		&\text{NTS } W_2,Y_1,S,M_1 \cup j \preceq V_2,H_1,R, F_1 \cup g\\
		&\emph{(1)}\quad W_2,Y_1 \sim V_2,H_1 \tag{condition 1. of $\preceq$ and Fact 1}\\
		&\emph{(2)}\quad \text{Let } \gamma_2 : dom(Y_1) \setminus (M_1 \cup j) 
			\to \mathcal{P}(dom(H_1)\setminus (F_1 \cup g)) \text{ be defined by } 
			\gamma_2(l) = \gamma_1(l) \setminus g\\
		&\quad \text{NTS } |\gamma_2(l)| = reach_{Y_1}(W_2)(l) + S(l)\\
		&\quad \text{STS } |\gamma_1(l)| = |\gamma_1(l) \cap g| + reach_{Y_1}(W_2)(l) + S(l)\\
		&\quad \textbf{case } x \in FV(e_2):\\
		&\quad\quad g =  collect(R',v_1,H_1,F_1) \\
		&\quad\quad = \emptyset  \tag{By \ref{itm:eager}}\\
		&\quad\quad |\gamma_1(l)| = reach_{Y_1}(w_1)(l) + S'(l) \tag{Fact 3}\\
		&\quad\quad = reach_{Y_1}(w_1)(l) + 
			reach_{Y}(W\restriction_{FV(e_2) \setminus \{x\}})(l) + S(l) \\
		&\quad\quad = reach_{Y_1}(W_2)(l) + S(l)  \\
		&\quad \textbf{case } x \notin FV(e_2):\\
		&\quad\quad g = collect(R',v_1,H_1,F_1) \sqcup reach_{H_1}(v_1)\\
		&\quad\quad = reach_{H_1}(v_1) \tag{By \ref{itm:eager}}\\
		&\quad\quad |\gamma_1(l) \cap g| = reach_{Y_1}(w_1) \tag{Fact 3}\\
		&\quad\quad \text{STS } |\gamma_1(l)| = reach_{Y_1}(w_1)(l) + reach_{Y_1}(W_2)(l) + S(l)\\
		&\quad\quad = reach_{Y_1}(w_1)(l) + S'(l)  \tag{Fact 3}\\
		&\quad\quad = reach_{Y_1}(w_1)(l) + reach_{Y}(W\restriction_{FV(e_2)\setminus \{x\}})(l) + S(l)\\
		&\quad\quad = reach_{Y_1}(w_1)(l) + reach_{Y_1}(W\restriction_{FV(e_2)\setminus \{x\}})(l) + S(l) 		\tag{By \ref{itm:stable}}\\
		&\quad\quad = reach_{Y_1}(W_2)(l) + S(l)\\
		&\emph{(3)}\quad \text{Let $l \in dom(\gamma_2), x' \in dom(W_2)$, 
			$P$ valid sequence w.r.t $W_2(x')$. NTS }\\ 
		&|reach_{H_1}(V_2(x';P)) \cap \gamma_2(l)| = reach_{Y_1}(W_2(x';P))(l)\\ 
		&\quad \textbf{case } x' = x:\\
		&\quad\quad |reach_{H_1}(V_2(x';P)) \cap \gamma_2(l)| = reach_{Y_1}(W_2(x';P))(l) \tag{Fact 4}\\ 
		&\quad \textbf{case } x' \ne x:\\
		&\quad\quad |reach_{H_1}(V_2(x';P)) \cap \gamma(l)| = reach_{Y_1}(W_2(x';P))(l) 
			\tag{stability and condition 3. of $\preceq$}\\ 
		&\quad\quad |reach_{H_1}(V_2(x';P)) \cap \gamma_1(l)| = reach_{Y_1}(W_2(x';P))(l) 
			\tag{$reach_{H_1}(V_2(x';P)) \subseteq R'$ and Fact 5.}\\
		&\quad\quad |reach_{H_1}(V_2(x';P)) \cap \gamma_2(l)| = reach_{Y_1}(W_2(x';P))(l) 
			\tag{$g \cap R' = \emptyset$}\\
		&\emph{(4).a}\quad \text{NTS } S \subseteq dom(Y_1) \setminus (M_1 \cup j)\\
		&\quad S' \subseteq dom(Y_1) \setminus M_1 \tag{Fact 5.}\\
		&\quad S \subseteq dom(Y_1) \setminus M_1\\
		&\quad S \cap j = \emptyset\\
		&S \subseteq dom(Y_1) \setminus (M_1 \cup j)\\
		&\emph{(4).b}\quad \text{Let } l \in S. \text{ NTS } |\gamma_2(l) \cap R| = S(l)\\
		&\quad |\gamma_2(l) \cap R| = |(\gamma_1(l) \setminus g) \cap R| \\
		&\quad = |\gamma_1(l) \cap R| \tag{$g \cap R = \emptyset$}\\
		&\quad = |\gamma(l) \cap R| \tag{Fact 5.}\\
		&\quad = S(l) \tag{condition 4. of $\preceq$}\\ 
		&\emph{(5)}\quad \text{NTS } |M_1 \sqcup j| = |F_1 \sqcup g| + \oh{\gamma_2}\\
		&\quad\text{Exactly the same as in E:CondT}\\
		&\text{Thus } W_2,Y_1,S,M_1 \cup j \preceq V_2,H_1,R, F_1 \cup g\\
		&\text{By IH on the second premise, we have } (w_2,Y_2,M_2) \text{ and } \gamma_3 \text{ s.t. }\\
		&\text{Fact 1'}. W_2,Y_1,S,M_1 \cup j \vdash^{\gcSem} e_2 \Downarrow w_2,Y_2,M_2\\
		&\text{Fact 2'}. \veq{H_2}{Y_2}{v_2}{w_2}\\
		&\text{Fact 3'}. \gamma_3 \text{ is a proper partition, such that for all } l \in dom(\gamma_3),\\
		&\quad|\gamma_3(l)| = |reach_{Y_2}(w_2)(l)| + S(l) + |\gamma_3(l)|\\
		&\text{Fact 4'}. \text{For all } P, |reach_{H_2}(find_{H_2}(v_2;P)) \cap \gamma_3(l)| = 
				reach_{Y_2}(find_{Y_2}(w_2;P))(l)\\
		&\text{Fact 5'}. \gamma_3(l) \cap R = \gamma_2(l) \cap R \text{ and } 
			S \subseteq dom(Y_2) \setminus M_2\\
		&\quad \gamma_2(l) \cap R = \gamma_1(l) \cap R \tag{$g \cap R = \emptyset$}\\
		&\quad = \gamma(l) \cap R \tag{Fact 5. from first premise}\\
		&\text{Fact 6'}. |M_2| = |F_2| + |\oh{\gamma_3}|\\
		&\text{Apply F:Let to \emph{(1)}, we are done.}
  \end{align*}
	\item[Case 8: E:Pair]
  Similar to E:Const*
  \item[Case 9: E:MatP]
  Similar to E:CondT
  \item[Case 10: E:Nil]
  Similar to E:Const*
  \item[Case 11: E:Cons]
  \begin{align*}
		&V,H,R,F \; \vdash \consexcst{x_1}{x_2} \Downarrow l,H' ,F \setminus \{l\} \tag{case}\\
		&W,Y,S,M \preceq V,H,R,F \tag{assumption}\\
		&\text{Let } w = \pairexcst{W(x_1)}{W(x_2)}\\
		&\text{Let } m \in M, Y' = Y\{m \mapsto w\}\\
		&\emph{(1) }V,H,R,F \; \vdash
			\consexcst{x_1}{x_2} \Downarrow m,Y' ,M \setminus \{m\} \tag{F:Cons}\\
		&\emph{(2) } \veq{H}{Y}{v}{w} \tag{assumption}\\
		&\emph{(3) } \text{Let } \gamma' : dom(Y') \setminus M' \to \mathcal{P}(dom(H')\setminus F')
			\text{ be defined by } \gamma'(l') = \gamma[m \mapsto \{l\}](l')\\
		&\quad \gamma' \text{ is a proper partition } 
			\tag{$\gamma$ proper and $l \notin dom(H) \setminus F$}\\
		&\quad \text{NTS } |\gamma'(l')| = reach_{Y'}(m)(l') + S(l')\\
		&\quad \text{STS } |\gamma[m \mapsto \{l\}](l')| = 
			reach_{Y'}(m)(l') + S(l')\\
		&\textbf{case } l' = m:\\
		&\quad |\gamma[m \mapsto \{l\}](l')| = |\{l\}| = 1\\
		&\quad 	reach_{Y'}(m)(l') + S(l') = 1 + reach_{Y'}(w_1)(m) + reach_{Y'}(w_2)(m) + S(l')\\
		&\quad = 1 + S(m) \tag{$M \cap reach_{Y}(W) = \emptyset$}\\
		&\quad = 1 \tag{$M \cap S = \emptyset$}\\
		&\textbf{case } l' \ne m:\\
		&\quad |\gamma[m \mapsto \{l\}](l')| = |\gamma(l')| = reach_H(W)(l') + S(l') 
			\tag{condition 2. of $\preceq$}\\
		&\quad = reach_{H'}(w_1)(l') + reach_{H'}(w_2)(l') + S(l')\\
		&\quad = \{m \mapsto 1\}(l') + reach_{H'}(w_1)(l') + reach_{H'}(w_2)(l') + S(l')\\
		&\quad = reach_{H'}(m)(l') + S(l')\\
		&\emph{(4) } \text{Let } l \in dom(\gamma'), P \text{ be a valid path w.r.t } l. \text{ NTS }
		|reach_{H'}(find_{H'}(l;P)) \cap \gamma'(l')| = 
				reach_{Y'}(find_{Y'}(m;P))(l')\\
		&\textbf{case } P = []\\
		&\quad |reach_{H'}(find_{H'}(l;P)) \cap \gamma'(l')| = |reach_{H'}(l) \cap \gamma'(l')|\\
		&\quad = |(\{l\} \cup reach_{H'}(v_1) \cup reach_{H'}(v_2)) \cap \gamma'(l')|\\
		&\quad = |\{l\} \cap \gamma(l')| + |reach_{H'}(v_1) \cap \gamma'(l')| 
		+ |reach_{H'}(v_2) \cap \gamma'(l')| \\
		&\quad = \mathbbm{1}_{l' = m} + reach_{Y'}(w_1)(l') + reach_{Y'}(w_2)(l') 
			\tag{condition 3. of $\preceq$}\\
		&\quad = reach_{Y'}(m)(l')\\
		&\quad = reach_{Y'}(find_{Y'}(m;P))(l')\\
		&\textbf{case } P = \ms{N}::P'\\
		&\quad |reach_{H'}(find_{H'}(l;\ms{N}::P')) \cap \gamma'(l')| = 
			|reach_{H'}(\pairexcst{v_1}{v_2}) \cap \gamma'(l')|\\
		&\quad = reach_{Y'}(find_{Y'}(m;P))(l') \tag{similar to above}\\
		&\emph{(5) } \text{NTS } S \subseteq dom(\gamma') 
			\tag{condition 4. of $\preceq$ and $dom(\gamma) \subseteq dom(\gamma')$}\\
		&\quad\text{Let } l' \in dom(\gamma'). \text{ NTS } 
			\gamma(l') \cap R = \gamma(l) \cap R\\
		&\quad \text{STS } \gamma[m \mapsto \{l\}](l') \cap R = \gamma(l') \cap R\\
		&\textbf{case } l' = m:\\
		&\quad \gamma[m \mapsto \{l\}](m) \cap R = \{l\} \cap R\\
		&\quad = \emptyset \tag{well-formed configuration}\\
		&\quad = \gamma(l') \cap R \tag{well-formed configuration}\\
		&\textbf{case } l' \ne m:\\
		&\quad \gamma[m \mapsto \{l\}](m) \cap R = \gamma(l') \cap R\\
		&\emph{(6) } \text{NTS } |M'| = |F'| + \oh{\gamma'}\\
		&\quad |M'| = |M| - 1\\
		&\quad |F'| = |F| - 1\\
		&\quad \oh{\gamma'} = \oh{\gamma[m \mapsto \{l\}]}\\
		&\quad = \bigcup C \in ec(\gamma') C \setminus (rep(C))\\
		&\quad = (\{l\} \setminus \{l\}) \cup \bigcup C \in ec(\gamma) C \setminus (rep(C))\\
		&\quad = \bigcup C \in ec(\gamma) C \setminus (rep(C))\\
		&\quad = \bigcup C \in ec(\gamma) C \setminus (rep(C))\\
		&\quad = \oh{\gamma}\\
		&\quad \text{STS } |M| - 1 = |F| - 1 + \oh{\gamma}\\
		&\quad \text{Have } |M| = |F| + \oh{\gamma} \tag{condition 5. of $\preceq$}
	\end{align*}
  \item[Case 12: E:MatNil]
  Similar to E:Cond*
  \item[Case 13: E:MatCons]
  \begin{align*}
		&V,H,R,F \; \vdash^{\copySem} \listcaseexcst{x}{e_1}{x_h}{x_t}{e_2} \Downarrow v,H',F' \tag{case}\\
		&W,Y,S,M \preceq V,H,R,F \tag{assumption}\\
		&V',H,R,F \cup g \; \vdash e_2 \Downarrow v, H',F' \tag{admissibility}\\
		&\text{Let } W' = W \restriction_{dom(V')}\\
		&\text{Let } j = \{l \in Y | l \notin M \cup S \cup locs_{W',Y}(e_2) \}\\
		&\text{NTS } W',Y,S,M \cup j \preceq V',H,R,F \cup g\\
		&\text{Let } \gamma' : dom(Y) \setminus (M \sqcup j) 
		\to \mathcal{P}(dom(H) \setminus (F \sqcup g)) \text{ be defined by } 
		\gamma'(l) = \gamma(l) \setminus g\\
		&\emph{(1) } W',Y \sim V',H \tag{similar to E:CondT}\\
		&\text{Let } W(x) = m\\
		&H(m) = \pairexcst{w_h}{w_t}, \veq{H}{Y}{v_h}{w_h},\veq{H}{Y}{v_t}{w_t} \tag{(1)} \\
		&\emph{(2) } \gamma'(l) \text{ is a proper partition }. \tag{similar to E:CondT}\\
		&\quad \text{Let } l' \in dom(\gamma')\\
		&\quad \text{Now, NTS } |\gamma'(l')| = reach_{Y}(W')(l) + S(l')\\
		&\quad \text{Consider } |\gamma(l') \cap reach_H(V(x))|\\
		&\quad = |\gamma(l') \cap \{l\}| + |\gamma(l') \cap reach_H(v_h)| 
			+ |\gamma(l') \cap reach_H(v_t)|\\ 
		&\quad = reach_Y(W(x))(l') \tag{condition 3. of $\preceq$}\\
		&\quad = (\{m \mapsto 1\} \uplus reach_Y(w_h) \uplus reach_Y(w_t))(l')\\
		&\quad = \{m \mapsto 1\}(l') + reach_Y(w_h)(l') + reach_Y(w_t)(l')\\
		&\quad\text{Note } |\gamma(l') \cap reach_H(v_h)| = 
			|\gamma(l') \cap reach_H(V(x;[\ms{N},\ms{L}]))|\\
		&\quad = reach_Y(W(x;[\ms{N},\ms{L}]))(l')\\
		&\quad = reach_Y(w_h)(l')\\
		&\quad\text{Similarly, } |\gamma(l') \cap reach_H(v_h)| = reach_Y(w_h)(l')\\
		&\quad\text{Thus } |\gamma(l') \cap \{l\}| =  \{m \mapsto 1\}(l') = \mathbbm{1}_{l' = m}\\
		&\quad \text{Back to the NTS: }\\
		&\quad \gamma'(l') = \gamma(l') \setminus g \tag{definition}\\ 
		&\quad |\gamma'(l')| = |\gamma(l')| - |\gamma(l') \cap g|\\
		&\quad = reach_Y(W)(l') + S(l') - |\gamma(l') \cap g|\\
		&\textbf{case } \{x_h,x_t\} \subseteq FV(e_2):\\
		&\quad g = \{l\} \cup reach_H(V\restriction_{dom(V) \setminus (FV(e_2)\cup \{x\})})
			\tag{definition of $g$ and \ref{itm:na}}\\
		&\quad |\gamma(l') \cap g| = |(\gamma(l') \cap \{l\}) \cup (\gamma(l') \cap
		reach_H(V\restriction_{dom(V)\setminus (FV(e_2)\cup \{x\})}))|
		&\quad = \mathbbm{1}_{l' = m} + reach_H(W\restriction_{dom(W)\setminus (FV(e_2)\cup \{x\})})(l')
			\tag{condition 3. of $\preceq$}\\
		&\quad \text{Thus, } |\gamma'(l')| = 
			reach_Y(W)(l') + S(l') - (\mathbbm{1}_{l' = m}
				+ reach_Y(W\restriction_{dom(W)\setminus (FV(e_2) \cup \{x\})})(l'))\\
		&\quad = reach_Y(W\restriction_{FV(e_2) \cup \{x\}})(l') + S(l') - \mathbbm{1}_{l' = m}\\
		&\quad = reach_Y(W\restriction_{FV(e_2)})(l') + 
			reach_Y(m)(l') + reach_Y(w_h)(l') + reach_Y(w_t)(l') + S(l') - \mathbbm{1}_{l' = m}\\
		&\quad = reach_Y(W\restriction_{FV(e_2)})(l') + 
			reach_Y(w_h)(l') + reach_Y(w_t)(l') + S(l')\\
		&\quad = reach_Y(W')(l') +  S(l')\\
		&\textbf{case } x_h \in FV(e_2), x_t \notin FV(e_2):\\
		&\quad g = \{l\} \cup reach_H(V\restriction_{dom(V) \setminus (FV(e_2)\cup \{x\})}) \cup
			reach_H(v_t)
			\tag{definition of $g$ and \ref{itm:na}}\\
		&\quad |\gamma(l') \cap g| = |\gamma(l') \cap \{l\}| + |\gamma(l') \cap
		reach_H(V\restriction_{dom(V)\setminus (FV(e_2)\cup \{x\})})| + |\gamma(l') \cap reach_H(v_t)|
		&\quad = \mathbbm{1}_{l' = m} + reach_H(V\restriction_{dom(V)\setminus (FV(e_2)\cup \{x\})})(l')
			+ |\gamma(l') \cap reach_H(v_t)| \tag{condition 3. of $\preceq$}\\
		&\quad = \mathbbm{1}_{l' = m} + reach_H(V\restriction_{dom(V)\setminus (FV(e_2)\cup \{x\})})(l')
			+ reach_Y(w_t)(l') \tag{condition 3. of $\preceq$}\\
		&\quad \text{Thus, } |\gamma'(l')| = 
			reach_Y(W)(l') + S(l') - (\mathbbm{1}_{l' = m}
				+ reach_Y(W\restriction_{dom(W)\setminus (FV(e_2) \cup \{x\})})(l') + reach_Y(w_t)(l))\\
		&\quad = reach_Y(W\restriction_{FV(e_2)})(l') + 
			reach_Y(m)(l') + reach_Y(w_h)(l') + reach_Y(w_t)(l') + S(l') - \mathbbm{1}_{l' = m} 
				- reach_Y(w_t)(l)) \\
		&\quad = reach_Y(W\restriction_{FV(e_2)})(l') + 
			reach_Y(w_h)(l') + S(l')\\
		&\quad = reach_Y(W')(l') +  S(l')\\
		&\textbf{case } x_t \in FV(e_2), x_h \notin FV(e_2) \text{ and } 
			\{x_h,x_t\} \cap FV(e_2) = \emptyset: \text{ symmetric to above }\\
		&\emph{(3) } \text{Let $l' \in dom(\gamma'), x' \in dom(W')$, 
			$P$ valid sequence w.r.t $W'(x')$. NTS }\\ 
		&\quad|reach_{H}(V'(x';P)) \cap \gamma'(l')| = reach_{Y}(W'(x';P))(l')\\ 
		&\textbf{case } x' \notin \{x_h,x_t\}:\\
		&\quad |reach_{H}(V'(x';P)) \cap \gamma'(l')| = 
			|reach_{H}(V'(x';P)) \cap (\gamma(l')\setminus g)| \\
		&\quad = |reach_{H}(V'(x';P)) \cap \gamma(l')| \tag{$g \cap reach_H(V'(x)) = \emptyset$}\\ 
		&\quad = reach_Y(W'(x;P))(l') \\
		&\quad = reach_Y(W(x;P))(l') \\
		&\textbf{case } x' = x_h:\\
		&\quad |reach_{H}(V'(x';P)) \cap \gamma'(l')| = |reach_{H}(find_H(v_h,P)) \cap \gamma'(l')|\\
		&\quad |reach_{H}(find_H(v_h,P)) \cap (\gamma(l')\setminus g)|\\
		&\quad |reach_{H}(find_H(v_h,P)) \cap \gamma(l')| \tag{$g \cap reach_H(V') = \emptyset$}\\
		&\quad = |reach_{H}(find_H(l,\ms{N}::\ms{L}::P)) \cap \gamma(l')|\\
		&\quad = |reach_{H}(V(x,\ms{N}::\ms{L}::P)) \cap \gamma(l')|\\
		&\quad = reach_{Y}(W(x,\ms{N}::\ms{L}::P))(l') \tag{condition 3. of $\preceq$}\\
		&\quad = reach_{Y}(find_H(m,\ms{N}::\ms{L}::P))(l') \\
		&\quad = reach_{Y}(find_H(v_h,P))(l') \\
		&\quad = reach_{Y}(W'(x_h;P))(l') \\
		&\emph{(4) } \text{Similar to E:CondT}\\
		&\emph{(5) } \text{Similar to E:CondT}\\
		&\text{Apply IH and F:MatCons and we're done}
  \end{align*}
  \item[Case 14: E:Share]
	\begin{align*}
		&V,H,R,F \; \vdash^{\copySem} \sharecpcst{x}{x_1}{x_2}{e} \Downarrow v,H'',F' \tag{case}\\
		&W,Y,S,M \preceq V,H,R,F \tag{assumption}\\
		&V',H',R,F' \sqcup g \; \vdash e \Downarrow v,H'',F' \tag{admissibility}\\
		&\text{Let } W(x) = w'\\
		&\veq{Y}{H}{v'}{w'} \tag{condition 1 of. $\preceq$}\\
		&\text{Let } W' = (W[x_1 \mapsto w', x_2 \mapsto w'])\restriction_{FV(e)}\\
		&\text{Let } j = \{l \in Y | l \notin M \cup S \cup locs_{W',Y}(e) \}\\
		&\text{NTS } W',Y,S,M \cup j \preceq V',H,R,F \cup g\\
		&\text{Let } \gamma' : dom(Y) \setminus (M \sqcup j) 
		\to \mathcal{P}(dom(H) \setminus (F \sqcup g)) \text{ be defined by } 
		\gamma'(l) = \gamma(l) \setminus g\\
		&\emph{(1) } W',Y \sim V',H \tag{Similar to E:CondT}\\
		&\emph{(2) } \text{Have proper partition } \gamma' : 
			dom(Y) \setminus M \to dom(H') \setminus F' \tag{By $\ref{itm:copyRel}$}\\
		&\quad \text{Let } j = \{l \in H \mid l \notin M \cup S \cup locs_{W',Y}(e)\}\\
		&\quad \text{Let } \gamma''(l) : dom(Y) \setminus (M \cup j) \to dom(H') \setminus (F' \cup g)
			\text{ by defined by } \gamma''(l) =  \gamma'(l) \setminus g\\
		&\quad \gamma'' \text{ is a proper partition } \tag{Similar to E:CondT}\\
		&\quad \text{Let } l \in dom(\gamma'')\\
		&\quad \text{Now, NTS } |\gamma''(l)| = reach_{Y}(W')(l) + S(l')\\
		&\quad \gamma''(l) = \gamma'(l) \setminus g \tag{definition}\\ 
		&\quad |\gamma''(l)| = |\gamma'(l)| - |\gamma'(l) \cap g|\\
		&\quad = |\gamma(l)| + \mathbbm{1}_{l \in reach_Y(w')} - |\gamma'(l) \cap g|\\
		&\quad = reach_Y(W)(l) + S(l) + reach_Y(w')(l) - |\gamma'(l) \cap g|\\
		&\textbf{case } \{x_1,x_2\} \subseteq FV(e):\\
		&\quad g = collect(R,reach_H(V),H,F) = \emptyset \tag{well-formed configuration}\\
		&\quad |\gamma''(l)| = reach_Y(W)(l) + S(l) + reach_Y(w')(l) \tag{By \ref{itm:copyRel}}\\
		&\quad = reach_Y(W')(l) + S(l) \\
		&\textbf{case } x_1 \in FV(e), x_2 \notin FV(e):\\
		&\quad g = collect(R,reach_H(V),H,F) \cup reach_H'(v') = reach_{H'}(v') 
			\tag{well-formed configuration}\\
		&\quad |\gamma''(l)| = reach_Y(W)(l) + S(l) + reach_Y(w')(l)
			- |\gamma'(l) \cap reach_{H'}(v')|\\
		&\quad = reach_Y(W)(l) + S(l) + reach_Y(w')(l) - |\gamma(l) \cap reach_H(v')|
			\tag{By \ref{itm:copyRel}}\\
		&\quad = reach_Y(W)(l) + S(l) + reach_Y(w')(l) - reach_Y(w')(l) 
			\tag{condition 3. of $\preceq$}\\
		&\quad = reach_Y(W)(l) + S(l)\\
		&\quad = reach_Y(W')(l) + S(l)\\
		&\textbf{case } x_2 \in FV(e), x_1 \notin FV(e) 
			\text{ and } \{x_1,x_2\} \cap FV(e) = \emptyset: \text{ symmetric to above}\\
		&\emph{(3) - (5)} \text{ Similar to E:MatCons}\\ 
		&\text{Applying the IH then F:Share, and we're done. }
	\end{align*}
  \end{description}
\end{proof}



%------------------------------------------------------------------------------
% Index
%\printindex

%------------------------------------------------------------------------------
\end{document}


%%% Local Variables:
%%% mode: latex
%%% mode: flyspell
%%% TeX-master: t
%%% End:
