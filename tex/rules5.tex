\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage{latexsym}
\usepackage{verbatim}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{stackengine}
\usepackage{scalerel}
\usepackage{code,proof,amsthm,amssymb, amsmath}
\usepackage{mathpartir}
\usepackage{turnstile}
\usepackage{fancyvrb}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{hyperref}
\usepackage[margin=0.5in]{geometry}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows}

\allowdisplaybreaks

\input{generic-defns}
\input{syn-defns}
\input{../pfpl/fun-defns}
\input{../pfpl/pcf-defns}
\input{../pfpl/prod-defns}
\input{../pfpl/sum-defns}
\input{../pfpl/icoi-defns}
\input{../pfpl/t-defns}

% =========================================================================== %
%                                                                             %
%                          Using this LaTeX Template                          %
%                                                                             %
% - new tasks are on their own section (how Gradescope expects them)          %
% - use '\task' to start a new task                                           %
% - use 'begin{task} ... \end{task}' if you'd like to preface your answer     %
%   with the question itself (i.e., fill in the '...' with the question)      %
% - use '\nextgroup' to advance from, for example, Task 1.4 to Task 2.1       %
% - use '\skipaheadtask' to skip from, for example, Task 2.2 to Task 2.4      %
%                                                                             %
% You also have access to all the definitions from the handout. See defs.tex, %
% syn-defns.tex, and generic-defns.tex.                                       %
%                                                                             %
%               TODO: Fill in your personal information below!                %
%                                                                             %
% =========================================================================== %
\newcommand{\myname}{Andrew Carnegie}
\newcommand{\myandrewid}{andrew}
\newcommand{\hwnumber}{1}
% =========================================================================== %

\newcounter{group}
\setcounter{group}{1}
\newtheorem{theorem}{Task}[group]
% Remove '\newpage' below to preview your doc compactly.
% Remember to put it back before submitting to Gradescope.
\newcommand{\task}{\newpage\begin{theorem}\end{theorem}}
\newcommand{\nextgroup}{\stepcounter{group}}
\newcommand{\skipaheadtask}{\stepcounter{theorem}}
\newcommand{\ms}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\irl}[1]{\mathtt{#1}}
\newcounter{rule}
\setcounter{rule}{0}
\newcommand{\rn}
  {\addtocounter{rule}{1}(\arabic{rule})}	

\newcounter{infercount}
\setcounter{infercount}{1}
\newcommand{\infern}[2]{\inferrule{#1}{#2}(\text{S}_{\arabic{infercount}}\stepcounter{infercount})}
\newcommand*\ts[2]{%
  \,\scalebox{1}[0.5]{$\sststile[ss]{\textstyle#1}{\textstyle#2}$}\,
}
\newcommand{\inferr}[2]{\inferrule{#2}{#1}}
\newcommand{\inferrr}[3]{\inferrule[#1]{#2}{#3}}
\newcommand{\paircaseabt}[4]{\irl{case}(#2,#3.#4)}
\newcommand{\paircasecst}[4]{\irl{case} \; #1\; \{(#2;#3) \hookrightarrow #4\}}
\newcommand{\na}[1]{\mathsf{no\_alias}(#1)}
\newcommand{\nr}[1]{\mathsf{no\_ref}(#1)}
\newcommand{\stable}[1]{\mathsf{stable}(#1)}
\newcommand{\set}[1]{\mathsf{set}(#1)}
\newcommand{\safe}[1]{\mathsf{safe}(#1)}
\newcommand{\dist}[1]{\mathsf{disjoint}(#1)}
\newcommand{\stack}[1]{\irl{stack}(#1)}
\newcommand{\denote}[1]{\llbracket#1\rrbracket}
\newcommand{\nil}{[]}
\newcommand{\cons}[2]{\pi(#1,#2)}
\newcommand{\sharecst}[4]{\irl{share}\;#1\;\irl{as}\;#2,#3\;\irl{in}\;#4}
\newcommand{\sharecpcst}[4]{\irl{shareCopy}\;#1\;\irl{as}\;#2,#3\;\irl{in}\;#4}
\newcommand{\shareabt}[4]{\irl{share}(#1;#2,#3.#4)}
\newcommand{\ssize}[2]{\left\Vert #2 \right\Vert_{#1}}
\newcommand{\card}[1]{card(#1)}
\newcommand{\val}[1]{\irl{val}(#1)}
\newcommand{\gc}[3]{\mathsf{gc}(#1,#2,#3)}
\newcommand{\wfc}[5]{\mathsf{wfc}(#1,#2,#3,#4,#5)}
\newcommand{\veq}[4]{#3 \sim^{#1}_{#2} #4}
\newcommand{\ctxeq}[2]{(#1) \sim (#2)}
\newcommand{\oh}[1]{\oslash(#1)}
\newcommand{\fogc}{\ms{FO}^{gc}}
\newcommand{\cf}[1]{#1^{cf}}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}{Corollary}[theorem]
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\title{Automatic Resource Bound Analysis for Functional Programs with Garbage Collection}
\author{\myname\\(\myandrewid)}
\date{\today}
\setlength{\parindent}{0pt}

\begin{document}
\maketitle
\pagenumbering{gobble}

\begin{abstract}
In todayâ€™s complex software systems, resource consumption such as time, memory, and energy is
increasingly more relevant. Manually analyzing and predicting resource consumption is cumbersome
and error prone. As a result, programming language research studies techniques that support developers
by automating and guiding such a resource analysis. Most current techniques for resource bound
inference work in an environment with manual memory management, or simply assume there is no
automatic memory management. As a result, memory bounds derived by the aforementioned techniques
are not accurate when the underlying system employs garbage collection. We
develop new techniques for automatic bound inference in the presence of garbage collection, and 
implement them as an extension to Resource Aware ML (RaML). We show that our system is able to 
derive tight symbolic bounds for heap usage of common algorithms for which current analysis give 
asymptotically worse bounds.
\end{abstract}

\section{Introduction}

\noindent
We present an algorithm for statically determining the symbolic cost bound 
of the space complexity for first-order, garbage-collected functional programs. 
The algorithm is based on Automatic Amortized Resource Analysis (AARA) as implemented 
in Resource Aware ML (RaML) \cite{Hoffmann:2017:TAR:3009837.3009842}.

\subsection{Background}
\label{sect:background}

We define the execution of the given language by giving it an
operational cost semantics. The semantics is a big-step
(or natural) semantics in the style of Spoonhower and Minamide (\cite{Spoonhower:2008:SPP:1411204.1411240} and 
\cite{DBLP:journals/entcs/Minamide99}), which assigns any program a space cost. This cost is
the highwater mark on the heap, or the maximum number of cells used in the mutable store during 
evaluation. While \cite{Spoonhower:2008:SPP:1411204.1411240} and 
\cite{DBLP:journals/entcs/Minamide99} compute this cost at the leaves of a 
evaluation judgment, we compute the cost ``as it happens'' by leveraging the \emph{free-list},
which represents the cells available for evaluation. 
The concept of the free-list can be found in Hofmann et. al. (\cite{Hofmann:2003:SPH:604131.604148}).
However, unlike \cite{Hofmann:2003:SPH:604131.604148}, in order to account for garbage collection,
we define the free-list as a set of locations instead of single number denoting its size.\\

The abstract and concrete syntax of the language is show below. Note that we only allow first order functions 
of type $\tau_1 \to \tau_2$, where $\tau_1$ and $\tau_2$ are base types: unit, bool, product, or lists. In 
this paper, we restrict the language to terms that are in let-normal form to simplify the presentation. We 
allow an extended syntax in the implementation. 

\[
\begin{array}{r l l l l}
\ms{BTypes} & \tau \,\,\,\,\, ::= \\
	& \irl{nat}                	 			& \irl{nat}											& \text{naturals}\\
	& \unittyabt                	 			& \unittycst										& \text{unit}\\
  & \booltyabt                       & \booltycst                    & \text{boolean}\\
  & \prodtyabt{\tau_1}{\tau_2}       & \prodtycst{\tau_1}{\tau_2}    & \text{product}\\
  &\listtyabt{\tau}		& L(\tau)											& \text{list}\\
  \\
\ms{FTypes} & \rho \,\,\,\,\, ::= \\
	&\irl{arr}(\tau_1;\tau_2) 				& \arrtycst{\tau_1}{\tau_2} 									& \text{first order function}\\
	 \\
\ms{Exp}
        & e   \,\,\,\,\, ::= \\
 	& x                                			& x 												& \text{variable}\\
  & \irl{nat}[n]							& \numeral{n}												& \text{number}\\
  & \irl{unit}							& ()												& \text{unit}\\
  & \irl{T}							& \irl{T}												& \text{true}\\
  & \irl{F}	   					& \irl{F}												& \text{false}\\
	& \irl{plus}(e_1;e_2)	   			& e_1 + e_2												& \text{plus}\\
	& \irl{minus}(e_1;e_2)	   			& e_1 - e_2												& \text{minus}\\
	& \irl{eq}(e_1;e_2)	   			& e_1 = e_2												& \text{equality}\\
	& \irl{lt}(e_1;e_2)	   			& e_1 < e_2												& \text{less-than}\\
	& \irl{and}(e_1;e_2)	   			& e_1 \land e_2												& \text{conjunction}\\
	& \irl{or}(e_1;e_2)	   			& e_1 \lor e_2												& \text{disjunction}\\
	& \irl{not}(e)	   			& \lnot e											& \text{negation}\\
  & \ifexabt{x}{e_1}{e_2} & \ifexcst{x}{e_1}{e_2}  & \text{if}\\
  & \irl{lam}(x:\tau.e) 						&\lambda \; x : \tau. e 		& \text{abstraction}\\
  & \irl{ap}(f;x) 					& \appcst{f}{x} 										& \text{application}\\
  & \irl{tpl}(x_1;x_2)     	& \pairexcst{x_1}{x_2}                									& \text{pair}\\
 	& \paircaseabt{p}{x_1}{x_2}{e_1}					& \paircasecst{p}{x_1}{x_2}{e_1}   	& \text{match pair}\\
 	& \nilexabt					& []   										& \text{nil}\\
 	& \consexabt{x_1}{x_2}					& x_1::x_2   										& \text{cons}\\
 	& \listcaseexabt{l}{e_1}{x}{xs}{e_2}					& \listcaseexcst{l}{e_1}{x}{xs}{e_2}   	& \text{match list}\\
  & \irl{let}(e_1; x : \tau.e_2)			& \irl{let}\; x = e_1 \; \irl{in}\; e_2   	& \text{let}\\
  & \shareabt{x}{x_1}{x_2}{e} &\sharecst{x}{x_1}{x_2}{e} &\text{share}\\
  \\
\ms{Val}
        & v   \,\,\,\,\, ::= \\
 	& \irl{val}(n)                                			& n 												& \text{numeric value}\\
 	& \irl{val}(\irl{T})                               			& \irl{T} 								  & \text{true value}\\
 	& \irl{val}(\irl{F})                                			& \irl{F}								  & \text{false value}\\
 	& \irl{val}(\irl{Null})                                  & \irl{Null} 								  & \text{null value}\\
 	& \irl{val}(\irl{cl}(V; x.e))                & (V, x.e) 					& \text{function value}\\
 	& \irl{val}(l)                                			& l 								  & \text{loc value}\\
 	& \irl{val}(\pairexabt{v_1}{v_2})                             & \pairexcst{v_1}{v_2} 								  & \text{pair value}\\
  \\
\ms{Loc} & l   \,\,\,\,\, ::= \\
 	& \irl{loc}(l)                                			& l 												& \text{location}\\\\
\ms{Var} & l   \,\,\,\,\, ::= \\
 	& \irl{var}(x)                                			& x 												& \text{variable}\\
\end{array}
\]

\newpage

\section{Notation}
\noindent 
For a finite mapping $f : A \to B$, we write $dom$ for the defined values of $f$. Sometimes we shorten $x \in dom(f)$ to $x \in f$. We write $f[x \mapsto y]$ for the extension of $f$ where $x$ is mapped to $y$, with the constraint that $x \notin dom(f)$. \\

Given possibly non-disjoint sets $A,B$, let the disjoint union be $A \oplus B$ defined by 
$\{(\ms{inl},a) \mid a \in A\} \cup \{(\ms{inr},b) \mid b \in B\}$.

Let a multiset be a function $S : A \to \mathbb{N}$, i.e. a map of the multiplicity of each element in the domain. 
Write $x \in S$ iff $S(x) \ge 1$. If for all  $s \in S$, $\mu(s) = 1$, then $S$ is a property set, 
and we denote this by $\ms{set}(S)$. Addtionally, $A \uplus B$ denotes counting union of sets where 
$(A \uplus B) (s) = A (s) + B(s)$, similarly, $(A \cap B)(s) = \min{A(s),B(s)}$. Furthermore,
 $A \cup B$ denotes the usual union where 
$(A \cup B)(s) = \max{(A(s),B(s))}$. 
For the union of disjoint multi-sets $A$ and $B$, we write $A \sqcup B$ to emphasize the disjointness.
For a collection of pairwise disjoint multi-sets $\mathcal{C}$, i.e. $\forall X,Y \in \mathcal{C}$. $X \cap Y = \emptyset$, we write $\dist{\mathcal{C}}$.
In the rest of the paper, 
we sometimes treat a set $A$ sets as multiset $A : A \to \mathbb{N}$ via 
$x \mapsto \begin{cases} 1 &\text{ if } x \in A \\0 &\text{ o.w.}\end{cases}$ when convenient. 
For instance, if an operation 
defined on multisets is used on sets and multisets, the set is thus promoted.\\

\section{Garbage collection semantics}



The garbage collection operation semantics is defined by a collection of judgement of the form:
\[
\fbox{$\mathcal{C} \; \vdash_{P : \Sigma} e \Downarrow v, H', F'$}
\]

\noindent
Where $\mathcal{C}$ is a \emph{configuration}, consisting of a 4-tuple in 
$\ms{Stack} \times \ms{Heap} \times \mathcal{P}(\ms{Loc}) \times \mathcal{P}(\ms{Loc})$, 
usually written as $V,H,R,F$. 
P is a program with signature $\Sigma : \ms{Var} \to \ms{FTypes}$. 
This can be read as: under stack $V$, heap $H$, continuation set $R$,
free-list $F$, and program $P$ with signature $\Sigma$, the expression $e$ evaluates to $v$, and engenders a new heap $H'$ and freelist $F'$. Here, $\ms{Stack}$ is defined as the set of finite mappings $\ms{Var} \to \ms{Val}$, and $\ms{Heap}$ is defined as the set of finite mappings $\ms{Loc} \to \ms{Val}$.\\

\noindent
A \emph{program} is then a $\Sigma$ indexed map $P$ from $\ms{Var}$ to pairs $(y_f,e_f)_{f \in \Sigma}$, where $\Sigma(y_f) = A \to B$, and $\Sigma;y_f : A \vdash e_f : B$ (typing rules are discussed in $\ref{sec:typing}$). We write $P : \Sigma$ to mean $P$ is a program with signature $\Sigma$. Because the signature $\Sigma$ for the mapping of function names to first order functions does not change during evaluation, we drop the subscript $\Sigma$ from $\vdash_{\Sigma}$ when the context of evaluation is clear. It is convenient to think of the evaluation judgement $\vdash$ as being indexed by a family of signatures $\Sigma$'s, each of which is a set of ``top-level'' first-order declarations to be used during evaluation.\\

The garbage collection semantics is to designed to model the heap usage of a program running with a 
``perfect'' reference counting garbage collector: whenever a heap cell becomes unreachable from the 
root set, it becomes collected and added to the free-list as available for reallocation.
The continuation set $R$ represents the set of locations required to compute the continuation 
\emph{excluding} the current expression.
We can think of $R$ heap cells needed to compute the (surrounding) context with a hole which is filled
by the current expression.
The root set is then the union of the locations in the continuation set $R$ and the locations in the current 
expression $e$.
Primitives and types with statically-known sizes are stack-allocated 
($\booltycst, \irl{nat}, \prodtycst{\tau_1}{\tau_2}$) and use no heap cells; this is reflected in the 
reachability predicate defined below. 

\subsection{Reachability}

\noindent
In order to formalize the intuitive operations of the garbage collector, we define some auxiliary relations. \\

We define the 3-place reachability relation $reach(H,v,L)$ on $\ms{Heap} \times \ms{Val} \times \wp(\ms{Loc})$.
We write $L = reach_H(v)$ to indicate this is a functional relation justified by the valid mode $(+,+,-)$.

\begin{mathpar}
\inferrule{
	A = reach_H(v_1)\\
	B = reach_H(v_2)
}{
	A \uplus B = reach_H(\pairexcst{v_1}{v_2}) 
} 

\inferrule{
	A = reach_H(H(l))\\
}{
	\{l\} \uplus A = reach_H(l)
} 

\inferrule{
	v \in \mathbb{N} \cup \{\irl{T},\irl{F},\irl{Null}\}
}{
	\{l\} \uplus A = reach_H(v)
} 
\end{mathpar}

The notion of reachability naturally lifts to expressions via $locs_{V,H}$:
\begin{align*}
  &locs_{V,H}(e) = \bigcup\limits_{x \in FV(e)} reach_H(V(x))\\\\
\end{align*}
Where $FV : \ms{Exp} \to \mathcal{P}(\ms{Var})$ denotes the set of free-variables of expressions as usual.
We define $FV^{\star} : \ms{Exp} \to \wp(\ms{Var})$, the multiset of free variables of expressions,
as the usual $FV$ inductively over the structure of $e$; the only unusual thing is that multiple occurences
of a free variable $x$ in $e$ will be reflected in the multiplicity of $FV^{\star}(e)$.\\


\subsection{The Copying Semantics $\ms{copy}$}

As mentioned in the introduction, $\ms{copy}$ is an intermediary semantics in which all variable sharing 
is accomplished by physically allocating a fresh set of locations from the free-list and copying the 
cells of the original value one by one. This is also sometimes referred to as deep copying.
Let $copy(H,L,v,H',v')$ be a 5-place relation on 
$\ms{Heap} \times \mathcal{P}(\ms{Loc}) \times \ms{Val} \times \ms{Heap} \times \ms{Val}$. Similar to 
reachability, we write this as 
$H',v = copy(H,L,v)$ to signify the intended mode for this predicate: $(+,+,+,-,-)$.
\begin{mathpar}
	\inferr{
		H,v = copy(H,L,v)	
	}{
		v \in \{n,\irl{T},\irl{F},\irl{Null}\}
	}

	\inferr{
		H'\{l' \mapsto v\},l' = copy(H,L,l) 
	}{
		l' \in L\\
		H',v = copy(H,L \setminus \{l'\},H(l)) 
	}

\inferr{
	H_2,\pairexcst{v_1'}{v_2'} = copy(H,L,\pairexcst{v_1}{v_2})
}{
	L_1 \sqcup L_2 \subseteq L\\
	|L_1| = |dom(reach_H(v_1)|\\
	|L_2| = |dom(reach_H(v_2)|\\
	H_1,v_1' = copy(H,L_1,v_1)\\
	H_2,v_2' = copy(H_1,L_2,v_2)\\
}
\end{mathpar}

Primitives require no cells to copy; a location value is copied recursively; 
a pair of values is copied sequentially, and the total number of cells required is the size of the reachable 
set of the value.\\



\subsection{Rules for $\mathsf{copy}$}\label{sec:copy}
\begin{mathpar}

\infern
{ V(x) = v\\
}
{V,H,R,F \; \vdash x \Downarrow v,H,F}

\infern
{
}{
  V,H,R,F \; \vdash \numeral{n} \Downarrow \irl{val}(n),H,F
}

\infern{
}{
  V,H,R,F \; \vdash \irl{T} \Downarrow \irl{val(T)},H,F
}

\infern{
}{
  V,H,R,F \; \vdash \irl{F} \Downarrow \irl{val(F)},H ,F
}

\infern{
}{
  V,H,R,F \; \vdash () \Downarrow \irl{val(Null)},H ,F
}

\infern{
  V(x) = \irl{T}\\
  g = \{l \in H \mid l \notin F \cup R \cup locs_{V,H}(e_1)\}\\
	V' = V\restriction_{FV(e_1)}\\
  V',H,R,F \cup g\; \vdash e_1 \Downarrow v, H',F'
}{
  V,H,R,F \; \vdash \ifexabt{x}{e_1}{e_2} \Downarrow v, H',F'
}

\infern{
	V(x) = \irl{F}\\
  g = \{l \in H \mid l \notin F \cup R \cup locs_{V,H}(e_2)\}\\
	V' = V\restriction_{FV(e_2)}\\
  V',H,R,F \cup g \; \vdash e_2 \Downarrow v, H',F'
}{
  V,H,R,F \; \vdash \ifexabt{x}{e_1}{e_2} \Downarrow v, H' ,F'
}

% function

\infern{
  V(x) = v'\\
  P(f) = (y_f,e_f)\\
  g = \{l \in H \mid l \notin F \cup R \cup locs_{V,H}(e_f)\}\\
  [y_f \mapsto v'],H,R,F \cup g \; \vdash e_f \Downarrow v,H',F'\\
}{
  V,H,R,F \; \vdash \appcst{f}{x} \Downarrow v,H',F'
}

% tuples

\infern{
  V(x_1) = v_1 \\
  V(x_2) = v_2 \\
}{
  V,H,R,F \; \vdash \pairexcst{x_1}{x_2} \Downarrow \pairexcst{v_1}{v_2},H ,F
}

\infern{
	V(x) = \pairexcst{v_1}{v_2}\\
  g = \{l \in H \mid l \notin F \cup R \cup locs_{V,H}(e)\}\\
	V'' = (V[x_1 \mapsto v_1, x_2 \mapsto v_2])\restriction_{FV(e)}\\
  V'',H,R,F \cup g \; \vdash e \Downarrow v,H',F'
}{
  V,H,R,F \; \vdash \paircasecst{x}{x_1}{x_2}{e} \Downarrow v, H' ,F'
}

% lists

\infern{
}{
  V,H,R,F \; \vdash \nilexabt \Downarrow \irl{val(Null)},H,F
} 

\infern{
  v = \pairexcst{V(x_1)}{V(x_2)}\\
	l \in F\\
  H' = H\{l \mapsto v\}
}{
	V,H,R,F \; \vdash \consexcst{x_1}{x_2} \Downarrow l,H' ,F \setminus \{l\}
}

\infern{
	V(x) = v\\
  L \subseteq F\\
  |L| = |dom(reach_H(v'))|\\
  H',v'' = copy(H,L,v')\\
	V_2 = (V[x_1 \mapsto v',x_2 \mapsto v'']) \restriction_{FV(e)}\\
	F' =	F \setminus L\\
	g = \{l \in H \mid l \notin F' \cup R \cup locs_{V_2,H}(e)\}\\
 	V_2,H',R,F' \sqcup g \; \vdash e \Downarrow v,H'',F'
}{
  V,H,R,F \; \vdash \sharecpcst{x}{x_1}{x_2}{e} \Downarrow v,H'',F'
}

\infern{
  V(x) = \irl{Null}\\
	V' = V\restriction_{FV(e_1)}\\
  g = \{l \in H \mid l \notin F \cup R \cup locs_{V,H}(e_1)\}\\
  V',H,R,F \cup g \; \vdash e_1 \Downarrow v, H',F' \\
}{
  V,H,R,F \; \vdash \listcaseexcst{x}{e_1}{x_h}{x_t}{e_2} \Downarrow v,H',F'
}

\infern{
  V(x) =  l\\
  H(l) = \pairexcst{v_h}{v_t} \\
	V'' = (V[x_h \mapsto v_h, x_t \mapsto v_t])\restriction_{FV(e_2)}\\
  g = \{l \in H \mid l \notin F \cup R \cup locs_{V'',H}(e_2)\}\\
  V'',H,R,F \cup g \; \vdash e_2 \Downarrow v, H',F' \\
}{
  V,H,R,F \; \vdash \listcaseexcst{x}{e_1}{x_h}{x_t}{e_2} \Downarrow v,H',F'
}

\infern{
	V_1 = V\restriction_{FV(e_1)}\\
  R' = R \cup locs_{V_2,H}(\irl{lam}(x : \tau.e_2))\\
  V_1,H,R',F \vdash e_1 \Downarrow v_1,H_1,F_1\\
	V_2 = (V[x \mapsto v_1])\restriction_{FV(e_2)}\\
  g = \{ l \in H_1 \mid l \notin F_1 \cup R \cup locs_{V_2,H_1}(e_2) \}\\
  V_2,H_1,R, F_1 \cup g \vdash e_2 \Downarrow v_2,H_2,F_2 \\
}{
  V,H,R,F \; \vdash \irl{let}(e_1; x : \tau.e_2) \Downarrow v_2,H_2,F_2
}
\end{mathpar}

\newpage

As a simple example, take the rule (\text{E:CondT}): 

\[
\inferrule{
  V(x) = \irl{T}\\
	V' \subseteq V\\
	dom(V') = FV(e_1)\\
  g = \{l \in H \mid l \notin F \cup R \cup locs_{V,H}(e_1)\}\\
  V',H,R,F \cup g\; \vdash e_1 \Downarrow v, H',F'
}{
  V,H,R,F \; \vdash \ifexabt{x}{e_1}{e_2} \Downarrow v, H',F'
}(\text{E:CondT})
\]

This states that, to evaluate a conditional, look in the stack for the value of the branching boolean.
In the case it is true, we proceed to evaluate the first branch. In the process,
we update the stack so it only binds variables reachable from the first branch. This update is only necessary 
to prove properties about the evaluation, and is not needed in an implementation.
Furthermore, we collect cells in the heap
that are not reachable from the root set ($R \cup locs_{V,H}(e_1)$) or already in the current free-list
$F$, and add them ($g$) to the available cells for evaluating $e_1$. We could have removed the restriction 
that the cells be not in the current free-list $F$, but this simplifies the presentation of the proofs 
and the actual check can be removed in an implementation as the free-list is a set. \\

Next, we look at a more complicated rule, (\text{E:MatchCons}): 

\[
\inferrule{
  V(x) =  l\\
  H(l) = \pairexcst{v_h}{v_t} \\
  V' \subseteq V\\
  dom(V') = FV(e_2) \setminus \{x_h,x_t\} \\
  V'' = V'[x_h \mapsto v_h, x_t \mapsto v_t]\\
  g = \{l \in H \mid l \notin F \cup R \cup locs_{V'',H}(e_2)\}\\
  V'',H,R,F \cup g \; \vdash e_2 \Downarrow v, H',F' \\
}{
  V,H,R,F \; \vdash \listcaseexcst{x}{e_1}{x_h}{x_t}{e_2} \Downarrow v,H',F'
}(\text{E:MatchCons})
\]

This states that, to map out of list, look in the stack for the value of the list. In the case it is a 
heap location $l$, we check that it is mapped to a pair representing the head and tail. Similar to 
the conditional, we restrict the stack to only variables in the cons branch, and collect all heap locations
not reachable from the root set, adding it to the current free-list $F$. Finally, we evaluate $e_2$ with 
the restricted stack and new free-list.\\

As the last (and most involved) example, we look at the rule (\text{E:Let}):

\[
\infern{
  V = V_1 \sqcup V_2\\
  dom(V_1) = FV(e_1)\\
  dom(V_2) = FV(\irl{lam}(x : \tau. e_2))\\
  R' = R \cup locs_{V_2,H}(\irl{lam}(x : \tau.e_2))\\
  V_1,H,R',F \vdash e_1 \Downarrow v_1,H_1,F_1\\
  V_2' = V_2[x \mapsto v_1]\\
  g = \{ l \in H_1 \mid l \notin F_1 \cup R \cup locs_{V_2',H_1}(e_2) \}\\
  V_2',H_1,R, F_1 \cup g \vdash e_2 \Downarrow v_2,H_2,F_2 \\
}{
  V,H,R,F \; \vdash \irl{let}(e_1; x : \tau.e_2) \Downarrow v_2,H_2,F_2
}
\]

This states that, to evaluate a sequence of expressions ($e_1,e_2$), we evaluate the first expression 
with the corresponding restricted stack $V_1$ and a expanded continuation set $R'$. The extra locations come 
from the free variables of $e_2$ (not including the bound variable $x$), which we cannot collect during 
the evaluation of $e_1$. Next, we extend the restricted stack $V_2$ with the result $v_1$, 
and evaluate $e_2$ with this stack and the original continuation set $R$. \\

Of course, in many real-world languages, variable aliasing does not actually incur overhead proportional to the
size of the value; instead, the aliased value simply gains one more reference. \ms{free} (rules introduced in \ref{sec:free}) is 
the version of the garbage collection semantics designed to capture ``shallow'' copying. It is identical to \ms{copy} 
except for the variable sharing rule.
We use \ms{copy} to mediate between the type system and \ms{free}.
The chart below shows the plan for proving the soundess of the type 
system w.r.t \ms{free}:

\tikzstyle{process} = [rectangle, text centered, draw=black, fill=orange!30]
\tikzstyle{arrow} = [thick,->,>=stealth]

\begin{center}
\begin{tikzpicture}[node distance=5cm]
\node (type) [process] {Type Rules};
\node (copy) [process, right of=type, xshift=2cm] {\ms{copy}};
\node (free) [process, below of=copy] {\ms{free}};

\draw [arrow] (type) -- node[anchor=south] {Is sound w.r.t (\ref{itm:soundness})} (copy);
\draw [arrow] (copy) -- node[anchor=west] {Over-approximates (\ref{itm:frugal})} (free);
\draw [dashed,->] (type) -- node[anchor=south] {} (free);

\end{tikzpicture}
\end{center}

Where the dashed arrow represents the intended result.

\section{Operational semantics}
In order to state and prove the soundess of the type system, we also define a simplified operational semantics
that does not account for garbage collection. This technique is similar to the one employed in 
\cite{Hofmann:2003:SPH:604131.604148}.

\[
\fbox{$\mathcal{S} \vdash e \Downarrow v, H'$}
\]

Where $\mathcal{S}$ is a \emph{context}, consisting of a tuple in $\ms{Stack} \times \ms{Heap}$, and usually
written as $(V,H)$.
This can be read as: under stack $V$, heap $H$ the expression $e$ evaluates to $v$, 
and engenders a new heap $H'$. We write the representative rules, since the rest are derived in the obvious
way from the garbage collection semantics.

\begin{mathpar}
\infern{
	l \notin dom(H)\\
  v = \pairexcst{V(x_1)}{V(x_2)}\\
	H' = H\{l \mapsto v\}\\
}{
  V,H \; \vdash \consexcst{x_1}{x_2} \Downarrow l,H'
}

\infern{
  V(x) = l \\
  H(l) = \pairexcst{v_h}{v_t} \\
  V' \subseteq V\\
  dom(V') = FV(e_2) \setminus \{x_h,x_t\}\\
  V'' = V'[x_h \mapsto v_h, x_t \mapsto v_t]\\
  V'',H \; \vdash e_2 \Downarrow v, H' \\
}{
  V,H \; \vdash \listcaseexcst{x}{e_1}{x_h}{x_t}{e_2} \Downarrow v,H'
}

\infern{
  V = V_1 \sqcup V_2\\
  dom(V_1) = FV(e_1)\\
  dom(V_2) = FV(\irl{lam}(x : \tau. e_2))\\
  V_1,H \vdash e_1 \Downarrow v_1,H_1\\
  V_2' = V_2[x \mapsto v_1]\\
  V_2',H_1\vdash e_2 \Downarrow v_2,H_2\\
}{
  V,H \; \vdash \irl{let}(e_1; x : \tau.e_2) \Downarrow v_2,H_2
}

\infern{
  V = V'[x \mapsto v']\\
	L \cap dom(H) = \emptyset\\
  |L| = dom(reach_H(v'))\\
  H',v'' = copy(H,L,v')\\
  V'[x_1 \mapsto v',x_2 \mapsto v''],H' \; \vdash e \Downarrow v,H''
}{
  V,H \; \vdash \sharecpcst{x}{x_1}{x_2}{e} \Downarrow v,H''
}


\end{mathpar}
\section{Well Defined Environments}
In order to define the potential for first-order types, we need a notion of well-define environments, one that relates 
heap values to semantic values of a type. We first give a denotational semantics for the first-order types: 

\begin{align*}
() &\in \denote{\unittyabt}\\
\bot &\in \denote{\booltyabt}\\
\top &\in \denote{\booltyabt}\\
0 &\in \denote{\irl{nat}}\\
n + 1 &\in \denote{\irl{nat}} \text{ if } n \in \denote{\irl{nat}}\\
\pairexcst{a_1}{a_2} &\in \denote{\prodtycst{A_1}{A_2}} 
	\text{ if } a_1 \in \denote{A_1} \text{ and } a_2 \in \denote{A_2}\\
\nil &\in \denote{L(A)}\\
\cons{a}{l} &\in \denote{L(A)} \text{ if } a \in \denote{A} \text{ and } l \in \denote{L(A)}\\
\end{align*}

Where semantic set for each type is the least set such that the above holds. Note $\pi(x,y)$ is the usual set-theoretic pairing function, and write $[a_1,...,a_n]$ for $\pi(a_1,...,\pi(a_n,[]))$.
We also refer to the elements of a semantic set as structures. \\

Now we give the judgements relating heap values to semantic values, in the form \fbox{$H \vDash v \mapsto a : A$}, which can be read as: under heap $H$, heap value $v$ defines the semantic value $a \in \denote{A}$.  

\begin{mathpar}
\inferr{
  H \vDash \val{n} \mapsto n : \irl{nat}
}{
  n \in \mathbb{Z}
}(\text{V:ConstI})

\inferr{
  H \vDash \val{\irl{Null}} \mapsto n : \unittyabt
}{
}(\text{V:ConstI})

\inferr{
  H \vDash \val{\irl{Null}} \mapsto n : L(A)
}{
  A \in \ms{BType}
}(\text{V:Nil})

\inferr{
  H \vDash \val{\irl{T}} \mapsto \top : \booltyabt
}{
}(\text{V:True})

\inferr{
  H \vDash \val{\irl{F}} \mapsto \bot : \booltyabt
}{
}(\text{V:False})

	\inferr{
		H \vDash \pairexcst{v_1}{v_2} \mapsto \pairexcst{a_1}{a_2} : \prodtycst{A_1}{A_2}
	}{
		H \vDash v_1 \mapsto a_1 : A_1 \\
		H \vDash v_2 \mapsto a_2 : A_2
	}(\text{V:Pair})
	
\inferr{
  H \vDash l \mapsto [a_1,\ldots,a_n] : L(A)
}{
  l \in \ms{Loc}\\
  H(l) = \pairexcst{v_h}{v_t}\\
  H \vDash v_h \mapsto a_1 : A\\
  H \vDash v_t \mapsto [a_2,\ldots,a_n] : L(A)
}(\text{V:Cons})
\end{mathpar}

\iffalse
\section{Stack vs Heap Allocated Types}
In order to share variables, we need to distinguish between types that are allocated on the stack and the heap. 
We write \fbox{$\stack{A}$} to denote that values of type $A$ will be allocataed \emph{entirely} on the stack at run time (no references into the heap). 

\begin{mathpar}
\inferr{
  \stack{A}
}
{
  A \in \{\unittyabt,\booltyabt,\irl{nat}\}
}(\text{S:Const})

\inferr{
  \stack{\prodtycst{A_1}{A_2}}
}
{
  \stack{A_1} \\
  \stack{A_2}
}(\text{S:Product})
\end{mathpar}
\fi

\section{Linear Potential}\label{sec:potential}
We introduce linear potential for structures corresponding to the base types.
With linear potential, each component of a structure is associated with a constant amount of potential. 
Given a structure $a$ in a heap $H$, where  $H \vDash v \mapsto a : A$, we define its potential 
$\Phi_H(a : A)$ by recursion on $A$: 

\begin{align*}
&\Phi_H(a : A) = 0 &A \in \{\unittycst, \booltyabt, \irl{nat}\}\\
&\Phi_H(\pairexcst{a_1}{a_2} : \prodtycst{A_1}{A_2}) = \Phi_H(a_1 : A_1) + \Phi_H(a_2 : A_2)\\
&\Phi_H([a_1,...a_n] : L^p(A)) = p\cdot n + \sum_{1 \le i \le n} \Phi_H(a_i : A)  
\end{align*}

\section{Linear Garbage Collection Type Rules}
\label{sec:typing}
The type system $\fogc$ consists of rules of the form \fbox{$\Sigma;\Gamma \sststile{q'}{q} e : A$}, read as 
under signature $\Sigma$, context $\Gamma$, $e$ has type $A$ starting with $q$ units of constant potential and 
ending with $q'$ units.\\

The linear version of the type system takes into account of garbaged collected cells by returning potential locally in a match construct. Since we are interested in the number of heap cells, 
there is an implicit side condition which ensures all constants are assumed to be nonnegative.\\

The type system is based on the affine type system in \ref{Hoffmann:2017:TAR:3009837.3009842}. 
The only major difference is the rule for L:MatL, in which an additional unit of potential is returned. This reflects the 
fact (Lemma \ref{itm:na}) once a cons-cell is matched on, there can be no live references from the root set to it, and thus 
we are justified in restituting the potential to type the subexpression $e_2$. 


\iffalse
The second let rule expresses the fact that since stack types don't reference heap cells, 
any heap cells used in the evaluation of $e_1$ can be deallocated, as there are no longer references to them in $v_1$. 
\fi

\begin{mathpar}
\inferr{
  \Sigma; \emptyset \sststile{q}{q} n : \irl{nat}
}{
  n \in \mathbb{Z}
}(\text{L:ConstI})

\inferr{
  \Sigma; \emptyset \sststile{q}{q} () : \irl{unit}
}{
}(\text{L:ConstU})

\inferr{
  \Sigma; \emptyset \sststile{q}{q} \irl{T} : \irl{bool}
}{
}(\text{L:ConstT})

\inferr{
  \Sigma; \emptyset \sststile{q}{q} \irl{F} : \irl{bool}
}{
}(\text{L:ConstF})

\inferr{
  \Sigma; x : B \sststile{q}{q} x : B
}{
}(\text{L:Var})

\inferr{
  \Sigma; x : A \sststile{q'}{q} f(x) : B
}
{
  \Sigma(f) = A \xmapsto{q/q'} B
}

\inferr{
  \Sigma; \Gamma, x : \irl{bool} \sststile{q'}{q} \ifexcst{x}{e_t}{e_f} : B
}{
  \Sigma; \Gamma \sststile{q'}{q} e_t : B \\
  \Sigma; \Gamma \sststile{q'}{q} e_f : B
}(\text{L:Cond})

\inferr{
  \Sigma; x_1 : A_1, x_2 : A_2 \sststile{q}{q} \pairexcst{x_1}{x_2} : \prodtycst{A_1}{A_2}
}{
}(\text{L:Pair})

\inferr{
  \Sigma; \Gamma, x : (A_1,A_2) \sststile{q'}{q} \paircasecst{x}{x_1}{x_2}{e} : B
}{
  \Sigma; \Gamma, x_1 : A_1, x_2 : A_2 \sststile{q'}{q} e : B
}(\text{L:MatP})

\inferr{
  \Sigma; \emptyset \sststile{q}{q} \irl{nil} : L^p(A)
}{
}(\text{L:Nil})

\inferr{
  \Sigma; x_h : A, x_t : L^p(A) \sststile{q}{q+p+1} \consexcst{x_h}{x_t} : L^p(A)
}{
}(\text{L:Cons})

\inferr{
  \Sigma; \Gamma, x : L^p(A) \sststile{q'}{q} \listcaseexcst{x}{e_1}{x_h}{x_t}{e_2} : B
}{
  \Sigma; \Gamma \sststile{q'}{q} e_1 : B \\
  \Sigma; \Gamma, x_h : A, x_t : L^p(A) \sststile{q'}{q + p + 1} e_2 : B
}(\text{L:MatL})

\inferr{
  \Sigma; \Gamma_1, \Gamma_2 \sststile{q'}{q} \irl{let}(e_1; x : \tau.e_2) : B
}{
  \Sigma; \Gamma_1 \sststile{p}{q} e_1 : A \\
  \Sigma; \Gamma_2, x : A \sststile{q'}{p} e_2 : B
}(\text{L:Let})

\iffalse
\inferr{
  \Sigma; \Gamma_1, \Gamma_2 \sststile{q'}{q} \irl{let}(e_1; x : \tau.e_2) : B
}{
  \Sigma; \Gamma_1 \sststile{p}{q} e_1 : A \\
  \stack{A}\\
  \Sigma; \Gamma_2, x : A \sststile{q'}{\max{(p,q)}} e_2 : B
}(\text{L:LetS})

\inferr{
  \Sigma; \Gamma_1, \Gamma_2 \sststile{q'}{q} \irl{let}(e_1; x : \tau.e_2) : B
}{
  \Sigma; \Gamma_1 \sststile{p}{q} e_1 : A \\
  \Sigma; \Gamma_1 \sststile{}{\ms{cf}} e_1 : A' \\
  \Sigma; \Gamma_2, x : (A' - 1) \sststile{q'}{p} e_2 : B
}(\text{L:Let})
\fi

\inferr{
  \Sigma; \Gamma, x : A \sststile{q'}{q} \irl{drop}(x;e) : B
}{
  \Sigma; \Gamma \sststile{q'}{q} e : B
}(\text{L:Drop})

\iffalse
\inferr{
  \Sigma; \Gamma, x : A \sststile{q'}{q} \sharecst{x}{x_1}{x_2}{e} : B
}{
  \stack{A}\\
  \Sigma; \Gamma, x_1 : A, x_2 : A \sststile{q'}{q} e : B
}(\text{L:ShareS})
\fi

\inferr{
  \Sigma; \Gamma, x : A \sststile{q'}{q} \sharecpcst{x}{x_1}{x_2}{e} : B
}{
  A \;\curlyvee \;A_1, A_2,1\\
  \Sigma; \Gamma, x_1 : A_1, x_2 : A_2 \sststile{q'}{q} e : B
}(\text{L:ShareCopy})
\end{mathpar}

Where $A \curlyvee A_1,A_2,n$ is the sharing relation defined as:
\begin{align*}
	&L^p(A) \curlyvee L^q(A_1),L^r(A_2),n & \text{if } p = q + r + n \;\text{and}\; A \curlyvee A_1,A_2,n\\
	&\prodtycst{A}{B} \curlyvee \prodtycst{A_1}{A_2}, \prodtycst{B_1}{B_2}, n 
		&\text{ if } A \curlyvee A_1,A_2,n \text{ and } B \curlyvee B_1,B_2,n\\
	&A \curlyvee A,A,n & \text{ if } A \in \{\unittycst, \booltycst, \irl{nat}\}\\
\end{align*}

\iffalse
And $A - n$ is potential subtraction defined as:
\begin{align*}
L^p(A) - n &= L ^ {\max{(p - n,0)}}(A - n)\\
\prodtycst{A_1}{A_2} - n &= \prodtycst{A_1 - n}{A_2 - n}\\
A - n &= A\\
\end{align*}
\fi

Now if we take $\dagger :  L^p(A) \mapsto L(A)$ as the map that erases resource annotations, 
 we obtain a simpler typing judgement \fbox{$\Sigma^{\dagger}; \Gamma^{\dagger} \vdash e : B^{\dagger}$}.

\newpage
\section{Soundness for Linear GC}
We state and prove the soundness of $\ms{FO}^{gc}$ for \emph{well-formed} computations. We need the following 
definitions to state well-formedness:

\begin{definition}(Non-aliasing context)
Given a context $(V,H)$, let
$x,y \in dom(V)$, $x \ne y$, and $r_x = reach_H(V(x))$, $r_y = reach_H(V(y))$.
It is non-aliasing given that:
\begin{enumerate}
\item $\ms{set}(r_x), \ms{set}(r_y)$
\item $r_x \cap r_y = \emptyset$
\end{enumerate}
Denote this by $\na{V,H}$.
\end{definition}

For a stack $V$ and a heap $H$, whenever $\na{V,H}$ holds, visually, one can think of the situation as the following: the induced graph of heap $H$ with variables on the stack as additional leaf nodes is a forest: a disjoint union of directed trees; consequently, there is at most one path from a live variable on the stack $V$ to a location in $H$ by following the pointers.

\begin{definition}[Stability]
Given heaps $H,H'$, a set of locations is \emph{stable} if $\forall l \in R$. $H(l) = H'(l)$. Denote this by
$\stable{R,H,H'}$.
\end{definition}

\begin{definition}[Well-formed computation]
Given a configuration $\mathcal{C} = (V,H,R,F)$ and an expression $e$, 
we say the 5-tuple $(\mathcal{C},e)$ is a \emph{computation}; it is a \emph{well-formed computation} 
given the following:
\begin{enumerate}
\item $dom(V) = FV(e)$
\item $\na{V,H}$
\item $\dist{\{R,F,locs_{V,H}(e)\}}$
\end{enumerate} 
And we write $\wfc{V}{H}{R}{F}{e}$ to denote this fact.
\end{definition}

\begin{lemma}
\label{a} If $\Sigma; \Gamma \sststile{q'}{q} e : B$, then $\Sigma^{\dagger}; \Gamma^{\dagger} \vdash e : B^{\dagger}$.
\end{lemma}

\begin{lemma}\label{itm:linear}
\label{a} If $\Sigma; \Gamma \sststile{q'}{q} e : B$, then $\set{FV^{\star}(e)}$ and $dom(\Gamma) = FV(e)$.
\end{lemma}

\begin{proof}
Induction on the typing judgement.
\end{proof}

\begin{lemma}\label{itm:stable}
Let $H \vDash v \mapsto a : A$. For all sets of locations $R$, if $reach_H(v) \subseteq R$ and $\stable{R,H,H'}$, then $H' \vDash v \mapsto a : A$ and $reach_H(v) = reach_{H'}(v)$.
\end{lemma}

\begin{proof}
Induction on the structure of $cst$.
\end{proof}

\begin{corollary}
Let $H \vDash V : \Gamma$. For all sets of locations $R$, if $\bigcup_{x \in V} reach_H(V(x)) \subseteq R$ and $\stable{R,H,H'}$, then $H' \vDash V : \Gamma$.
\end{corollary}

\begin{proof}
Follows from Lemma $\ref{itm:stable}$.
\end{proof}

\begin{lemma}\label{itm:stack}
Let $H \vDash v \mapsto a : A$. If $\stack{A}$, then $\Phi_H(v:A) = 0$.
\end{lemma}

\begin{proof}
Induction on $H \vDash v \mapsto a : A$.
\end{proof}

% copy

\begin{lemma}[stability of copying]
	Let $H',v' = copy(H,L,v)$. For all $l \in H$, if $l \notin L$, then $H(l) = H'(l)$. 
	Further, $reach_{H'}(v') \subseteq L$.
\end{lemma}

\begin{lemma}[copy is copy]
	Let $H',v' = copy(H,L,v)$. If $H \vDash v \mapsto a : A$, then $H' \vDash v' \mapsto a : A$.
\end{lemma}

\iffalse
% heap conservation
\begin{lemma}[heap conservation]
Let $\wfc{V}{H}{R}{F}{e}$, $V,H,R,F \; \vdash e \Downarrow v, H', F'$, and $g = \gc{H'}{R}{F'}$. 
Then $\ssize{H}{V} + |F| \le \ssize{H'}{v} + |F' \cup g|$.
\end{lemma}

\begin{proof}
Induction on evaluation.\\
\begin{description}
  \item[Case 1: E:Var]
  \begin{align*}
  &V = [x \mapsto v] \tag{since $dom(V) = FV(e) = \{x\}$}\\
  &\ssize{H}{V} = \ssize{H}{v} \tag{def of $\ssize{H}{\cdot}$}\\
  &\ssize{H}{V} + |F| \le \ssize{H'}{v} + |F \cup g|\\
  \end{align*}
  \item[Case 2: E:Const*]
  Due to similarity, we show only for E:ConstI
  \begin{align*}
  &V = \emptyset \tag{since $dom(V) = FV(e) = \emptyset$}\\
  &\ssize{H}{V} = \ssize{H}{v} \tag{def of $\ssize{H}{\cdot}$}\\
  &\ssize{H}{V} + |F| \le \ssize{H'}{v} + |F \cup g|\\
  \end{align*}
  \item[Case 4: E:App]
  \item[Case 5: E:CondT] Similar to E:MatNil
  \item[Case 6: E:CondF] Similar to E:CondT
  \item [Case 7: E:Let]
  \begin{align*}
  &\ssize{H}{V_1} + |F| \le \ssize{H_1}{v_1} + |F_1 \cup g| \tag{IH on first premise}\\ 
  &\text{Let } g' = \gc{H_2}{R}{F_2}\\
  &\ssize{H_1}{V_2'} + |F_1 \cup g| \le \ssize{H_2}{v_2} + |F \cup g'| \tag{IH on second premise}\\
  &\ssize{H_1}{V_2'} = \ssize{H_1}{V_2} + \ssize{H_1}{v_1} \tag{definition of semantic size}\\
  &\quad = \ssize{H}{V_2} + \ssize{H_1}{v_1} \tag{main lemma}\\
  &\ssize{H}{V_2} + \ssize{H_1}{v_1} + |F_1 \cup g| \le \ssize{H_2}{v_2} + |F \cup g'|\\
  &\ssize{H}{V_1} + \ssize{H}{V_2} + \ssize{H_1}{v_1} + |F| + |F_1 \cup g| \le \ssize{H_1}{v_1} + \ssize{H_2}{v_2} +
  |F_1 \cup g| + |F \cup g'|\\
  &\ssize{H}{V} + |F| \le \ssize{H_2}{v_2} + |F \cup g'|\\
  \end{align*}
  \item[Case 8: E:Pair]
  Similar to E:Var
  \item[Case 9: E:MatP]
  Similar to E:MatCons
  \item[Case 10: E:Nil]
  Similar to E:Const*
  \item[Case 11: E:Cons]
  \begin{align*}
  &V = [x_1 \mapsto v_1,x_2 \mapsto v_2] \tag{since $dom(V) = FV(e) = \{x_1,x_2\}$}\\
  &\ssize{H}{V} = \ssize{H}{v_1} + \ssize{H}{v_2} \tag{def of $\ssize{H}{\cdot}$}\\
  &\ssize{H'}{l} = 1 + \ssize{H'}{H'(l)} = 1 + \ssize{H''}{v} = 1 + \ssize{H''}{v_1} + \ssize{H''}{v_2}
  \tag{def of semantic size}\\
  &\quad = 1 + \ssize{H}{v_1} + \ssize{H}{v_1}\\
  &\quad = 1 + \ssize{H}{V}\\
  &L \sqcup \{l\} \subseteq g \tag{$R \cap F = \emptyset$ and $L \sqcup \{l\} \subseteq H''$}\\
  &|g| \ge |L \sqcup \{l\}| = size(v) + 1\\
  &|F' \cup g| \ge |F|\\
  &\ssize{H}{V} + |F| \le \ssize{H'}{v} + |F \cup g|\\
  \end{align*}
  \item[Case 12: E:MatNil]
  \begin{align*}
  \end{align*}
  \item [Case 13: E:MatCons]
  \begin{align*}
  &\text{Let } g' = \gc{H'}{R}{F'}\\
  &\ssize{H}{V''}  + |F \cup g| \le |F' \cup g'| \tag{IH (wfc from main lemma)}\\
  &\ssize{H}{V''} = \ssize{H}{V'[x_h \mapsto v_h, x_t \mapsto v_t]}\\
  &\quad = \ssize{H}{V'} + \ssize{H}{v_h} + \ssize{H}{v_t}\\
  &\quad = \ssize{H}{V'} + \ssize{H}{l} - 1\\
  &\quad = \ssize{H}{V} - 1\\
  &\ssize{H}{V} - 1 + |F \cup g| \le |F' \cup g'|\\
  &\ssize{H}{v} - 1 + |F| + |g| \le |F' \cup g'| \tag{$F \cap g = \emptyset$}\\
  &\ssize{H}{v} + |F| \le |F' \cup g'| \tag{$|g| \ge 1$ from main lemma}\\
  \end{align*}
  \item [Case 13: E:Drop]
  \begin{align*}
  &\text{Let } g' = \gc{H'}{R}{F'}\\
  &\ssize{H}{V'} + |F \cup g| \le \ssize{H'}{v} + |F' \cup g'| \tag{IH}\\
  &\sszie{H}{V} = \ssize{V'} + \ssize{v'}\\
  &\ssize{H}{V} - \ssize{v'} + |F \cup reach_H(v')| \le \ssize{H'}{v} + |F' \cup g'|\\
  &\ssize{H}{V} - \ssize{v'} + |F| + |reach_H(v')| \le \ssize{H'}{v} + |F' \cup g'|\\
  &\ssize{H}{V} + |F| \le \ssize{H'}{v} + |F' \cup g'|\\
  \end{align*}
  \item [Case 13: E:ShareCopy]
  \begin{align*}
	&\text{Let } g' = \gc{H'}{R}{F'}\\
	&\ssize{H'}{V'[x_1 \mapsto v', x_2 \mapsto v'']} + |F \setminus L| 
			\le \ssize{H''}{v} + |F' \cup g'| \tag{IH, well-formedness from main lemma}\\
  &\ssize{H'}{V'[x_1 \mapsto v', x_2 \mapsto v'']} + |F \setminus L| =
			\ssize{H}{V} + \ssize{H'}{v''} + |F| - |L| \tag{stability lemma for copy}\\
	&\quad = \ssize{H}{V} + |L| + |F| - |L| \tag{lemma about copy}\\
	&\quad = \ssize{H}{V} + |F|\\
  \end{align*}
\end{description}
\end{proof}
\fi

% main lemma

\begin{lemma}[main lemma]\label{itm:na}
For all stacks $V$ and heaps $H$, let  $V,H,R,F \; \vdash e \Downarrow v, H', F'$ 
and $\Sigma; \Gamma \vdash e : B$. Then given that $\wfc{V}{H}{R}{F}{e}$, we have the follwoing: 
\begin{enumerate}
\item $\ms{set}(reach_{H'}(v))$
\item $\dist{\{R,F',reach_{H'}(v)\}}$, and
\item $\stable{R,H,H'}$
\end{enumerate}
\end{lemma}

\iffalse
\begin{proof}
Nested induction on the evaluation judgement and the typing judgement.\\
\begin{description}
  \item[Case 1: E:Var]
  \begin{align*}
  &\text{Suppose } H \vDash V : \Gamma, dom(V) = FV(e), \na{V,H}, \dist{\{R,F,locs_{V,H}(e)\}}\\
  &\ms{set}(reach_{H}(v)) \tag{$\na{V,H}$}\\
  &\dist{\{R,F,reach_{H}(v)\}} \tag{$\dist{\{R,F,locs_{V,H}(e)\}}$}\\
  &\na{V,H} \tag{Sp.}\\
  &\stable{R,H,H'} \tag{$H = H'$}
  \end{align*}
  \item[Case 2: E:Const*]
  Due to similarity, we show only for E:ConstI
  \begin{align*}
  &\text{Suppose } H \vDash V : \Gamma, dom(V) = FV(e), \na{V,H},\dist{\{R,F,locs_{V,H}(e)\}}\\
  &\ms{set}(reaach_{H}(v)) \tag{$reach_H(v) = \emptyset$}\\
  &\dist{\{R,F,\emptyset\}} \tag{$\dist{R,F}$}\\
  &\na{V,H} \tag{Sp.}\\
  &\stable{R,H,H'} \tag{$H = H'$}
  \end{align*}
  \item[Case 4: E:App]
  \item[Case 5: E:CondT] Similar to E:MatNil
  \item[Case 6: E:CondF] Similar to E:CondT
  \item [Case 7: E:Let]
  \begin{align*}
  &V,H,R,F \; \vdash \irl{let}(e_1; x : \tau.e_2) \Downarrow v_2,H_2,F_2 \tag{case}\\
  &V,H,R',F \vdash e_1 \Downarrow v_1,H_1,F_1 \tag{ad.}\\
  &\Sigma; \Gamma_1,\Gamma_2 \vdash \irl{let}(e_1; x : \tau.e_2) : B \tag{case}\\
  &\Sigma; \Gamma_1 \vdash e_1 : A \tag{ad.}\\
  &\text{Suppose } H \vDash V : \Gamma, dom(V) = FV(e), \na{V,H}, \dist{\{R,F,locs_{V,H}(e)\}}\\ 
  &H \vDash V_1 : \Gamma_1 \tag{def of W.D.E and Lemma $~\ref{itm:linear}$}\\
  &\text{By IH, we have invariant on } J_1\\
  &\text{NTS (1) - (3) to instantiate invariant on } J_1\\
  &\emph{(1)}\quad dom(V_1) = FV(e_1) \tag{def of $V_1$}\\
  &\emph{(2)}\quad \na{V_1,H} \tag{$\na{V,H}$ and $V_1 \subseteq V$}\\
  &\emph{(3)}\quad \dist{R',F,locs_{V,H}(e_1)}\\
  &F \cap R' = \emptyset \tag{$F \cap locs_{V,H}(e) = \emptyset$ and $locs_{V_2,H}(\irl{lam}(x : \tau. e_2)) \subseteq locs_{V,H}(e)$}\\
  &FV(e_1) \cap FV(\irl{lam}(x : \tau. e_2)) = \emptyset \tag{Lemma ~\ref{itm:linear}}\\
  &locs_{V,H}(e_1) \cap locs_{V_2,H}(\irl{lam}(x : \tau. e_2)) = \emptyset \tag{$\na{V,H}$}\\
  &R' \cap locs_{V,H}(e_1) = \emptyset \tag{$\dist{\{R,locs_{V,H}(e)\}}$}\\
  &F \cap locs_{V,H}(e_1) = \emptyset \tag{Sp.}\\
  &\text{Thus we have } \dist{R',F,locs_{V,H}(e_1)}\\
  &\text{By IH, }\\
  &\emph{(1)}\quad \ms{set}(reach_{H_1}(v_1))\\
  &\emph{(2)}\quad \dist{\{R',F_1,reach_{H_1}(v_1)\}}\\
  &\emph{(3)}\quad \stable{R',H,H_1}\\
  &V_2',H_1,R, F_1 \cup g \vdash e_2 \Downarrow v_2,H_2,F_2 \tag{ad.} \\
  &\Sigma; \Gamma_2, x : A \vdash e_2 : B \tag{ad.}\\
  &H_1 \vDash V_2' : (\Gamma_2, x : A) \tag{???}\\
  &\text{By IH, we have invariant on } J_2\\
  &\text{NTS (1) - (3) to instantiate invariant on } J_2\\
  &\emph{(1)}\quad dom(V_2') = FV(e_2) \tag{def of $V_2'$}\\
  &\emph{(2)}\quad \na{V_2',H_1}\\
  &\text{Let } x_1, x_2 \in V2', x_1 \ne x_2 \text{ be arb.}\\
  &\textbf{case: } x_1 \ne x, x_2 \ne x\\
  &\quad reach_H(V_2'(x_1)) \subseteq R' \tag{$reach_H(V_2'(x_1)) \subseteq locs_{V_2',H}(\irl{lam}(x : \tau. e_2))$}\\
  &\quad reach_H(V_2'(x_2)) \subseteq R' \tag{$reach_H(V_2'(x_2)) \subseteq locs_{V_2',H}(\irl{lam}(x : \tau. e_2))$}\\
  &\quad reach_H(V_2'(x_1)) = reach_{H_1}(V_2'(x_1)),reach_H(V_2'(x_2)) = reach_{H_1}(V_2'(x_2)) \tag{$\stable{R',H,H_1}$ and Lemma $~\ref{itm:stable}$}\\
  &\quad reach_{H_1}(V_2'(x_1)) = reach_{H}(V(x_1)),reach_{H_1}(V_2'(x_2)) = reach_{H}(V(x_2)) \tag{$\stable{R',H,H_1}$ and Lemma $~\ref{itm:stable}$}\\
  &\quad \na{V_2',H_1} \tag{$\na{V,H}$}\\
  &\textbf{case: } x_1 = x, x_2 \ne x\\
  &\quad reach_{H_1}(V_2'(x_1)) = reach_{H_1}(v_1) \tag{def of $V_2'$}\\
  &\quad reach_{H_1}(V_2'(x_2)) \subseteq R' \tag{same as above}\\
  &\quad \ms{set}(reach_{H_1}(v_1)) \tag{IH 1.1}\\
  &\quad reach_{H_1}(V_2'(x_2)) = reach_{H}(V(x_2)) \tag{same as above}\\
  &\quad \ms{set}(reach_{H_1}(V_2'(x_2))) \tag{$\na{V,H}$}\\
  &\quad reach_{H_1}(V_2'(x_1)) \cap reach_{H_1}(V_2'(x_2)) = \emptyset \tag{$\dist{\{R',reach_{H_1}(v_1)\}}$}\\
  &\text{Thus we have } \na{V_2',H_1}\\
  &\emph{(3)}\quad \dist{\{R,F_1 \cup g,locs_{V_2',H_1}(e_2)\}}\\
  &R \cap F_1 = \emptyset \tag{$\dist{\{R', F_1\}}$ from 1.2 and $R \subseteq R'$}\\
  &R \cap (F_1 \cup g) = \emptyset \tag{def of $g$}\\
  &\text{NTS } (F_1 \cup g) \cap locs_{V_2',H_1}(e_2) = \emptyset\\
  &\text{Let } l \in locs_{V_2',H_1}(e_2) \text{ be arb.}\\
  &l \in reach_{H_1}(V_2'(x')) \text{ for some } x' \in V_2'\\
  &\textbf{case: } x' \ne x\\
  &\quad reach_H(V_2(x')) = reach_{H_1}(V_2'(x')) \tag{same as above}\\
  &\quad reach_{H_1}(V_2'(x')) \subseteq R' \tag{def of $R'$}\\
  &\quad reach_{H_1}(V_2'(x')) \cap F_1 = \emptyset \tag{$\dist{\{R', F_1\}}$ from 1.2}\\
  &\text{case: } x' = x\\
  &\quad reach_{H_1}(V_2'(x')) = reach_{H_1}(v_1) \tag{def of $V_2'$}\\
  &\quad reach_{H_1}(V_2'(x')) \cap F_1 = \emptyset \tag{$\dist{\{F_1,reach_{H_1}(v_1)\}}$ from 1.2}\\
  &reach_{H_1}(V_2'(x')) \subseteq locs_{V_2',H_1}(e_2) \tag{def of $locs_{V,H}$}\\
  &reach_{H_1}(V_2'(x')) \cap g = \emptyset \tag{def of $g$}\\
  &\text{Thus } reach_{H_1}(V_2'(x')) \cap (F_1 \cup g) = \emptyset\\
  &\text{NTS } R \cap locs_{V_2',H_1}(e_2) = \emptyset\\
  &\text{Let } l \in locs_{V_2',H_1}(e_2) \text{ be arb.}\\
  &l \in reach_{H_1}(V_2'(x')) \text{ for some } x' \in V_2'\\
  &\textbf{case: } x' \ne x\\
  &\quad reach_H(V_2(x')) = reach_{H_1}(V_2'(x')) \tag{same as above}\\
  &\quad l \in locs_{V,H}(e) \tag{def of $locs_{V,H}$}\\
  &\quad l \notin R \tag{$\dist{\{R,locs_{V,H}(e)\}}$ from 0.3}\\
  &\textbf{case: } x' = x\\
  &\quad reach_{H_1}(V_2'(x')) = reach_{H_1}(v_1) \tag{def of $V_2'$}\\
  &\quad reach_{H_1}(V_2'(x')) \cap R = \emptyset \tag{$\dist{\{R', reach_{H_1}(v_1)\}}$ from 1.2 and $R \subseteq R'$}\\
  &\text{Thus } reach_{H_1}(V_2'(x')) \cap R = \emptyset\\
  &\text{Hence we have }\emph{(3)}\quad \dist{R,F_1 \cup g,locs_{V_2',H_1}(e_2)}\\
  &\text{By instantiating the invariant on } J_2, \text{ we have }\\
  &\emph{(1)}\quad \ms{set}(reach_{H_2}(v_2))\\
  &\emph{(2)}\quad \dist{\{R,F_2,reach_{H_2}(v_2)\}}\\
  &\emph{(3)}\quad \stable{R,H_1,H_2}\\
  &\text{Lastly, showing (1) - (3) holds for the original case } J_0:\\
  &\emph{(1)}\quad \ms{set}(reach_{H_2}(v_2)) \tag{By 2.1}\\
  &\emph{(2)}\quad \dist{\{R,F_2,reach_{H_2}(v_2)\}} \tag{By 2.2}\\
  &\emph{(3)}\quad \stable{R,H_1,H_2}\\
  &\text{Let } l \in R \text{ be arb. }\\
  &H(l) = H_1(l) \tag{$\stable{R',H,H_1}$ from 1.3}\\
  &H_1(l) = H_2(l) \tag{$\stable{R,H_1,H_2}$ from 2.3}\\
  &H(l) = H_2(l)\\
  &\text{Hence } \stable{R,H,H_2}\\
  \end{align*}
  \item[Case 8: E:Pair]
  Similar to E:Var
  \item[Case 9: E:MatP]
  Similar to E:MatCons
  \item[Case 10: E:Nil]
  Similar to E:Const*
  \item[Case 11: E:Cons]
  \begin{align*}
  &V,H,R,F \; \vdash e \Downarrow l,H'',F' \tag{case}\\
  &\text{Suppose } H \vDash V : \Gamma, dom(V) = FV(e), \na{V,H}, \dist{\{R,F,locs_{V,H}(e)\}}\\
  &\text{NTS (1) - (3) holds after evaluation }\\
  &\emph{(1)} \quad \ms{set}(reach_{H''}(l))\\
  &\stable{\{locs_{V,H}(e)\},H,H''} \tag{$\dist{\{F,locs_{V,H}(e)\}}$ and $copy$ only updates $l \in L \subseteq F$}\\
  &reach_H(V(x_i)) = reach_{H''}(V(x_i)) \tag{$reach_H(V(x_i)) \subseteq locs_{V,H}(e)$ and $~\ref{itm:stable}$ for $i = 1,2$}\\
  &reach_{H''}(l) = \{l\} \cup reach_{H''}(V(x_1))\cup reach_{H''}(V(x_2)) \tag{def of $reach_H$}\\
  &\set{reach_{H''}(l)} \tag{$l \notin locs_{V,H}(e)$ and $\na{V,H}$}\\ 
  &\emph{(2)} \quad \dist{\{R,F',reach_{H''}(l)\}}\\
  &R \cap F' = \emptyset \tag{$F' \subseteq F$ and $\dist{\{R,F\}}$}\\
  &R \cap reach_{H''}(l) = \emptyset \tag{$l \in F$ and $\dist{\{R,locs_{V,H}(e)\}}$}\\
  &F' \cap reach_{H''}(l) = \emptyset\tag{$F' \subseteq F$ and $\dist{\{F,locs_{V,H}(e)\}}$}\\
  &\text{Thus we have }\emph{(2)} \quad \dist{\{R,F',reach_{H''}(l)\}}\\
  &\emph{(3)} \quad \stable{R,H,H''} \tag{since copy only updates $l \in L \subseteq F$ and $F \cap R = \emptyset$}\\
  \end{align*}
  \item[Case 12: E:MatNil]
  \begin{align*}
  &\text{Suppose } H \vDash V : \Gamma, dom(V) = FV(e), \na{V,H}, \dist{\{R,F,locs_{V,H}(e)\}}\\
  &\Sigma; \Gamma' \vdash e_1 : B \tag{ad.}\\
  &V,H,R,F \cup g \; \vdash e_1 \Downarrow v, H',F' \tag{ad.}\\
  &H \vDash V' : \Gamma' \tag{def of W.D.E}\\
  &\text{By IH, we have invariant on } J_1\\
  &\text{NTS (1) - (3) to instantiate invariant on } J_1\\
  &\emph{(1)}\quad dom(V') = FV(e_1) \tag{def of $V'$}\\
  &\emph{(2)}\quad \na{V',H} \tag{$\na{V,H}$ and $V' \subseteq V$}\\
  &\emph{(3)}\quad \dist{\{R,F,locs_{V',H}(e_1)\}} \tag{$\dist{\{R,F,locs_{V,H}(e)\}}$ and $locs_{V',H}(e_1) \subseteq locs_{V,H}(e)$}\\
  &\text{Instantiating invariant on } J_1,\\
  &\emph{(1)}\quad \ms{set}(reach_{H'}(v))\\
  &\emph{(2)}\quad \dist{\{R,F_1,reach_{H'}(v)\}}\\
  &\emph{(3)}\quad \stable{R,H,H'}
  \end{align*}
  \item [Case 13: E:MatCons]
  \begin{align*}
  &V(x) = l \tag{ad.}\\
  &H(l) = \pairexcst{v_h}{v_t} \tag{ad.}\\
  &\Gamma = \Gamma', x : L(A) \tag{ad.}\\
  &\Sigma; \Gamma', x_h : A, x_t : L(A) \vdash e_2 : B \tag{ad.}\\
  &V'',H,R,F \cup g \; \vdash e_2 \Downarrow v_2, H_2, F' \tag{ad.} \\
  &\text{Suppose } H \vDash V : \Gamma, dom(V) = FV(e), \na{V,H},\dist{\{F,R,locs_{V,H}(e)\}}\\
  &H \vDash V(x) : L(A) \tag{def of W.D.E}\\
  &H''\vDash v_h : A,\; H'' \vDash v_t : L(A) \tag{ad.}\\
  &H\vDash v_h : A,\; H \vDash v_t : L(A) \tag{???}\\
  &H \vDash V'' : \Gamma', x_h : A, x_t : L(A) \tag{def of W.D.E}\\
  &\text{By IH, we have invariant on } J_1\\
  &\text{NTS (1) - (3) to instantiate invariant on } J_1\\
  &\emph{(1)}\quad dom(V'') = FV(e_2) \tag{def of $V''$}\\
  &\emph{(2)}\quad \na{V'',H} \\
  &\text{Let } x_1, x_2 \in V'', x_1 \ne x_2, r_{x_1} = reach_H(V''(x_1)), r_{x_2} = reach_H(V''(x_2))\\
  & \textbf{case: } x_1 \notin \{x_h,x_t\}, x_2 \notin \{x_h,x_t\}\\
  &\quad (1), (2) \text{ from } \na{V,H}\\
  & \textbf{case: } x_1 = x_h, x_2 \notin \{x_h,x_t\}\\
  &\quad \ms{set}(r_{x_1}) \tag{ since $\ms{set}(reach_H(V(x)))$ from  $\na{V,H}$}\\
  &\quad \ms{set}(r_{x_2}) \tag{since  $\na{V,H}$}\\
  &\quad x_2 \in FV(e) \tag{def of $FV$}\\
  &\quad reach_H(V(x)) \cap r_{x_2} = \emptyset \tag{def of $reach$ and $\na{V,H}$}\\
  &\quad \text{hence } r_{x_1} \cap r_{x_2} = \emptyset\\
  &\textbf{case: } x_1 = x_h, x_2 = x_t\\
  &\quad \ms{set}(r_{x_1}) \text{ since } \ms{set}(reach_{H}(V(x))) \text{ from } \na{V,H}\\
  &\quad \ms{set}(r_{x_2}) \text{ since } \ms{set}(reach_H(V(x))) \text{ from } \na{V,H}\\
  &\quad r_{x_1} \cap r_{x_2} = \emptyset \tag{$\ms{set}(reach_H(V(x))$}\\
  & \textbf{case: otherwise} \\
  &\quad \text{similar to the above}\\
  &\text{Thus we have } \na{V'',H}\\
  &\emph{(3)}\quad \dist{\{R,F \cup g,locs_{V'',H}(e_2)\}}\\
  &(F \cup g) \cap R = \emptyset \tag{ since $F \cap R = \emptyset$ and by def of $g$}\\
  &\text{NTS } R \cap locs_{V'',H}(e_2) = \emptyset\\
  &\text{Let } l' \in locs_{V'',H}(e_2) \text{ be arb.}\\
  &\textbf{case: }  l' \in reach_{H}(V''(x')) \text{ for some $x' \in FV(e_2)$ where } x' \notin \{x_h,x_t\}\\
  &\quad x' \in V \tag{def of $V''$}\\
  &\quad l' \in reach_{H}(V(x'))\\
  &\quad x' \in FV(e) \tag{def of $FV$}\\
  &\quad l' \in locs_{V,H}(e) \tag{def of $locs_{V,H}$}\\
  &\quad l' \notin R \tag{$\dist{\{R,F,locs_{V,H}(e)\}}$}\\
  &\textbf{case: }  l' \in reach_{H}(V''(x_h)) \\tom
  &\quad l' \in reach_{H}(v_h)\\
  &\quad l' \in reach_{H}(V(x)) \tag{def of $reach$}\\
  &\quad l' \in locs_{V,H}(e) \tag{def of $locs_{V,H}$}\\
  &\quad l' \notin R \tag{since $\dist{\{F,R,locs_{V,H}(e)\}}$}\\
  &\textbf{case: }  l' \in reach_{H}(V''(x_t)) \\
  &\quad \text{similar to above}\\
  &\text{Hence } R \cap locs_{V'',H}(e_2) = \emptyset\\
  &F \cap locs_{V'',H}(e_2) = \emptyset \tag{Similar to above}\\
  &g \cap locs_{V'',H}(e_2) = \emptyset \tag{def. of $g$}\\
  &(F \cup g) \cap locs_{V'',H}(e_2) = \emptyset\\
  &\text{Thus } \dist{\{R,F \cup g,locs_{V'',H}(e_2)\}}\\
  &\text{Instantiating invariant on } J_1,\\
  &\emph{(1)} \quad \ms{set}(reach_{H'}(v))\\
  &\emph{(2)} \quad\dist{\{R,F',reach_{H'}(v)\}}\\
  &\emph{(3)} \quad\stable{R,H,H'}\\
  \end{align*}
  \item [Case 13: E:Drop]
  \begin{align*}
  &e = \irl{drop}(x;e') \tag{case}\\
  &V',H,R,F \cup g \vdash e' \Downarrow v,H',F' (\mathcal{J}_1) \tag{ad.}\\
  &\Gamma = \Gamma',x:A \tag{case}\\
  &\Sigma;\Gamma' \sststile{q'}{q} e' : B\\
  &\text{Suppose } dom(V) = FV(e), \na{V,H},\dist{\{R,F,locs_{V,H}(e)\}}\\
  &\text{By IH, we have invariant on } \mathcal{J}_1\\
  &\text{NTS (1) - (3) for } \mathcal{J}_1\\
  &\emph{(1)} \quad dom(V') = FV(e') \tag{$dom(V) = FV(e)$ and def of $FV$}\\
  &\emph{(2)} \quad \na{V',H} \tag{$\na{V,H}$ and $V' \subseteq V$}\\
  &\emph{(3)} \quad \dist{\{R,F \cup g,locs_{V',H}(e')\}}\\
  &g = reach_H(v') \tag{case}\\
  &g \subseteq locs_{V,H}(e) \tag{def of $locs_{V,H}$}\\
  &R \cap (F \cup g) = \emptyset \tag{$\dist{\{R,F\}}$ and $\dist{\{R,locs_{V,H}(e)\}}$}\\
  &R \cap locs_{V',H}(e') = \emptyset \tag{\dist{\{R,locs_{V,H}(e)\}}$ and $locs_{V',H}(e) \subseteq locs_{V,H}(e)$}\\
  &F \cap locs_{V',H}(e') = \emptyset \tag{\dist{\{F,locs_{V,H}(e)\}}$ and $locs_{V',H}(e) \subseteq locs_{V,H}(e)$}\\
  &g \cap locs_{V',H}(e') = \emptyset \tag{$\na{V,H}$}\\
  &\text{Instantiating invariant on }  \mathcal{J}_1,\\
  &\emph{(1)} \quad \set{reach_{H'}(v)}\\
  &\emph{(2)} \quad \disjoint{\{R,F',reach_{H'}(v)\}}\\
  &\emph{(3)} \quad \stable{R,H,H'}\\
  \end{align*}
  \item [Case 13: E:Share]
  \begin{align*}
  &e = \sharecpcst{x}{x_1}{x_2}{e'} \tag{case}\\
  &\text{Suppose } H \vDash V : \Gamma, dom(V) = FV(e), \na{V,H}, \dist{\{R,F,locs_{V,H}(e)\}} 
		\tag{def. of wfc} \\
	&\text{Let } V_2 = V'[x_1 \mapsto v', x_2 \mapsto v'']\\
	&\text{We show the subsequent computation is also well-formed to invocate the IH:}\\
  &\emph{(1)} \quad dom(V_2) = FV(e') \tag{$dom(V) = FV(e)$ and def of $FV$}\\
  &\emph{(2)} \quad \na{V'[x_1 \mapsto v', x_2 \mapsto v''],H}
	&\quad \na{V'[x_1 \mapsto v']} \tag{$\na{V,H}$}\\
  &\quad \text{Let } x' \mapsto v''' \in V'[x_1 \mapsto v']. 
		\text{STS } reach_{H'}(v''') \cap reach_{H'}(v'') = \emptyset\\
	&\quad reach_{H'}(v'') \subseteq L \subseteq F \tag{lemma about copy}\\
	&\quad reach_{H'}(v''') \subseteq locs_{V'[x_1\mapsto v'],H'}(e') \subseteq locs_{V,H}(e) 
		\tag{stability lemma for copy}\\ 
	&\quad \text{but since } $F \cap locs_{V,H}(e) = \emptyset$, \text{we have the result.}
		 \tag{$\wfc{V}{H}{R}{F}{e}$}\\
  &\emph{(3)} \quad \dist{\{R,F \setminus L,locs_{V_2,H'}(e')\}}\\
	&\quad \text{Disjointedness involving $F$ follows from assumption. Last one follows since }
		$locs_{V_2,H'}(e') \subseteq \locs_{V,H}(e) \cup L$\\
	&\text{By IH:}
  &\emph{(1)} \quad \set{reach_{H''}(v)}\\
  &\emph{(2)} \quad \disjoint{\{R,F',reach_{H''}(v)\}}\\
  &\emph{(3)} \quad \stable{R,H',H''}\\
	&\text{STS } \stable{R,H,H'}, \text{ which follows from $L \cap R = \emptyset$ and stability for copy}\\
  \end{align*}
  \end{description}
\end{proof}
\fi

To formally state the soundness theorem (and later the equivalence of free and copy semantics), we need the notion
of context equivalence. Here we define it for contexts, which consisting of only the stack and heap. Later, 
we extend it the the full configuration. First, define \emph{value} equivalence: 

\begin{definition}[Value Equivalence]
Two values $v_1,v_2$ are equivalent (with the presupposition that they are well-formed w.r.t heaps $H_1,H_2$),
iff $H_1 \vDash v_1 \mapsto a : A$ and $H_2 \vDash v_2 \mapsto a : A$. 
Write value equivalence as $\veq{H_1}{H_2}{v_1}{v_2}$.
\end{definition}

\begin{definition}[Context Equivalence]
Two simple contexts $(V_1,H_1), (V_2,H_2)$ are equivalent
(with the presupposition that both are well-formed contexts) iff $dom(V_1) = dom(V_2)$ and 
for all $x \in dom(V_1)$, $\veq{H_1}{H_2}{V_1(x)}{V_2(x)}$. Write context equivalence as 
$\ctxeq{V_2,H_2}{V_2,H_2}$
\end{definition}

Stated simply, two contexts are equivalent when they have the same domain and equal variables bind equal 
semantic values.

\begin{theorem}[Soundness]
\label{b} let $H \vDash V : \Gamma$, $\Sigma; \Gamma \sststile{q'}{q} e : B$,
$V,H \; \vdash e \Downarrow v, H'$, and $H' \vDash v \mapsto a : A$.
Then $\forall C \in \mathbb{Q}^{+}$ and $\forall F,R \subseteq \ms{Loc}$,
given the following (existence lemma):
\begin{enumerate} 
\item $\wfc{V}{H}{R}{F}{e}$
\item $|F| \ge \Phi_{V,H}(\Gamma) + q + C$ 
\end{enumerate}
then there exists a context $(W,Y)$, a value $w$, and a freelist $F'$ s.t.
\begin{enumerate}
	\item $\ctxeq{W,Y}{V,H}$
  \item $W,Y,R,F \vdash e \Downarrow w, Y', F'$
	\item $\veq{H'}{Y'}{v}{w}$
  \item $|F'| \ge \Phi_{H'}(v:B) + q' + C$
\end{enumerate}
\end{theorem}

\begin{proof}
Nested induction on the evaluation judgement and the typing judgement.\\
\begin{description}
  \item[Case 1: E:Var]
  \begin{align*}
  &V,H \; \vdash x \Downarrow V(x),H \tag{admissibility}\\
  &\Sigma; x : B \sststile{q}{q} x : B \tag{admissibility}\\
	&\text{Let } C \in \mathbb{Q}^+, F,R \subseteq \ms{Loc} \text{ be arb.}\\
	&\text{Suppose this eval-config is well-formed, and further, } |F| \ge \Phi_{V,H}(x : B) + q + C\\
	&\text{Let } F' = F. \text{ Then }\\
	&V,H,R,F \vdash e \Downarrow V(x),H,F' \tag{E:Var}\\
	&\text{And we have } F' = F \ge \Phi_{V,H}(x : B) + q + C\\
	&\quad = \Phi_{H}(V(x) : B) + q + C \tag{definition of $\Phi$}\\
  \end{align*}
  \item[Case 2: E:Const*]
  Due to similarity, we show only for E:ConstI
  \begin{align*}
  &|F| - |F'| = |F| - |F| \tag{ad.}\\
  &\quad = 0\\
  &\Phi_{V,H}(\Gamma) +q - (\Phi_{H'}(v:B) + q') = \Phi_{V,H}(\emptyset) +q - (\Phi_{H}(v:int) + q) \tag{ad.}\\
  &\quad = 0 \tag{def of $\Phi_{V,H}$}\\
  &|F| - |F'| \le \Phi_{V,H}(\Gamma) +q - (\Phi_{H'}(v:B) + q')
  \end{align*}
  \item[Case 4: E:App]
  \item[Case 5: E:CondT]
  \begin{align*}
  &\Gamma = \Gamma', x : \irl{bool} \tag{ad.}\\
  &H \vDash V : \Gamma' \tag{def of W.F.E}\\
  &\Sigma; \Gamma' \sststile{q'}{q} e_t : B \tag{ad.}\\
  &V,H,R,F \cup g\; \vdash e_t \Downarrow v, H',F' \tag{ad.}\\
  &|F \cup g| - |F'| \le \Phi_{V,H}(\Gamma) +q - (\Phi_{H'}(v:B) + q') \tag{IH}\\
  &|F| - |F'| \le \Phi_{V,H}(\Gamma) +q - (\Phi_{H'}(v:B) + q') \\
  \end{align*}
  \item[Case 6: E:CondF] 
  Similar to E:CondT
  \item[Case 7: E:Let]
  \begin{align*}
  &V,H \vdash e \Downarrow v_2,H_2 \tag{case}\\
  &V,H \vdash e_1 \Downarrow v_1,H_1 \tag{ad.}\\
  &\Sigma; \Gamma_1 \sststile{p}{q} e_1 : A \tag{ad.}\\
  &H \vDash V_1 : \Gamma_1 \tag{def of W.D.E}\\
  &\text{Let } C \in \mathbb{Q}^+, F,R \subseteq \ms{Loc} \text{ be arb.}\\
  &\text{Suppose }  dom(V) = FV(e),\na{V,H}, \dist{\{R,F,locs_{V,H}(e)\}}, \text{ and } |F| \ge \Phi_{V,H}(\Gamma) + q + C\\
  &\text{NTF } F' \text{ s.t. }\\
  &\quad 1. V,H,R,F \vdash e \Downarrow v_2, H_2,F' \text{ and }\\ 
  &\quad 2. |F'| \ge \Phi_{H_2}(v_2:B) + q' + C\\
  &\text{Let } R' = R \cup locs_{V,H}(\irl{lam}(x : \tau.e_2))\\
  &\dist{\{R',F,locs_{V,H}(e_1)\}} \tag{Similar to case in Lemma $~\ref{itm:na}$}\\
  &\text{Instantiate IH with } C = C + \Phi_{V_2,H}(\Gamma_2), F = F, R = R', \text{ we get existence lemma on } J_1:\\
  &\text{NTS (1) - (4) to instantiate existence lemma on } J_1\\
  &\emph{(1)} \quad dom(V_1) = FV(e_1)\\
  &\emph{(2)} \quad \na{V_1,H}\\
  &\emph{(3)} \quad \dist{\{R,F,locs_{V,H}(e)\}} \tag{(1) - (3) all verbatim as in Lemma $~\ref{itm:na}$}\\
  &\emph{(4)} \quad |F| \ge \Phi_{V_1,H}(\Gamma_1) + q + C + \Phi_{V,H}(\Gamma_2) \tag{$|F| \ge \Phi_{V,H}(\Gamma) + q + C$ and $\Phi_{V,H}(\Gamma) \ge \Phi_{V_1,H}(\Gamma_1) + \Phi_{V,H}(\Gamma_2)$}\\
  &\text{Instantiating existence lemma on } J_1, \text{ we get }  F'' \text{ s.t. }\\
  &\quad 1. V,H,R',F \vdash e_1 \Downarrow v_1, H_1,F'' \text{ and }\\ 
  &\quad 2. |F''| \ge \Phi_{H_1}(v_1:A) + p + C + \Phi_{V_2,H_1}(\Gamma_2)\\
  &\text{For the second premise: }\\
  &\Sigma; \Gamma_2, x : A \sststile{q'}{p} e_2 : B \tag{ad.}\\
  &H_1 \vDash v_1 : A \text{ and } \tag{Theorem 3.3.4}\\ 
  &H_1 \vDash V : \Gamma_2 \tag{???}\\
  &H_1 \vDash V' : \Gamma_2, x : A \tag{def of $\vDash$}\\
  &V',H_1 \vdash e_2 \Downarrow v_2,H_2 \tag{ad.}\\
  &\text{Let } g = \{l \in H_1 \mid l \notin F_1 \cup R \cup locs_{V',H_1}(e_2)\}\\ 
  &\text{Instantiate IH with } C = C, F = F'' \cup g, R = R, \text{ we get existence lemma on  } J_2:\\
  &\text{NTS (1) - (4) to instantiate existence lemma on } J_1\\
  &\emph{(1)} \quad dom(V_2') = FV(e_2)\\
  &\emph{(2)} \quad \na{V_2',H_1} \\
  &\emph{(3)} \quad \dist{\{R,F'' \cup g,locs_{V_2',H_1}(e_2)\}} \tag{(1) - (3) all verbatim as in Lemma $\ref{itm:na}$}\\
  &\emph{(4)} \quad |F'' \cup g| \ge \Phi_{V_2',H_1}(\Gamma_2,x: (\cf{A} - 1)) + p + C\\
  &\quad \text{STS } |F'' \cup g| \ge \Phi_{V_2,H_1}(\Gamma_2) + \Phi_{H_1}(v_1 : (\cf{A} - 1)) + p + C\\
  &\quad |F'' \cup g| \ge \ssize{H}{V_1} + |F| - \ssize{H_1}{v_1} \tag{conservation lemma}\\
  &\quad \ge \Phi_{V,H}(\Gamma) + q + C + \ssize{H}{V_1} - \ssize{H_1}{v_1} 
    \tag{$|F| \ge \Phi_{H}(V) + q + C$ }\\
  &\quad \text{STS } \Phi_{V_1,H}(\Gamma_1) + q + C \ssize{H}{V_1} - \ssize{H_1}{v_1} \ge \Phi_{H_1}(v_1 : (\cf{A} - 1)) + p + C\\
  &\quad \Phi_{V_1,H}(\Gamma_1) \ge \Phi_{H_1}(v_1 : (\cf{A} - 1)) \tag{lemma about cf typing}\\
  &\quad \text{STS } \ssize{H}{V_1} - \ssize{H_1}{v_1} + q \ge p \tag{done by aux lemma}\\
  &\text{Instantiating existence lemma on } J_2, \text{ we get } F^{(3)} \text{ s.t. }\\
  &\quad 1. V_2',H_1,R, F'' \cup g \vdash e_2 \Downarrow v_2,H_2,F^{(3)} \\
  &\quad 2. |F^{(3)}| \ge \Phi_{H_2}(v_2:B) + q' + C\\
  &\text{Take } F' = F^{(3)}\\
  &V,H,R,F \vdash e \Downarrow v_2, H_2,F' \text{ and } \tag{E:Let}\\ 
  &|F'| \ge \Phi_{H_2}(v_2:B) + q' + C \tag{from IH}\\
  \end{align*}
	\item[Case 8: E:Pair]
  Similar to E:Const*
  \item[Case 9: E:MatP]
  Similar to E:MatCons
  \item[Case 10: E:Nil]
  Similar to E:Const*
  \item[Case 11: E:Cons]
  \begin{align*}
  &V,H \vdash \consexabt{x_1}{x_2} \Downarrow l, H' \tag{case}\\
  &\text{Let } C \in \mathbb{Q}^+, F,R \subseteq \ms{Loc} \text{ be arb.}\\
  &\text{Suppose } dom(V) = FV(e), \na{V,H}, \dist{\{R,F,locs_{V,H}(e)\}}, |F| \ge \Phi_{V,H}(\Gamma) + q + C\\
  &\text{NTF } F' \text{ s.t. }\\
  &\quad 1. V,H,R,F \vdash e \Downarrow v, H',F' \text{ and }\\ 
  &\quad 2. |F'| \ge \Phi_{H'}(v:B) + q' + C\\
  &\text{Let } F' = F \ 
  \end{align*}
  \item[Case 12: E:MatNil]
  Similar to E:Cond*
  \item[Case 13: E:MatCons]
  \begin{align*}
  &V(x) = (l,\irl{alive}) \tag{ad.}\\
  &H(l) = \pairexcst{v_h}{v_t} \tag{ad.}\\
  &\Gamma = \Gamma', x : L^p(A) \tag{ad.}\\
  &\Sigma; \Gamma', x_h : A, x_t : L^p(A) \sststile{q'}{q + p + 1} e_2 : B \tag{ad.}\\
  &V'',H \; \vdash e_2 \Downarrow v, H' \tag{ad.}\\
  &\text{Let } C \in \mathbb{Q}^+, F,R \subseteq \ms{Loc} \text{ be arb.}\\
  &H \vDash V(x) : L^p(A) \tag{def of W.D.E}\\
  &H''\vDash v_h : A,\; H'' \vDash v_t : L^p(A) \tag{ad.}\\
  &H\vDash v_h : A,\; H \vDash v_t : L^p(A) \tag{???}\\
  &H \vDash V'' : \Gamma', x_h : A, x_t : L^p(A) \tag{def of W.D.E}\\
  &\text{Suppose }  \na{V,H}, \dist{\{R,F,locs_{V,H}(e)\}}, \text{ and } |F| \ge \Phi_{V,H}(\Gamma) + q + C\\
  &\text{NTF } F' \text{ s.t. }\\
  &\quad 1. V,H,R,F \vdash e \Downarrow v, H',F' \text{ and }\\ 
  &\quad 2. |F'| \ge \Phi_{H'}(v:B) + q' + C\\
  &\text{Let } g = \{l \in H \mid l \notin F \cup R \cup locs_{V'',H}(e_2)\}\\
  &\text{We want to $g$ nonempty, in particular, that } l \in g\\
  &\quad l \notin F \cup R \tag{$\dist{\{R,F,locs_{V,H}(e)\}}$}\\
  &\quad \text{AFSOC } l \in locs_{V'',H}(e_2)\\
  &\quad \text{Then } l \in reach_H(\overline V'' (x')) \text{ for some } x' \ne x\\
  &\quad x' \in \{x_h,x_t\} \tag{since $reach_H(\overline V (x')) \cap reach_H(\overline (Vx)) = \emptyset$ from $\na{V,H}$}\\
  &\quad \text{WLOG let } x' = x_h\\
  &\quad \text{But then } \mu_{reach_H(\overline V(x))}(l) \ge 2 \text{ and } \ms{set}(reach_(\overline V(x))) \text{ doesn't hold}\\
  &\quad l \notin locs_{V'',H}(e_2)\\
  &\text{Hence } l \in g\\
	&\text{Next, we have } \na{V'',H} \text{ and } \dist{\{R,F \cup g,locs_{V'',H}(e_2)\}} \tag{similar to case in Lemma 1.2}\\
	&\text{By IH with } C' = C, F'' = F \cup g \text{ and the above conditions, we have: } F^{(3)} \text{ s.t.}\\
	&\quad 1. V'',H,R,F\cup g \vdash e_2 \Downarrow v,H',F^{(3)}\\
	&\quad 2. |F^{(3)}| \ge \Phi_{H'}(v:B) + q' + C\\
	&\text{Where we also verify the precondition that } |F''| \ge \Phi_{V'',H}(\Gamma',x_h:A,x_t:L^p(A)) + q + p + 1 + C':\\
	&\quad |F''| = |F \cup g|\\
	&\quad \quad = |F| + |g| \tag{$F$ and $g$ disjoint}\\
	&\quad \quad \ge \Phi_{V,H}(\Gamma) + q + C + |g| \tag{Sp.}\\
	&\quad \quad = \Phi_{V,H}(\Gamma',x_h:A,x_t:L^p(A)) + p + q + C + |g| \tag{Lemma 4.1.1}\\
	&\quad \quad = \Phi_{V,H}(\Gamma',x_h:A,x_t:L^p(A)) + p + q + C + 1 \tag{$g$ nonempty}\\
	&\text{Now take } F' = F^{(3)}\\
	&V,H,R,F \; \vdash e \Downarrow v,H',F' \tag{E:MatCons}\\
  &|F'| \ge \Phi_{H'}(v:B) + q' + C \tag{From the IH}\\
  \end{align*}
  \item[Case 14: E:Share]
	\begin{align*}
	&V,H \vdash e \Downarrow v,H'' \tag{case}\\
	&V'[x_1 \mapsto v',x_2 \mapsto v''], H' \vdash e' \Downarrow v,H'' \tag{ad}\\
	&\Sigma;\Gamma,x:A \sststile{q'}{q} e : B \tag{case}\\
	&A \curlyvee A_1,A_2,1 \tag{ad.}\\
	&\Sigma; \Gamma,x_1:A_1,x_2:A_2 \sststile{q'}{q} e : B \tag{ad.}\\
  &\text{Let } C \in \mathbb{Q}^+, F,R \subseteq \ms{Loc} \text{ be arb.}\\
  &\text{Suppose }  \na{V,H}, \dist{\{R,F,locs_{V,H}(e)\}}, \text{ and } |F| 
		\ge \Phi_{V,H}(\Gamma,x:A) + q + C\\
  &\text{NTF } F'' \text{ s.t. }\\
  &\quad 1. V,H,R,F \vdash e \Downarrow v, H'',F'' \text{ and }\\ 
  &\quad 2. |F''| \ge \Phi_{H''}(v:B) + q' + C\\
	&\text{We need to show the freelist is sufficient for the subsequent computation to invoke the IH:}\\
	&\text{Instantiate with } C, F \setminus L, \text{and} R\\
	&\text{STS } |F\setminus L| \ge \Phi_{V_2, H'}(\Gamma,x_1 : A_1,x_2 : A_2) + q + C\\
	&\quad \iff |F| - |L| \ge \Phi_{V_2,H'}(\Gamma) + 
			\Phi_{V_2,H'}(x_1 : A_1) + \Phi_{V_2,H'}(x_2 : A_2) + q + C\\
	&\quad \iff |F| \ge \Phi_{V_2,H'}(\Gamma) + 
			\Phi_{V_2,H'}(x_1 : A_1) + \Phi_{V_2,H'}(x_2 : A_2) + \ssize{H}{v'} + q + C\\
	&\quad \iff |F| \ge \Phi_{V_2,H'}(\Gamma) + 
			\Phi_{V,H}(x : A) + q + C \tag{definition of sharing relation}\\
	&\quad \iff |F| \ge \Phi_{V,H}(\Gamma,x:A) + q + C \tag{stability of copying}\\
	&\quad \text{done from assumption}\\
	&\text{By IH, we get } F'' \text{ fulfilling the previous two points for the case. }\\
	\end{align*}
  \end{description}
\end{proof}

\section{Copy-free garbage collection semantics}

Consider the GC semantics (from now on $\mathsf{copy}$ semantics) above,
with the share rule replaced with the following: 

\begin{mathpar}
\inferr{
  V,H,R,F \; \vdash \sharecst{x}{x_1}{x_2}{e} \Downarrow v,H'',F'
}{
  V = V'[x \mapsto v']\\
  V'[x_1 \mapsto v',x_2 \mapsto v'],H',R,F \; \vdash e \Downarrow v,H'',F'
}(\text{F:Share})
\end{mathpar}

Call this new semantics $\mathsf{free}$ semantics for copy-free (all rules are renamed to F:\_ for free). 
It is easy to see that any terminating compuation
in $\mathsf{copy}$ has a corresponding one in $\mathsf{free}$ that can be instantiated with 
an equal or smaller freelist. Before formalizing this idea, we extend context equivalence to a preorder on 
configurations: 

\begin{definition}[Compute Potential]
Given a configuration $\mathcal{C} = V,H,R,F$, define the \emph{compute potential} 
of the configuration $\kappa$ as $|F| + |H \setminus F|$.
\end{definition}

\begin{lemma}[Compute Invariance (copy)]
If $V,H,R,F \vdash^{\mathsf{copy}} e \Downarrow v,H',F'$, then $\kappa(H,F) = \kappa(H',F')$.
\end{lemma}

\iffalse
\begin{proof}
Induction on the evaluation judgement.\\
\begin{description}
  \item[Case 1: E:Var]
  \begin{align*}
		&V,H,R,F \vdash^{\mathsf{copy}} e \Downarrow V(x),H,F \tag{case}\\
		&\kappa(H,F) = \kappa(H,F)
  \end{align*}
  \item[Case 2: E:Const*]
	Similar to E:Var.
  \item[Case 4: E:App]
  \begin{align*}
	&V,H,R,F \vdash \appcst{f}{x} \Downarrow v,H',F' \tag{case}\\
  &V'[y_f \mapsto v'],H,R,F \cup g \vdash e_f \Downarrow v,H',F' \tag{case}\\
	&\kappa(H,F\cup g) = \kappa(H',F') \tag{IH}\\
	&\kappa(H,F \cup g) = |F \cup g| + |H \setminus (F \cup g)| \tag{Def. compute potential}\\
	&\quad = |F| + |H \setminus F| \tag{$F \cap g = \emptyset$ and $g \subseteq H$}\\
	&\quad = \kappa(H,F)\\
	&\kappa(H,F) = \kappa(H',F')\\
  \end{align*}
  \item[Case 5: E:CondT]
	Similar to E:App
  \item[Case 6: E:CondF] 
  Similar to E:CondT
  \item[Case 7: E:Let]
  \begin{align*}
  &V,H,R,F \; \vdash \irl{let}(e_1; x : \tau.e_2) \Downarrow v_2,H_2,F_2 \tag{case}\\
	&V_1,H,R',F \vdash e_1 \Downarrow v_1,H_1,F_1 \tag{case}\\
	&\kappa(H,F) = \kappa(H_1,F_1) \tag{IH}\\
  &V_2',H_1,R, F_1 \cup g \vdash e_2 \Downarrow v_2,H_2,F_2 \tag{case}\\
	&\kappa(H_1, F_1 \cup g) = \kappa(H_2,F_2) \tag{IH}\\
	&\kappa(H_1, F_1 \cup g) = |F_1 \cup g| + |H_1 \setminus (F_1 \cup g)| \tag{Def. compute potential}\\
	&\quad = |F_1 \cup g| + |(H_1 \setminus F_1) \cap (H_1 \setminus g)|\\
	&\quad = |F_1 \cup g| + |(H_1 \setminus F_1) \setminus g|\\
	&\quad = |F_1| + |g| + |H_1 \setminus F_1| - | g| \tag{$F \cap g = \emptyset$ and $g \in H_1$}\\
	&\quad = |F_1| + |H_1 \setminus F_1| \\
	&\quad = \kappa(H_1,F_1)\\
	&\kappa(H,F) = \kappa(H_2,F_2)
  \end{align*}
	\item[Case 8: E:Pair]
  Similar to E:Const*
  \item[Case 9: E:MatP]
  Similar to E:App
  \item[Case 10: E:Nil]
  Similar to E:Const*
  \item[Case 11: E:Cons]
  \begin{align*}
	&\kappa(H,F) = |F| + |H \setminus F| \tag{Def. compute potential}\\
	&\kappa(H', F \setminus \{l\}) = |F \setminus \{l\}| + |H' \setminus (F \setminus \{l\})|
				\tag{Def. compute potential}\\
	&\quad = (|F| - 1) + (|H' \setminus F| + 1)\\
	&\quad = |F| + |H' \setminus F|\\
	&\textbf{case } l \in H: \\
	&|H'| = |H| \tag{Def. replacement}\\
	&\kappa(H',F \setminus \{l\}) = |F| + |H \setminus F| = \kappa(H,F)\\
	&\textbf{case } l \notin H: \\
	&H' \setminus F = H \setminus F \tag{$l \notin H$ and $l \in F$}\\
	&|F| + |H' \setminus F| = |F| + |H \setminus F|\\
	&\kappa(H',F \setminus \{l\}) = |F| + |H \setminus F| = \kappa(H,F)\\
  \end{align*}
  \item[Case 12: E:MatNil]
  Similar to E:App
  \item[Case 13: E:MatCons]
	Similar to E:App
  \item[Case 14: E:Share]
	\begin{align*}
		&V,H,R,F \; \vdash \sharecpcst{x}{x_1}{x_2}{e} \Downarrow v,H'',F' \tag{case}\\
 		&V_2,H',R,F \setminus L \; \vdash e \Downarrow v,H'',F' \tag{case}\\
		&\kappa(H',F \setminus L) = \kappa(H'',F') \tag{IH}\\
		&\kappa(H',F \setminus L) = |F \setminus L| + |H' \setminus (F \setminus L)| \tag{Def. compute potential}\\
		&\quad = |F| + |H' \setminus F| \tag{Set algebra}\\
		&\text{NTS } H' \setminus F = H \setminus F \\
		&\text{Let } l \in H' \setminus F\\
		&l \in H', l \notin F \\
		&l \in H \cup L \tag{Locality of copy}\\
		&\textbf{case } l \in H: \text{ done }\\
		&\textbf{case } l \in L: \text{ contradiction  since } L \subseteq F\\
		&\text{Hence } l \in H\\
		&\text{Let } l \in H \setminus F\\
		&l \in H, l \notin F \\
		&l \in H' \tag{Monotonicity of copy}\\
		&\text{Thus } H' \setminus F = H \setminus F \\
		&\kappa(H',F \setminus L) = |F| + |H \setminus F|\\
	\end{align*}
  \end{description}
\end{proof}

\begin{lemma}[Compute Invariance (free)]
If $V,H,R,F \vdash^{\mathsf{free}} e \Downarrow v,H',F'$, then $\kappa(H,F) = \kappa(H',F')$.
\end{lemma}

\begin{proof}
Same proof as for the copy semantics, except the share case, which proceed similar to E:App.
\end{proof}

\begin{lemma}[Collect Preservation]
If $g \in dom(H)$ and $F \cap g = \emptyset$, then $\kappa(H,F \cup g) = \kappa(H,F)$.
\end{lemma}

\begin{proof}
\begin{align*}
&\kappa(H,F\cup g) = |F \cup g| + |H \setminus (F \cup g)| \tag{Def. compute potential}\\
&\quad = |F \cup g| + |(H \setminus F) \cap (H \setminus g)|\\
&\quad = |F \cup g| + |(H \setminus F) \setminus g|\\
&\quad = |F| + |g| + |H \setminus F| - |g| \tag{$g \in dom(H)$ and $F \cap g = \emptyset$}\\
&\quad = |F| + |H \setminus F|\\
&\quad = \kappa(H,F)
\end{align*}
\end{proof}
\fi

For each pair of structurally equivalent values $\veq{H}{H'}{v}{v'}$, there is an induced bijection between
the reach locations of each respective value that serves as the evidence for their structural equivalence.
We give the representative rules:

\begin{mathpar}
\inferrule{
	m_1 : \veq{H}{H'}{v_1}{v_1'}\\
	m_2 : \veq{H}{H'}{v_2}{v_2'}
}{
	m_1 \uplus m_2 : \veq{H}{H'}{\pairexcst{v_1}{v_2}}{\pairexcst{v_1'}{v_2'}}
}(\text{M:Pair})

\inferrule{
	m : \veq{H}{H'}{H(l)}{H(l')}
}{
	m \uplus \{l \to l'\} : \veq{H}{H'}{l}{l'}
}(\text{M:Loc})
\end{mathpar}

Extending to a context, we write $L : V_1,H_1 \sim V_2,H_2$ if for all $x \in dom(V_1)$, 
$L(x) : \veq{H_1}{H_2}{V_1(x)}{V_2(x)}$.\\

\begin{definition} A configuration $(V,H,R,F)$ is well-formed if $dom(H) \subseteq reach_H(V) \cup R \cup F$.
\end{definition}

Now consider two well-formed configurations $\mathcal{C}_1 = (V_1,H_1,R_1,F_1),
 \mathcal{C}_2 = (V_2,H_2,R_2,F_2)$.\\

We define the induced mapping
$\gamma : dom(H_1) \setminus F_1 \to \mathcal{P}(dom(H_2) \setminus F_2)$ 
between $\mathcal{C}_1, \mathcal{C}_2$ from $L$: $\gamma(l) = (\biguplus_{x \in dom(V_1)} L(x)) (l)$.
Note that by construction, for any $l$, $\gamma(l)$ is nonempty, and thus we can choose an arbitrary 
$l' \in \gamma(l)$ to be the representation for that part; call this $rep(l)$.\\

A mapping $f : A \to \mathcal{P}(B)$ is a \emph{partition} on $B$ the image of 
$A$ forms a disjoint union of $B$ 
(e.g. $\forall x,y \in A, f(x) \cap f(y) = \emptyset \land \bigcup f(A) = B$). Furthermore,
a partition is \emph{proper} if for any $x \in A$, $f(x) \neq \emptyset$.\\

A simple corollary is the fact that if $V_2,H_2$ is a linear context (e.g. $\na{V_2,H_2}$ holds), then
$|\gamma(l)| = |(reach_{H_1}(V_1))(l)|$, where $ reach_{H_1}(V_1) = \biguplus_{x \in dom(V)} reach_{H_1}(x)$. 
In general for a multiset $S$, when this holds, we say that 
$\gamma$ is a \emph{counting partition} for $S$.\\

For a partition $f : A \to \mathcal{P}(B)$, we write the set of equivalence classes
as $ec(f) = \{f(x) \mid x \in A\} = f(A)$, i.e. the image of $f$ on its domain $A$.\\

For an evaluation $\mathcal{C} = (V,H,R,F) \vdash e \Downarrow v,H',F'$, denote its
garbage collection
as $collect(R,v,H',F') = \{l \in H' \mid l \notin F' \cup R \cup reach_H'(v)\}$.

\begin{definition}
	Let \ms{dir} be the set \{\ms{L},\ms{R},\ms{N}\}, denoting left, right, and next 
	respectively. We can index values via directions:
	\begin{align*}
		get_H(Just(\pairexcst{v_1}{v_2},\ms{L})) &= Just(v_1)\\
		get_H(Just(\pairexcst{v_1}{v_2},\ms{R})) &= Just(v_2)\\
		get_H(Just(\pairexcst{v_1}{v_2}),_) &= None\\
		get_H(Just(l),\ms{N}) &= Just(H(l)) \\
		get_H(Just(l), \_) &= None\\
		get_H(r,\_) &= r
	\end{align*}
	Let $P$ be a sequence of directions. Extend $get$ to sequence of directions:
	\begin{align*}
		find_H(v,D::P) &= find_H(get_H(v,D),P)\\
		find_H(v,[]) &= v
	\end{align*}
	Call $P$ valid w.r.t a value $v$ if $find_H(v,P) = Just (v')$ for some $v'$.
	Write $V_H(x;P)$ for $fromJust(find_H(V(x),P))$ given a valid sequence $P$ w.r.t $V(x)$,
	and $reach_H(V(x;P))$ for $reach_H(V_H(x;P))$.
	Given a map $m : X \to \mathcal{S}(\ms{dir})$ from varibles to valid sequences of directions, 
	Define $reachPath_{V,H}(X,m) = \biguplus_{x \in X} reach_H(V(x;m(x)))$.
	
\end{definition}

\begin{lemma}
	Let $V_1,H_1 \sim V_2,H_2$. Then for all $x \in dom(V_1)$ and sequence of directions $P$, 
	Either $find_{H_1}(V_1(x),P) = find_{H_2}(V_2(x),P) = None$ or 
	$find_{H_1}(V_1(x),P) = v_1$, $find_{H_2}(V_2(x),P) = v_2$ and
	$\veq{H_1}{H_2}{v_1}{v_2}$
\end{lemma}

\begin{proof}
	Induction on length of $P$ and then $H \vdash v \mapsto a : A$.
\end{proof}

\begin{definition}
A configuration $\mathcal{C}_2 = (V_2,H_2,R_2,F_2)$ is a \emph{copy extension} of another configuration
$\mathcal{C}_1 = (V_1,H_1,R_1,F_1)$ iff
\begin{enumerate}
\item $V_1,H_1 \sim V_2,H_2$
\item There is a proper partition $\gamma : dom(H_1) \setminus F_1 \to \mathcal{P}(dom(H_2) \setminus F_2)$ 
such that for all $l \in dom(\gamma)$, $|\gamma(l)| = reach_{H_1}(V_1)(l) + R_1(l)$
\item for all $l \in dom(\gamma)$, $x \in dom(V_1)$, valid sequence of directions $P$ w.r.t $V_1(x)$,
	$|reach_{H_2}(V_2(x;P)) \cap \gamma(l)| = reach_{H_1}(V_1(x;P))(l)$.
\item $R_1 \subseteq dom(H_1) \setminus F_1$ and 
	for all $l \in R_1$, $|\gamma(l) \cap R_2| = R_1(l)$
\item $|F_1| = |F_2| + |\oh{\gamma}|$, where 
	$\oh{\gamma} = \bigcup_{P \in ec(\gamma)} P \setminus (rep(P))$
\end{enumerate}
Write this as $\mathcal{C}_1 \preceq \mathcal{C}_2$.
\end{definition} 

Note that $\preceq$ is reflexive. Now the key lemma:

\begin{lemma}
	Let $(\mathcal{C}_2,e)$ be a linear computation. Given that 
	$\mathcal{C}_2 \vdash^{\mathsf{copy}} e \Downarrow v,H',F'$, and $H' \vDash v \mapsto a : A$, 
	for all well-formed configurations $\mathcal{C}_1$ such that $\mathcal{C}_1 \preceq \mathcal{C}_2$,
there is exists a triple
$(w,Y',M') \in \ms{Val} \times \ms{Heap} \times \ms{Loc}$ and 
	$\gamma' : dom(Y') \setminus M' \to \mathcal{P}(dom(H') \setminus F')$ s.t.
	\begin{enumerate}
			\item $\mathcal{C}_1 \vdash^{\mathsf{free}} e \Downarrow w,Y',M'$
			\item $\veq{H'}{Y'}{v}{w}$
			\item $\gamma'$ is a proper partition, such that for all $l \in dom(\gamma')$, 
				$|\gamma'(l)| = |reach_{Y_1}(w_1)(l)| + S(l)$
			\item For all $P$, $|reach_{H'}(find_{H'}(v;P)) \cap \gamma'(l)| = 
				reach_{Y'}(find_{Y'}(w;P))(l)$
			\item $\gamma'(l) \cap R = \gamma(l) \cap R$
			\item $|M'| = |F'| + |\oh{\gamma'}|$
	\end{enumerate}
\end{lemma}

For a configuration $\mathcal{C} = (V,H,R,F)$, denote the current garbage w.r.t a set of root variables 
$X \subseteq dom(V)$ 
as $clean(\mathcal{C},L) = \{l \in H \mid l \notin F \cup R \cup L\}$. Some auxiliary lemmas: 

\begin{lemma}\label{itm:aux}
Let $V_2,H_2,R_2,F_2 \vdash^{\mathsf{copy}} e \Downarrow v,H',F'$, and 
$V_1,H_1,R_1,F_1 \preceq V_2,H_2,R_2,F_2$ because $(-,\gamma,\eta,-,-)$. Then the following hold:
for all $l \in dom(H_1) \setminus F_1$, 
	$X \subseteq dom(V)$, $m : X \to \mathcal{S}(\ms{dir})$, 
	$\gamma(l) \subseteq clean(\mathcal{C}_2,reachPath_{V_2,H_2}(X,m))$ implies that 
	$l \in clean(\mathcal{C}_1,reachPath_{V_1,H_1}(X,m))$.
\end{lemma}

\begin{proof}
	\begin{align*}
		&\gamma(l) \cap (F \cup R \cup reachPath_{V_2,H_2}(X,m)) = 
			\emptyset \tag{definition of $clean$}\\
		&\text{NTS } l \notin F_1 \cup R_1 \cup reach_{H_1}(X)\\
		&\emph{(1) } l \notin F_1 \tag{assumption}\\
		&\emph{(2) } l \notin R_1\\
		&\quad \text{Know } \gamma(l) \cap R_2 = \emptyset\\
		&\quad |\gamma(l) \cap R_2| = R_1(l) = 0 \tag{condition 4. of $\preceq$}\\
		&\quad l \notin R_1\\
		&\emph{(3) } l \notin reachPath_{V_1,H_1}(X,m)\\
		&\quad \text{Know } \gamma(l) \cap reachPath_{V_2,H_2}(X,m) = \emptyset\\
		&\quad \text{Let } x \in X\\
		&\quad \gamma(l) \cap reach_{H_2}(V_2(x,m(x))) = \emptyset\\
		&\quad |\gamma(l) \cap reach_{H_2}(V_2(x,m(x)))| = reach_{H_1}(V_1(x,m(x)))(l) 
			\tag{condition 3. of $\preceq$}\\
		&\quad reach_{H_1}(V_1(x,m(x)))(l) = 0\\
		&\quad reachPath_{V_1,H_1}(X,m)(l) = 0\\
		&\quad l \notin reachPath_{V_1,H_1}(X,m)\\
		&\quad \text{Thus, } l \in clean(\mathcal{C}_1,reachPath_{V_1,H_1}(X,m))
	\end{align*}
\end{proof}
In particular, this means that we can (somewhat obviously), execute a computation using the free semantics
if the computation suceeded with the copy semantics. 

\begin{proof}
Induction on the evaluation judgement.\\
\begin{description}
  \item[Case 1: E:Var]
  \begin{align*}
		&V,H,R,F \vdash^{\mathsf{copy}} e \Downarrow V(x),H,F \tag{case}\\
		&\text{Let } W,Y,S,M \preceq V,H,R,F\\
		&\text{We need to show a triple that satisfies the 3 post-conditions.}\\
		&\text{Take } (w,Y', M') = (W(x),Y,M)\\
		&\emph{(1)}\quad W,Y,S,M \vdash^{\mathsf{free}} e \Downarrow w,Y,M \tag{F:Var}\\
		&\emph{(2)}\quad  \veq{H}{Y'}{V(x)}{w} \tag{Definition of $\sim$}\\
		&\emph{(3)}\quad \kappa(Y,M) = \kappa(H,F) \tag{Definition of cp. ext.}\\
  \end{align*}
  \item[Case 2: E:Const*]
  Due to similarity, we show only for E:ConstI
  \begin{align*}
  \end{align*}
  \item[Case 4: E:App]
  \item[Case 5: E:CondT]
  \begin{align*}
		&V,H,R,F \; \vdash^{\mathsf{copy}} \ifexabt{x}{e_1}{e_2} \Downarrow v, H',F' \tag{case}\\
		&\text{Let } W,Y,S,M \preceq V,H,R,F \\
		&\text{Let } W' = W \restriction_{V'}\\
		&\text{Let } j = \{l \in Y | l \notin M \cup S \cup locs_{W,Y}(e_1) \}\\
		&\text{NTS } W',Y,S,M \cup j \preceq V',H,R,F \cup g\\
		&\emph{(1)}\quad W',Y \sim V',H \tag{$W,Y \sim V,H$}\\
		&\emph{(2)}\quad \text{NTF a proper partition }
		 \gamma' : dom(Y) \setminus (M \sqcup j) \to \mathcal{P}(dom(H)\setminus (F \cup g))  \\
		&\quad \text{Let } \gamma'(l) = \gamma \restriction_{dom(Y)\setminus(M \sqcup j)}(l) \setminus g\\
		&\quad \text{First, show $\gamma'$ is a partition}\\
		&\quad \text{Let } l, l' \in dom(Y) \setminus (M \sqcup j)\\
		&\quad \gamma'(l) \cap \gamma'(l') = \emptyset \tag{$\gamma$ is partition}\\
		&\quad \gamma'(dom(Y) \setminus (M \sqcup j)) = \gamma(dom(Y) \setminus (M \sqcup j)) \setminus g\\
		&\quad = (\bigsqcup_{l \in dom(Y) \setminus M} \gamma(l) \setminus \bigsqcup_{l \in j} \gamma(l)) 
			\setminus g\\
		&\quad = ((dom(H) \setminus F) \setminus (\bigsqcup_{l \in j} \gamma(l))) \setminus g 
			\tag{$\gamma$ is partition}\\
		&\quad = (dom(H) \setminus F) \setminus g \tag{$\bigsqcup_{l \in j} \gamma(l) \subseteq g$}\\
		&\quad = dom(H) \setminus (F \sqcup g)\\
		&\quad \text{Hence } \gamma' \text{ is a partition}\\
		&\quad \gamma' \text{ is also proper: }\\
		&\quad \text{Let } l \in dom(Y) \setminus (M \sqcup j)\\
		&\quad \gamma'(l) = \gamma(l) \setminus g\\
		&\quad \text{AFSOC } \gamma(l) \subseteq g\\ 
		&\quad l \in j \tag{By Lemma \ref{itm:aux}}\\
		&\quad \text{Contradiction since assumed } l \notin j\\ 
		&\quad \text{Now, NTS } |\gamma'(l)| = reach_{Y}(W')(l) + S(l)
		&\quad \text{Let } l \in dom(\gamma')\\
		&\quad \gamma'(l) = \gamma(l) \setminus g \tag{definition}\\ 
		&\quad |\gamma'(l)| = |\gamma(l)| - |\gamma(l) \cap g|\\
		&\quad = reach_Y(W)(l) + S(l) - |\gamma(l) \cap g|\\
		&\quad = reach_Y(W)(l) + S(l) - |\gamma(l) \cap g|\\
		&\quad \text{TODO (proof in notebook)}\\
		&\emph{(3)}\quad \text{Let $l \in dom(\gamma'), x \in dom(W')$, 
			$P$ valid sequence w.r.t $W'(x)$. NTS }\\ 
		&|reach_{H}(V'(x;P)) \cap \gamma'(l)| = reach_{Y}(W'(x;P))(l)\\ 
		&\quad \text{STS } |reach_{H}(V'(x;P)) \cap (\gamma(l) \setminus g)| = reach_{Y}(W'(x;P))(l) \\
		&\quad g \cap reach_H(V'(x;P)) = \emptyset \tag{definition of $g$}\\
		&\quad |reach_{H}(V'(x;P)) \cap (\gamma(l) \setminus g)| = 
				|(reach_{H}(V'(x;P)) \setminus g) \cap \gamma(l)|\\
		&\quad = |reach_{H}(V'(x;P)) \cap \gamma(l)|\\
		&\quad = |reach_{H}(V(x;P)) \cap \gamma(l)|\\
		&\quad = reach_{Y}(W(x;P))(l) \tag{condition 3. of $\preceq$}\\
		&\quad = reach_{Y}(W'(x;P))(l) \\
		&\emph{(4)}\quad S \subseteq dom(Y) \setminus (M \cup j) \text{ since } S \cap j = \emptyset\\
		&\quad \text{Let } l \in S \text{. NTS } |\gamma'(l) \cap R| = S(l)\\
		&\quad \text{STS } |(\gamma(l)\setminus g) \cap R| = S(l)\\
		&\quad (\gamma(l)\setminus g) \cap R = \gamma(l) \cap (R \setminus g)\\
		&\quad = \gamma(l) \cap R \tag{$g \cap R = \emptyset$}\\
		&\quad |\gamma(l) \cap R| = S(l) \tag{condition 4. of $\preceq$}\\
		&\emph{(5)}\quad \text{NTS } |M \cup j| = |F \cup g| + |\oh{\gamma'}|\\
		&\quad \text{STS } |M| + |j| = |F| + | g| + |\oh{\gamma'}|\\
		&\quad \text{By assumption }, |M| = |F| + |\oh{\gamma}|\\
		&\quad \text{STS } |j| + |\oh{\gamma}| = |g| + |\oh{\gamma'}|\\
		&\quad \text{NTF a bijection } f : j \oplus \oh{\gamma} \to g \sqcup \oh{\gamma'}\\
		&\quad \text{First, we show that } g = (\bigsqcup_{l \in j} \gamma(l)) \sqcup L \text{ for some } L\\
		&\quad \text{TODO: Show this (old papers)}\\
		&\quad \text{Let } \mathcal{C}_1 = \{\gamma(l) \mid l \in j\},
				\mathcal{C}_2 = ec(\gamma) \setminus \mathcal{C}_1\\
		&\quad \text{Clearly, } \oh{\gamma} = 
		\bigsqcup_{C  \in \mathcal{C}_1} C \setminus rep(C) \sqcup \bigsqcup_{C  \in \mathcal{C}_2} C \setminus rep(C)\\
		&\quad \text{Let } D_1 = \bigsqcup_{C  \in \mathcal{C}_1} C \setminus rep(C), 
		D_2 = \bigsqcup_{C  \in \mathcal{C}_2} C \setminus rep(C)\\
		&\quad \text{We define the bijection } 
			f \text{ by parts: } 
			f_1 : j \oplus D_1 \to \bigsqcup_{C \in \mathcal{C}_2} C, f_2 : D_2 \to L \sqcup \oh{\gamma'}\\
		&\quad f_1(l) =  
		\begin{cases}
			rep(\gamma(l)) &l = (\ms{inl},l')\\
			l' &l = (\ms{inr},l')
		\end{cases}\\
		&\quad \text{Clearly, } f_1 \text{ is a bijection, and } |j| + |D_1| = |\bigsqcup_{C \in \mathcal{C}_1} C\\
		&\quad \text{To avoid the problem of maintaining a single representative for a class (which might be 
		collected), }\\
		&\quad \text{note the following: }\\
		&\quad |\mathcal{C}_2| = |ec(\gamma) \setminus \{\gamma(l) \mid l \in j\}|\\
		&\quad = |ec(\gamma \restriction_{dom(Y) \setminus (M \sqcup j)})|\\
		&\quad = |ec(\gamma')|\\
		&\text{Since both } \gamma,\gamma' \text{ are counting partitions we have the following: }\\
		&|D_2| = |L \sqcup \oh{\gamma'}| = |L \sqcup \bigsqcup_{C \in ec(\gamma')} C \setminus rep(C)| \text{ iff }
		|\bigsqcup_{C  \in \mathcal{C}_2} C| = |L \sqcup \bigsqcup_{C \in ec(\gamma')} C|\\ 
		&\quad \text{In fact, the latter two sets are equal: }\\
		&\quad \text{let } l \in \bigsqcup_{C  \in \mathcal{C}_2} C\\
		&\quad l \in H \setminus F \tag{Def. of partition}\\
		&\quad \textbf{case } l \in g\\
		&\quad\quad l \notin \bigsqcup_{l \in j} \gamma(l) \tag{Def. of $\mathcal{C_2}$}\\
		&\quad\quad l \in L \tag{Def. of $g$}\\
		&\quad\quad l \in L \sqcup \bigsqcup_{C \in ec(\gamma')} C\\
		&\quad \textbf{case } l \notin g\\
		&\quad\quad l \in H \setminus (F \sqcup g)\\
		&\quad\quad \text{Exists } C \in ec(\gamma') \text{ s.t. } l \in C \tag{Def. of partition}\\
		&\quad\quad l \in \bigsqcup_{C \in ec(\gamma')} C\\
		&\quad\quad l \in L \sqcup \bigsqcup_{C \in ec(\gamma')} C\\
		&\quad\text{For the other direction, let } l \in L \sqcup \bigsqcup_{C \in ec(\gamma')} C\\
		&\quad\textbf{case } l \in L\\
		&\quad\quad l \in H \setminus F \tag{Def. of $L$}\\
		&\quad\quad \text{Exists } C \in ec(\gamma) \text{ s.t. } l \in C \tag{Def. of partition}\\
		&\quad\quad l \in \bigsqcup_{C \in ec(\gamma)} C\\
		&\quad\textbf{case } \bigsqcup_{C \in ec(\gamma')} C\\
		&\quad\quad l \in H \setminus (F \sqcup g) \tag{Def. of partition}\\
		&\quad\quad l \in H \setminus F \\
		&\quad\quad \text{Exists } C \in ec(\gamma) \text{ s.t. } l \in C \tag{Def. of partition}\\
		&\quad\quad l \in \bigsqcup_{C \in ec(\gamma)} C\\
		&\quad\text{Hence we show that } |D_2| = |L \sqcup \oh{\gamma'}|, \text{ and together with the previous 
		equality, } |j| + |\oh{\gamma}| = |g| + |\oh{\gamma'}|\\
		&\text{Thus we have } W',Y,S,F \cup j \preceq V',H,R,F \cup g\\
  	&V',H,R,F \cup g\; \vdash^{\mathsf{copy}} e_1 \Downarrow v, H',F' \tag{case}\\
		&\text{By IH on $(V',H,R,F\cup g)$, we have } (w,Y',M',\gamma'') \text{ such that }\\
		&\emph{(1)}\quad  W',Y,S,M \cup j  \vdash^{\mathsf{free}} e_1 \Downarrow w,Y',M'\\
		&\emph{(2)}\quad \veq{H'}{Y'}{v}{w}\\
		&\emph{(3)}\quad \gamma' \text{ is a proper partition, and } |\gamma''(l)| = 
			reach_{Y'}(w)(l) + R(l)\\
		&\emph{(4)}\quad \gamma''(l) \cap R = \gamma'(l) \cap R \\
		&\quad \gamma'(l) \cap R = (\gamma(l) \setminus g) \cap R= \gamma(l) \cap R\\
		&\emph{(5)}\quad |M'| = |F'| + |\oh{\gamma''}|\\
		&\text{Apply F:CondT to \emph{(1)}, we are done.}
  \end{align*}
  \item[Case 6: E:CondF] 
  Similar to E:CondT
  \item[Case 7: E:Let]
  \begin{align*}
		&V,H,R,F \; \vdash \irl{let}(e_1; x : \tau.e_2) \Downarrow v_2,H_2,F_2 \tag{case}\\
		&W,Y,S,M \preceq V,H,R,F \tag{assumption}\\
		&V_1,H,R',F \vdash e_1 \Downarrow v_1,H_1,F_1 \tag{admissibility}\\
		&\text{Let } W_1 = W \restriction_{FV(e_1)}, S' = S \uplus locs_{W,Y}(\irl{lam}(x : \tau.e_2))\\
		&\text{NTS } W_1,Y,S',M \preceq V_1,H,R',F\\
		&\emph{(1)}\quad W_1,Y \sim V_1,H \tag{condition 1. of $\preceq$}\\
		&\emph{(2)a.}\quad \gamma \text{ is a proper partition } \tag{condition 2. of $\preceq$}\\
		&\emph{(2).b}\quad \text{NTS } |\gamma(l)| = reach_Y(W')(l) + S'(l)\\
		&\quad |\gamma(l)| = reach_Y(W)(l) + S(l) \tag{condition 2. of $\preceq$}\\
		&\quad = reach_Y(W')(l) + reach_Y(W\restriction_{FV(e_2)\setminus \{x\}})(l) + S(l)\\
		&\quad = reach_Y(W')(l) + S'(l)\\
		&\emph{(3)}\quad \text{Let. } l \in dom(\gamma), x \in dom(W'), P \text{ valid sequence of 
		directions. Have }\\
		&\quad |reach_H(V'(x;P)) \cap \gamma(l) = reach_Y(W'(x;P))(l) 
			\tag{condition 3. of $\preceq$}\\
		&\emph{(4).a}\quad \text{NTS } S' \subseteq dom(Y)\setminus M\\
		&\quad S \subseteq dom(Y)\setminus M \tag{condition 4. of $\preceq$}\\
		&\quad locs_{W,Y}(\irl{lam}(x : \tau.e_2)) \subseteq reach_Y(W) \subseteq dom(Y) \setminus M
			\tag{well-formed configuration}\\
		&\quad S' \subseteq dom(Y)\setminus M\\ 
		&\emph{(4).b}\quad \text{Let } l \in S'. \text{ NTS } |\gamma(l) \cap R'| = S'(l)\\
		&\quad \text{STS }  |\gamma(l) \cap (R \cup reach_H(FV(e_2) \setminus \{x\})| = S(l) + 
			reach_Y(FV(e_2) \setminus \{x\})(l)\\
		&\quad \text{STS } |(\gamma(l) \cap R) \cup (\gamma(l) \cap 
			reach_H(V(FV(e_2) \setminus \{x\})))| 
			= S(l) + reach_Y(W(FV(e_2) \setminus \{x\}))(l)\\
		&\quad \text{STS } |(\gamma(l) \cap R)| + |\gamma(l) \cap reach_H(V(FV(e_2) \setminus \{x\}))| 
			= S(l) + reach_Y(W(FV(e_2) \setminus \{x\}))(l) 
			\tag{$R \cap reach_H(V(FV(e_2) \setminus \{x\})) = \emptyset$}\\
		&\quad \text{STS } |\gamma(l) \cap reach_H(V(FV(e_2) \setminus \{x\}))| 
			= reach_Y(W(FV(e_2) \setminus \{x\}))(l) \tag{condition 4. of $\preceq$}\\
		&\quad \text{STS } |\gamma(l) \cap \bigcup_{x' \in FV(e_2) \setminus \{x\}} reach_H(V(x'))|
			= (\biguplus_{x' \in FV(e_2) \setminus \{x\}} reach_Y(W(x')))(l)\\
		&\quad \text{Let } x' \in FV(e_2) \setminus \{x\}\\
		&\quad |\gamma(l) \cap reach_H(V(x'))| = reach_Y(W(x'))(l) \tag{condition 3. of $\preceq$}\\
		&\emph{(5)}\quad \text{Have } |M| = |F| + |\oh{\gamma}| \tag{condition 5. of $\preceq$}\\
		&\text{By IH on first premise, have the following: }\\
		&\text{Fact 1}. W',Y,S',M \vdash^{\mathsf{free}} e \Downarrow w_1,Y_1,M_1\\
		&\text{Fact 2}. \veq{H_1}{Y_1}{v}{w}\\
		&\text{Fact 3}. \gamma_1 \text{ is a proper partition, such that for all } l \in dom(\gamma_1),
				|\gamma_1(l)| = |reach_{Y_1}(w_1)(l)| + S(l)\\
		&\text{Fact 4}. \text{For all } P, |reach_{H_1}(find_{H_1}(v_1;P)) \cap \gamma_1(l)| = 
				reach_{Y_1}(find_{Y_1}(w_1;P))(l)\\
		&\text{Fact 5}. \gamma_1(l) \cap R' = \gamma(l) \cap R'\\
		&\text{Fact 6}. |M_1| = |F_1| + |\oh{\gamma_1}|\\
		&V_2,H_1,R, F_1 \cup g \vdash e_2 \Downarrow v_2,H_2,F_2 \tag{admissibility}\\
		&\text{Let } W_2 = (W[x \mapsto w_1])\restriction_{FV(e_2)}, 
			j = \{ l \in H_1 \mid l \notin M_1 \cup S \cup locs_{W_2,Y_1}(e_2) \}\\
		&\text{NTS } W_2,Y_1,S,M_1 \cup j \preceq V_2,H_1,R, F_1 \cup g\\
		&\emph{(1)}\quad W_2,Y_1 \sim V_2,H_1 \tag{condition 1. of $\preceq$ and Fact 1}\\
		&\emph{(2)}\quad \text{Let } \gamma_2 : dom(Y_1) \setminus (M_1 cup j) 
			\to \mathcal{P}(dom(H_1)\setminus (F_1 \cup g)) \text{ be defined by } 
			\gamma_2(l) = \gamma_1(l) \setminus g\\
		&\quad \text{NTS } |\gamma_2(l)| = reach_{Y_1}(W_2)(l) + S(l)\\
		&\quad
  \end{align*}
	\item[Case 8: E:Pair]
  Similar to E:Const*
  \item[Case 9: E:MatP]
  Similar to E:MatCons
  \item[Case 10: E:Nil]
  Similar to E:Const*
  \item[Case 11: E:Cons]
  \begin{align*}
  \end{align*}
  \item[Case 12: E:MatNil]
  Similar to E:Cond*
  \item[Case 13: E:MatCons]
  \begin{align*}
  \end{align*}
  \item[Case 14: E:Share]
	\begin{align*}
		&V,H,R,F \; \vdash^{\mathsf{copy}} \sharecpcst{x}{x_1}{x_2}{e} \Downarrow v,H'',F' \tag{case}\\
		&\text{Suppose } H'' \vDash v \mapsto a : A. 
			\text{ We need to show a configuration and a triple that satisfies the 3 post-conditions.}\\
		&\text{By IH, we have } (w,K,M) \text{ such that }\\
		&\emph{(1)}\quad V_2,H',R,F \setminus L \vdash^{\mathsf{free}} e \Downarrow w,K,M \tag{F:Var}\\
		&\emph{(2)}\quad K \vDash w \mapsto a : A \\
		&\emph{(3)}\quad |M| \ge |F'|\\
		&
	\end{align*}
  \end{description}
\end{proof}

\label{sect:bib}
\bibliographystyle{plain}
%\bibliographystyle{alpha}
%\bibliographystyle{unsrt}
%\bibliographystyle{abbrv}
\bibliography{rules5}


\section{Examples}

For brevity, we write the following examples using an extended syntax which is not in let-normal form, but
which is equivalent to the restricted syntax in expressiveness and semantics. The 
program and signature is populated with top level let declarations.\\

\emph{append}:

\begin{verbatim}
let rec append (l1, l2) =
  match l1 with
    | [] -> l2
    | x::xs -> let r = append (xs, l2) in x::r
\end{verbatim}

$P = [\texttt{append} \mapsto e_{\texttt{append}}]$\\
$\Sigma = [\texttt{append} \xrightarrow{q/q} \prodtycst{L^p(A)}{L^p(A)} \to \L^p(A)]$\\

Type derivation:
\begin{tiny}
\[
\infer[\text{L:MatL}]{
	\Sigma; l_1 : L^p(A), l_2 : L^p(A) \sststile{q}{q} 
		\listcaseexcst{l_1}{l_2}{x}{xs}{\irl{let}\; r = append(xs,l_2) \; \irl{in}\; x::r } : L^p(A)
}{
	\infer[\text{L:Var}]{
		\Sigma; l_2 : L^p(A) \sststile{q}{q} l_2 : L^p(A)
	}{
	}&
	\infer[\text{L:Let}]{
		\Sigma; l_2 : L^p(A), x : A, xs : L^p(A) \sststile{q}{q + p + 1} 
				\irl{let}\; r = append(xs,l_2) \; \irl{in}\; x::r : L^p(A)
	}{
		\infer[\text{L:App}]{
			\Sigma; L_2 : L^p(A), xs : L^p(A) \sststile{q+p+1}{q+p+1} append(xs,l_2) : L^p(A)
		}{
			append : \xrightarrow{q/q} \prodtycst{L^p(A)}{L^p(A)} \to \L^p(A) \in \Sigma
		}&
		\infer[\text{L:Cons}]{
			\Sigma; x : A, r : L^p(A) \sststile{q}{q+p+1} x::r : L^p(A)
		}{
		}
	}
}
\]
\end{tiny}

This can be read as \texttt{append} takes two lists, each with potential $p$ per element, and a constant
potential $q$, and returns a list with potential $p$ per element and constant potential $q$. This 
bound is tight and reflects the fact that append is constructing the concatenation ``in place'' by 
collecting the cells in $l_1$. Thus, append induces no overhead heap cells in addition to its arguments.\\

Now we show that quicksort is also has no overhead. First, the partition:\\

\begin{verbatim}
let rec partition (p, l) =
  match l with
    | [] -> ([],[])
    | x::xs ->
      let (l1,l2) = partition xs in
      let r = x < p in
      if r then
        (x::l1,l2)
      else
        (l1,x::l2)
\end{verbatim}

$P = [partition \mapsto e_{partition}]$\\
$\Sigma = [partition \mapsto \prodtycst{\irl{nat}}{L^p(\irl{nat})} \xrightarrow{} \prodtycst{L^p(\irl{nat})}{L^p(\irl{nat})}]$\\
The type derivation for the Cons branch:

\[
\infer[]{
	\Sigma; p : \irl{nat}, x : \irl{nat}, xs : L^p(\irl{nat}) \sststile{}{} 
		\irl{let}\; r = \; \irl{in}\; x::r 
}{
}
\]	
\begin{verbatim}
let rec quicksort l = 
match l with
  | [] -> []
  | x::xs ->
      let ys, zs = partition (x,xs) in
			let l1 = quicksort ys in 
			let l2 = quicksort zs in 
			let r = x :: l2 in
      append (l1, r)
\end{verbatim}

\iffalse
\emph{map}: 

\begin{verbatim}
let rec map (f,l) = 
	match l with
	| [] -> []
	| x::xs -> let r = f x in r :: map (f, xs)
\end{verbatim}

$P = [\texttt{map} \mapsto e_{\texttt{map}}]$\\
$\Sigma = [\texttt{map} \mapsto \prodtycst{A \to B}{L^0(A)} \to \L^0(B)]$\\

Type derivation:

\[
\inferr{
	\Sigma; f : \arrtycst{A}{B}, l : L^0(A) \sststile{}{} \listcaseexcst{l}{[]}{x}{xs}{\appcst{f}{x} :: map(f,xs)} : 
}{
	\inferr{\Sigma; \cdot \sststile{}{} [] : L^0(A)}{
	}(\text{L:Nil})\\
	
	\inferr{\Sigma; f : \arrtycst{A}{B}, x : A, xs : L^0(A) \sststile{}{} f(x) :: map(f,xs)}{
		\inferr{\Sigma; f : \arrtycst{A}{B}, x : A \sststile{}{} }
	}(\text{L:Cons})
}(\text{L:MatL})
\]
\fi

\section{Implementation}

\section{Experimentation}

\section{Future Work}

\end{document}



  \end{align*}
	\item[Case 8: E:Pair]
  Similar to E:Const*
  \item[Case 9: E:MatP]
  Similar to E:MatCons
  \item[Case 10: E:Nil]
  Similar to E:Const*
  \item[Case 11: E:Cons]
  \begin{align*}
  \end{align*}
  \item[Case 12: E:MatNil]
  Similar to E:Cond*
  \item[Case 13: E:MatCons]
  \begin{align*}
  \end{align*}
  \item[Case 14: E:Share]
	\begin{align*}
		&V,H,R,F \; \vdash^{\mathsf{copy}} \sharecpcst{x}{x_1}{x_2}{e} \Downarrow v,H'',F' \tag{case}\\
		&\text{Suppose } H'' \vDash v \mapsto a : A. 
			\text{ We need to show a configuration and a triple that satisfies the 3 post-conditions.}\\
		&\text{By IH, we have } (w,K,M) \text{ such that }\\
		&\emph{(1)}\quad V_2,H',R,F \setminus L \vdash^{\mathsf{free}} e \Downarrow w,K,M \tag{F:Var}\\
		&\emph{(2)}\quad K \vDash w \mapsto a : A \\
		&\emph{(3)}\quad |M| \ge |F'|\\
		&
	\end{align*}
  \end{description}
\end{proof}

\label{sect:bib}
\bibliographystyle{plain}
%\bibliographystyle{alpha}
%\bibliographystyle{unsrt}
%\bibliographystyle{abbrv}
\bibliography{rules5}


\section{Examples}

For brevity, we write the following examples using an extended syntax which is not in let-normal form, but
which is equivalent to the restricted syntax in expressiveness and semantics. The 
program and signature is populated with top level let declarations.\\

\emph{append}:

\begin{verbatim}
let rec append (l1, l2) =
  match l1 with
    | [] -> l2
    | x::xs -> let r = append (xs, l2) in x::r
\end{verbatim}

$P = [\texttt{append} \mapsto e_{\texttt{append}}]$\\
$\Sigma = [\texttt{append} \xrightarrow{q/q} \prodtycst{L^p(A)}{L^p(A)} \to \L^p(A)]$\\

Type derivation:
\begin{tiny}
\[
\infer[\text{L:MatL}]{
	\Sigma; l_1 : L^p(A), l_2 : L^p(A) \sststile{q}{q} 
		\listcaseexcst{l_1}{l_2}{x}{xs}{\irl{let}\; r = append(xs,l_2) \; \irl{in}\; x::r } : L^p(A)
}{
	\infer[\text{L:Var}]{
		\Sigma; l_2 : L^p(A) \sststile{q}{q} l_2 : L^p(A)
	}{
	}&
	\infer[\text{L:Let}]{
		\Sigma; l_2 : L^p(A), x : A, xs : L^p(A) \sststile{q}{q + p + 1} 
				\irl{let}\; r = append(xs,l_2) \; \irl{in}\; x::r : L^p(A)
	}{
		\infer[\text{L:App}]{
			\Sigma; L_2 : L^p(A), xs : L^p(A) \sststile{q+p+1}{q+p+1} append(xs,l_2) : L^p(A)
		}{
			append : \xrightarrow{q/q} \prodtycst{L^p(A)}{L^p(A)} \to \L^p(A) \in \Sigma
		}&
		\infer[\text{L:Cons}]{
			\Sigma; x : A, r : L^p(A) \sststile{q}{q+p+1} x::r : L^p(A)
		}{
		}
	}
}
\]
\end{tiny}

This can be read as \texttt{append} takes two lists, each with potential $p$ per element, and a constant
potential $q$, and returns a list with potential $p$ per element and constant potential $q$. This 
bound is tight and reflects the fact that append is constructing the concatenation ``in place'' by 
collecting the cells in $l_1$. Thus, append induces no overhead heap cells in addition to its arguments.\\

Now we show that quicksort is also has no overhead. First, the partition:\\

\begin{verbatim}
let rec partition (p, l) =
  match l with
    | [] -> ([],[])
    | x::xs ->
      let (l1,l2) = partition xs in
      let r = x < p in
      if r then
        (x::l1,l2)
      else
        (l1,x::l2)
\end{verbatim}

$P = [partition \mapsto e_{partition}]$\\
$\Sigma = [partition \mapsto \prodtycst{\irl{nat}}{L^p(\irl{nat})} \xrightarrow{} \prodtycst{L^p(\irl{nat})}{L^p(\irl{nat})}]$\\
The type derivation for the Cons branch:

\[
\infer[]{
	\Sigma; p : \irl{nat}, x : \irl{nat}, xs : L^p(\irl{nat}) \sststile{}{} 
		\irl{let}\; r = \; \irl{in}\; x::r 
}{
}
\]	
\begin{verbatim}
let rec quicksort l = 
match l with
  | [] -> []
  | x::xs ->
      let ys, zs = partition (x,xs) in
			let l1 = quicksort ys in 
			let l2 = quicksort zs in 
			let r = x :: l2 in
      append (l1, r)
\end{verbatim}

\iffalse
\emph{map}: 

\begin{verbatim}
let rec map (f,l) = 
	match l with
	| [] -> []
	| x::xs -> let r = f x in r :: map (f, xs)
\end{verbatim}

$P = [\texttt{map} \mapsto e_{\texttt{map}}]$\\
$\Sigma = [\texttt{map} \mapsto \prodtycst{A \to B}{L^0(A)} \to \L^0(B)]$\\

Type derivation:

\[
\inferr{
	\Sigma; f : \arrtycst{A}{B}, l : L^0(A) \sststile{}{} \listcaseexcst{l}{[]}{x}{xs}{\appcst{f}{x} :: map(f,xs)} : 
}{
	\inferr{\Sigma; \cdot \sststile{}{} [] : L^0(A)}{
	}(\text{L:Nil})\\
	
	\inferr{\Sigma; f : \arrtycst{A}{B}, x : A, xs : L^0(A) \sststile{}{} f(x) :: map(f,xs)}{
		\inferr{\Sigma; f : \arrtycst{A}{B}, x : A \sststile{}{} }
	}(\text{L:Cons})
}(\text{L:MatL})
\]
\fi

\section{Implementation}

\section{Experimentation}

\section{Future Work}

\end{document}
